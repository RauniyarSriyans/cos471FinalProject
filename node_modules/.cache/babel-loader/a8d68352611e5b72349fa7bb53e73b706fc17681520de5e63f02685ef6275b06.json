{"ast":null,"code":"const debug = require(\"debug\")(\"contract:execute\");\nconst PromiEvent = require(\"./promievent\");\nconst EventEmitter = require(\"events\");\nconst utils = require(\"./utils\");\nconst StatusError = require(\"./statuserror\");\nconst Reason = require(\"./reason\");\nconst handlers = require(\"./handlers\");\nconst override = require(\"./override\");\nconst reformat = require(\"./reformat\");\nconst {\n  sendTransactionManual\n} = require(\"./manual-send\");\nconst execute = {\n  // -----------------------------------  Helpers --------------------------------------------------\n  /**\n   * Retrieves gas estimate multiplied by the set gas multiplier for a `sendTransaction` call.\n   * Lacking an estimate, sets gas to have of latest blockLimit\n   * @param  {Object} params     `sendTransaction` parameters\n   * @param  {Number} blockLimit  most recent network block.blockLimit\n   * @return {Number}             gas estimate\n   */\n  getGasEstimate: function (params, blockLimit) {\n    let stacktrace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const constructor = this;\n    const interfaceAdapter = constructor.interfaceAdapter;\n    const web3 = constructor.web3;\n    return new Promise(function (accept, reject) {\n      // Always prefer gas specified by user (if a user sets gas to 0, that is treated\n      // as undefined here and we do proceed to do gas estimation)\n      if (params.gas) return accept(params.gas);\n      if (!constructor.autoGas) return accept();\n      interfaceAdapter.estimateGas(params, stacktrace).then(gas => {\n        // there are situations where the web3 gas estimation function in interfaceAdapter\n        // fails, specifically when a transaction will revert; we still want to continue\n        // the user flow for debugging purposes if the user has enabled stacktraces; so we provide a\n        // default gas for that situation, equal to half of the blockLimit for the latest block\n        //\n        // note: this means if a transaction will revert but the user does not have stacktracing enabled,\n        // they will get an error from the gas estimation and be unable to proceed; we may need to revisit this\n        if (gas === null) {\n          const defaultGas = utils.bigNumberify(Math.floor(blockLimit / 2));\n          accept(defaultGas.toHexString());\n        } else {\n          const limit = utils.bigNumberify(blockLimit);\n          // if we did get a numerical gas estimate from interfaceAdapter, we\n          // multiply that estimate by the gasMultiplier to help ensure we\n          // have enough gas for the transaction\n          const bestEstimate = utils.multiplyBigNumberByDecimal(utils.bigNumberify(gas), constructor.gasMultiplier);\n          // Check that we don't go over blockLimit\n          bestEstimate.gte(limit) ? accept(limit.sub(1).toHexString()) : accept(bestEstimate.toHexString());\n        }\n      }).catch(error => {\n        //HACK: Frankenstein together an error in a destructive fashion!!\n        debug(\"error: %O\", error);\n        const reason = Reason._extract({\n          error\n        }, web3);\n        error.reason = reason;\n        if (reason) {\n          error.message += ` -- Reason given: ${reason}.`;\n        }\n        reject(error);\n      });\n    });\n  },\n  /**\n   * Prepares simple wrapped calls by checking network and organizing the method inputs into\n   * objects web3 can consume.\n   * @param  {Object} constructor   TruffleContract constructor\n   * @param  {Object} methodABI     Function ABI segment w/ inputs & outputs keys.\n   * @param  {Array}  _arguments    Arguments passed to method invocation\n   * @param  {Boolean}  isCall      Used when preparing a call as opposed to a tx;\n   *                                  skips network checks and ignores default gas prices\n   * @return {Promise}              Resolves object w/ tx params disambiguated from arguments\n   */\n  prepareCall: async function (constructor, methodABI, _arguments, isCall) {\n    let args = Array.prototype.slice.call(_arguments);\n    let params = utils.getTxParams.call(constructor, methodABI, args, isCall);\n    args = utils.convertToEthersBN(args);\n    if (constructor.ens && constructor.ens.enabled) {\n      const {\n        web3\n      } = constructor;\n      const processedValues = await utils.ens.convertENSNames({\n        networkId: constructor.network_id,\n        ens: constructor.ens,\n        inputArgs: args,\n        inputParams: params,\n        methodABI,\n        web3\n      });\n      args = processedValues.args;\n      params = processedValues.params;\n    }\n    //isCall flag used to skip network call for read data (calls type) methods invocation\n    if (isCall) {\n      return {\n        args,\n        params\n      };\n    }\n    const network = await constructor.detectNetwork();\n    return {\n      args,\n      params,\n      network\n    };\n  },\n  /**\n   * Disambiguates between transaction parameter objects and BN / BigNumber objects\n   * @param  {Any}  arg\n   * @return {Boolean}\n   */\n  hasTxParams: function (arg) {\n    return utils.is_object(arg) && !utils.is_big_number(arg);\n  },\n  /**\n   * Parses function arguments to discover if the terminal argument specifies the `defaultBlock`\n   * to execute a call at.\n   * @param  {Array}  args      `arguments` that were passed to method\n   * @param  {Any}    lastArg    terminal argument passed to method\n   * @param  {Array}  methodABI  ABI for the method; null for ABI-less calls\n   * @return {Boolean}           true if final argument is `defaultBlock`\n   */\n  hasDefaultBlock: function (args, lastArg, methodABI) {\n    const expectedArgsCount = methodABI ? methodABI.inputs.length : 0;\n    const hasDefaultBlock = !execute.hasTxParams(lastArg) && args.length > expectedArgsCount;\n    const hasDefaultBlockWithParams = execute.hasTxParams(lastArg) && args.length - 1 > expectedArgsCount;\n    return hasDefaultBlock || hasDefaultBlockWithParams;\n  },\n  // -----------------------------------  Methods --------------------------------------------------\n\n  /**\n   * Executes method as .call and processes optional `defaultBlock` argument.\n   * @param  {Function} fn         method\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}             Return value of the call.\n   */\n  call: function (fn, methodABI, address) {\n    const constructor = this;\n    return function () {\n      let defaultBlock = constructor.web3.eth.defaultBlock || \"latest\";\n      const args = Array.prototype.slice.call(arguments);\n      const lastArg = args[args.length - 1];\n      const promiEvent = new PromiEvent();\n\n      // Extract defaultBlock parameter\n      if (execute.hasDefaultBlock(args, lastArg, methodABI)) {\n        defaultBlock = args.pop();\n      }\n      //skipNetworkCheck flag passed to skip network call for read data (calls type) methods invocation\n      const skipNetworkCheck = true;\n      execute.prepareCall(constructor, methodABI, args, skipNetworkCheck).then(async _ref => {\n        let {\n          args,\n          params\n        } = _ref;\n        let result;\n        params.to = address;\n        promiEvent.eventEmitter.emit(\"execute:call:method\", {\n          fn: fn,\n          args: args,\n          address: address,\n          abi: methodABI,\n          contract: constructor\n        });\n        result = fn //null fn is used for instance.call()\n        ? await fn(...args).call(params, defaultBlock) : await constructor.web3.eth.call(params, defaultBlock);\n        result = reformat.numbers.call(constructor, result, methodABI ? methodABI.outputs : []);\n        return promiEvent.resolve(result);\n      }).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n  /**\n   * Executes method as .send\n   * @param  {Function} fn         Method to invoke\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @param  {String}   address    Deployed address of the targeted instance\n   * @return {PromiEvent}          Resolves a transaction receipt (via the receipt handler)\n   */\n  send: function (fn, methodABI, address) {\n    const constructor = this;\n    const web3 = constructor.web3;\n    return function () {\n      const promiEvent = new PromiEvent(false, constructor.debugger);\n      execute.prepareCall(constructor, methodABI, arguments).then(async _ref2 => {\n        let {\n          args,\n          params,\n          network\n        } = _ref2;\n        const context = {\n          contract: constructor,\n          // Can't name this field `constructor` or `_constructor`\n          promiEvent: promiEvent,\n          blockLimit: network.blockLimit,\n          params: params\n        };\n        params.to = address;\n        params.data = fn ? fn(...args).encodeABI() : params.data;\n        promiEvent.eventEmitter.emit(\"execute:send:method\", {\n          fn,\n          args,\n          address,\n          abi: methodABI,\n          contract: constructor\n        });\n        params.gas = await execute.getGasEstimate.call(constructor, params, network.blockLimit, promiEvent.debug //apply stacktracing mode if promiEvent.debug is true\n        );\n\n        execute.sendTransaction(web3, params, promiEvent, context) //the crazy things we do for stacktracing...\n        .then(receipt => {\n          if (promiEvent.debug) {\n            // in this case, we need to manually invoke the handler since it\n            // hasn't been set up (hack?)\n            handlers.receipt(context, receipt);\n          }\n          //otherwise, just let the handlers handle things\n        }).catch(override.start.bind(constructor, context));\n      }).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n  /**\n   * Deploys an instance\n   * @param  {Object} constructorABI  Constructor ABI segment w/ inputs & outputs keys\n   * @return {PromiEvent}             Resolves a TruffleContract instance\n   */\n  deploy: function (constructorABI) {\n    const constructor = this;\n    const web3 = constructor.web3;\n    return function () {\n      let deferred;\n      const promiEvent = new PromiEvent(false, constructor.debugger, true);\n      execute.prepareCall(constructor, constructorABI, arguments).then(async _ref3 => {\n        let {\n          args,\n          params,\n          network\n        } = _ref3;\n        const {\n          blockLimit\n        } = network;\n        utils.checkLibraries.apply(constructor);\n\n        // Promievent and flag that allows instance to resolve (rather than just receipt)\n        const context = {\n          contract: constructor,\n          promiEvent,\n          blockLimit,\n          onlyEmitReceipt: true\n        };\n        const options = {\n          data: constructor.binary,\n          arguments: args\n        };\n        const contract = new web3.eth.Contract(constructor.abi);\n        params.data = contract.deploy(options).encodeABI();\n        params.gas = await execute.getGasEstimate.call(constructor, params, blockLimit, promiEvent.debug //apply stacktracing mode if promiEvent.debug is true\n        );\n\n        context.params = params;\n        promiEvent.eventEmitter.emit(\"execute:deploy:method\", {\n          args,\n          abi: constructorABI,\n          contract: constructor\n        });\n        deferred = execute.sendTransaction(web3, params, promiEvent, context); //the crazy things we do for stacktracing...\n\n        try {\n          const receipt = await deferred;\n          if (receipt.status !== undefined && !receipt.status) {\n            const reason = await Reason.get(params, web3);\n            const error = new StatusError(params, context.transactionHash, receipt, reason);\n            return context.promiEvent.reject(error);\n          }\n          const web3Instance = new web3.eth.Contract(constructor.abi, receipt.contractAddress);\n          web3Instance.transactionHash = context.transactionHash;\n          context.promiEvent.resolve(new constructor(web3Instance));\n        } catch (web3Error) {\n          // Manage web3's 50 blocks' timeout error.\n          // Web3's own subscriptions go dead here.\n          await override.start.call(constructor, context, web3Error);\n        }\n      }).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n  /**\n   * Begins listening for an event OR manages the event callback\n   * @param  {Function} fn  Solidity event method\n   * @return {Emitter}      Event emitter\n   */\n  event: function (fn) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    let currentLogID = null;\n\n    // Someone upstream is firing duplicates :/\n    function dedupe(id) {\n      return id === currentLogID ? false : currentLogID = id;\n    }\n    return function (params, callback) {\n      if (typeof params === \"function\") {\n        callback = params;\n        params = {};\n      }\n\n      // As callback\n      if (callback !== undefined) {\n        const intermediary = function (err, e) {\n          if (err) return callback(err);\n          if (!dedupe(e.id)) return;\n          callback(null, decode.call(constructor, e, true)[0]);\n        };\n        return constructor.detectNetwork().then(() => fn.call(constructor.events, params, intermediary));\n      }\n\n      // As EventEmitter\n      const emitter = new EventEmitter();\n      constructor.detectNetwork().then(() => {\n        const event = fn(params);\n        event.on(\"data\", e => dedupe(e.id) && emitter.emit(\"data\", decode.call(constructor, e, true)[0]));\n        event.on(\"changed\", e => dedupe(e.id) && emitter.emit(\"changed\", decode.call(constructor, e, true)[0]));\n        event.on(\"error\", e => emitter.emit(\"error\", e));\n      });\n      return emitter;\n    };\n  },\n  /**\n   * Wraps web3 `allEvents`, with additional log decoding\n   * @return {PromiEvent}  EventEmitter\n   */\n  allEvents: function (web3Instance) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    let currentLogID = null;\n\n    // Someone upstream is firing duplicates :/\n    function dedupe(id) {\n      return id === currentLogID ? false : currentLogID = id;\n    }\n    return function (params) {\n      const emitter = new EventEmitter();\n      constructor.detectNetwork().then(() => {\n        const event = web3Instance.events.allEvents(params);\n        event.on(\"data\", e => dedupe(e.id) && emitter.emit(\"data\", decode.call(constructor, e, true)[0]));\n        event.on(\"changed\", e => dedupe(e.id) && emitter.emit(\"changed\", decode.call(constructor, e, true)[0]));\n        event.on(\"error\", e => emitter.emit(\"error\", e));\n      });\n      return emitter;\n    };\n  },\n  /**\n   * Wraps web3 `getPastEvents`, with additional log decoding\n   * @return {Promise}  Resolves array of event objects\n   */\n  getPastEvents: function (web3Instance) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    return function (event, options) {\n      return web3Instance.getPastEvents(event, options).then(events => decode.call(constructor, events, false));\n    };\n  },\n  /**\n   * Estimates gas cost of a method invocation\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  estimate: function (fn, methodABI, address) {\n    const constructor = this;\n    return function () {\n      return execute.prepareCall(constructor, methodABI, arguments).then(async res => fn //null fn is used for instance.estimateGas()\n      ? await fn(...res.args).estimateGas(res.params) : await constructor.web3.eth.estimateGas({\n        ...res.params,\n        to: address\n      }));\n    };\n  },\n  /**\n   *\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  request: function (fn, methodABI, address) {\n    const constructor = this;\n    return function () {\n      return execute.prepareCall(constructor, methodABI, arguments).then(res => {\n        //clone res.params\n        let tx = {};\n        for (let key in res.params) {\n          tx[key] = res.params[key];\n        }\n        //set to\n        tx.to = address;\n        //set data\n        tx.data = fn(...res.args).encodeABI();\n        return tx;\n      });\n    };\n  },\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `estimateGas`\n  estimateDeployment: function () {\n    const constructor = this;\n    const constructorABI = constructor.abi.filter(i => i.type === \"constructor\")[0];\n    return execute.prepareCall(constructor, constructorABI, arguments).then(res => {\n      const options = {\n        data: constructor.binary,\n        arguments: res.args\n      };\n      delete res.params[\"data\"]; // Is this necessary?\n\n      const instance = new constructor.web3.eth.Contract(constructor.abi, res.params);\n      return instance.deploy(options).estimateGas(res.params);\n    });\n  },\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `request`\n  requestDeployment: function () {\n    const constructor = this;\n    const constructorABI = constructor.abi.filter(i => i.type === \"constructor\")[0];\n    return execute.prepareCall(constructor, constructorABI, arguments).then(res => {\n      //clone res.params\n      let tx = {};\n      for (let key in res.params) {\n        tx[key] = res.params[key];\n      }\n      const options = {\n        data: constructor.binary,\n        arguments: res.args\n      };\n      const instance = new constructor.web3.eth.Contract(constructor.abi, res.params);\n      tx.data = instance.deploy(options).encodeABI();\n      return tx;\n    });\n  },\n  //our own custom sendTransaction function, made to mimic web3's,\n  //while also being able to do things, like, say, store the transaction\n  //hash even in case of failure.  it's not as powerful in some ways,\n  //as it just returns an ordinary Promise rather than web3's PromiEvent,\n  //but it's more suited to our purposes (we're not using that PromiEvent\n  //functionality here anyway)\n  //input works the same as input to web3.sendTransaction\n  //(well, OK, it's lacking some things there too, but again, good enough\n  //for our purposes)\n  sendTransaction: async function (web3, params, promiEvent, context) {\n    //if we don't need the debugger, let's not risk any errors on our part,\n    //and just have web3 do everything\n    if (!promiEvent || !promiEvent.debug) {\n      const deferred = web3.eth.sendTransaction(params);\n      handlers.setup(deferred, context);\n      return deferred;\n    }\n    //otherwise, do things manually!\n    //(and skip the PromiEvent stuff :-/ )\n    return sendTransactionManual(web3, params, promiEvent);\n  }\n};\nmodule.exports = execute;","map":{"version":3,"names":["debug","require","PromiEvent","EventEmitter","utils","StatusError","Reason","handlers","override","reformat","sendTransactionManual","execute","getGasEstimate","params","blockLimit","stacktrace","arguments","length","undefined","constructor","interfaceAdapter","web3","Promise","accept","reject","gas","autoGas","estimateGas","then","defaultGas","bigNumberify","Math","floor","toHexString","limit","bestEstimate","multiplyBigNumberByDecimal","gasMultiplier","gte","sub","catch","error","reason","_extract","message","prepareCall","methodABI","_arguments","isCall","args","Array","prototype","slice","call","getTxParams","convertToEthersBN","ens","enabled","processedValues","convertENSNames","networkId","network_id","inputArgs","inputParams","network","detectNetwork","hasTxParams","arg","is_object","is_big_number","hasDefaultBlock","lastArg","expectedArgsCount","inputs","hasDefaultBlockWithParams","fn","address","defaultBlock","eth","promiEvent","pop","skipNetworkCheck","_ref","result","to","eventEmitter","emit","abi","contract","numbers","outputs","resolve","send","debugger","_ref2","context","data","encodeABI","sendTransaction","receipt","start","bind","deploy","constructorABI","deferred","_ref3","checkLibraries","apply","onlyEmitReceipt","options","binary","Contract","status","get","transactionHash","web3Instance","contractAddress","web3Error","event","decode","decodeLogs","currentLogID","dedupe","id","callback","intermediary","err","e","events","emitter","on","allEvents","getPastEvents","estimate","res","request","tx","key","estimateDeployment","filter","i","type","instance","requestDeployment","setup","module","exports"],"sources":["/Users/karimelbarbary/Desktop/test4/devote/node_modules/@truffle/contract/lib/execute.js"],"sourcesContent":["const debug = require(\"debug\")(\"contract:execute\");\nconst PromiEvent = require(\"./promievent\");\nconst EventEmitter = require(\"events\");\nconst utils = require(\"./utils\");\nconst StatusError = require(\"./statuserror\");\nconst Reason = require(\"./reason\");\nconst handlers = require(\"./handlers\");\nconst override = require(\"./override\");\nconst reformat = require(\"./reformat\");\nconst { sendTransactionManual } = require(\"./manual-send\");\n\nconst execute = {\n  // -----------------------------------  Helpers --------------------------------------------------\n  /**\n   * Retrieves gas estimate multiplied by the set gas multiplier for a `sendTransaction` call.\n   * Lacking an estimate, sets gas to have of latest blockLimit\n   * @param  {Object} params     `sendTransaction` parameters\n   * @param  {Number} blockLimit  most recent network block.blockLimit\n   * @return {Number}             gas estimate\n   */\n  getGasEstimate: function (params, blockLimit, stacktrace = false) {\n    const constructor = this;\n    const interfaceAdapter = constructor.interfaceAdapter;\n    const web3 = constructor.web3;\n\n    return new Promise(function (accept, reject) {\n      // Always prefer gas specified by user (if a user sets gas to 0, that is treated\n      // as undefined here and we do proceed to do gas estimation)\n      if (params.gas) return accept(params.gas);\n      if (!constructor.autoGas) return accept();\n\n      interfaceAdapter\n        .estimateGas(params, stacktrace)\n        .then(gas => {\n          // there are situations where the web3 gas estimation function in interfaceAdapter\n          // fails, specifically when a transaction will revert; we still want to continue\n          // the user flow for debugging purposes if the user has enabled stacktraces; so we provide a\n          // default gas for that situation, equal to half of the blockLimit for the latest block\n          //\n          // note: this means if a transaction will revert but the user does not have stacktracing enabled,\n          // they will get an error from the gas estimation and be unable to proceed; we may need to revisit this\n          if (gas === null) {\n            const defaultGas = utils.bigNumberify(Math.floor(blockLimit / 2));\n            accept(defaultGas.toHexString());\n          } else {\n            const limit = utils.bigNumberify(blockLimit);\n            // if we did get a numerical gas estimate from interfaceAdapter, we\n            // multiply that estimate by the gasMultiplier to help ensure we\n            // have enough gas for the transaction\n            const bestEstimate = utils.multiplyBigNumberByDecimal(\n              utils.bigNumberify(gas),\n              constructor.gasMultiplier\n            );\n            // Check that we don't go over blockLimit\n            bestEstimate.gte(limit)\n              ? accept(limit.sub(1).toHexString())\n              : accept(bestEstimate.toHexString());\n          }\n        })\n        .catch(error => {\n          //HACK: Frankenstein together an error in a destructive fashion!!\n          debug(\"error: %O\", error);\n          const reason = Reason._extract({ error }, web3);\n          error.reason = reason;\n          if (reason) {\n            error.message += ` -- Reason given: ${reason}.`;\n          }\n          reject(error);\n        });\n    });\n  },\n\n  /**\n   * Prepares simple wrapped calls by checking network and organizing the method inputs into\n   * objects web3 can consume.\n   * @param  {Object} constructor   TruffleContract constructor\n   * @param  {Object} methodABI     Function ABI segment w/ inputs & outputs keys.\n   * @param  {Array}  _arguments    Arguments passed to method invocation\n   * @param  {Boolean}  isCall      Used when preparing a call as opposed to a tx;\n   *                                  skips network checks and ignores default gas prices\n   * @return {Promise}              Resolves object w/ tx params disambiguated from arguments\n   */\n  prepareCall: async function (constructor, methodABI, _arguments, isCall) {\n    let args = Array.prototype.slice.call(_arguments);\n    let params = utils.getTxParams.call(constructor, methodABI, args, isCall);\n\n    args = utils.convertToEthersBN(args);\n\n    if (constructor.ens && constructor.ens.enabled) {\n      const { web3 } = constructor;\n      const processedValues = await utils.ens.convertENSNames({\n        networkId: constructor.network_id,\n        ens: constructor.ens,\n        inputArgs: args,\n        inputParams: params,\n        methodABI,\n        web3\n      });\n      args = processedValues.args;\n      params = processedValues.params;\n    }\n    //isCall flag used to skip network call for read data (calls type) methods invocation\n    if (isCall) {\n      return { args, params };\n    }\n    const network = await constructor.detectNetwork();\n    return { args, params, network };\n  },\n\n  /**\n   * Disambiguates between transaction parameter objects and BN / BigNumber objects\n   * @param  {Any}  arg\n   * @return {Boolean}\n   */\n  hasTxParams: function (arg) {\n    return utils.is_object(arg) && !utils.is_big_number(arg);\n  },\n\n  /**\n   * Parses function arguments to discover if the terminal argument specifies the `defaultBlock`\n   * to execute a call at.\n   * @param  {Array}  args      `arguments` that were passed to method\n   * @param  {Any}    lastArg    terminal argument passed to method\n   * @param  {Array}  methodABI  ABI for the method; null for ABI-less calls\n   * @return {Boolean}           true if final argument is `defaultBlock`\n   */\n  hasDefaultBlock: function (args, lastArg, methodABI) {\n    const expectedArgsCount = methodABI ? methodABI.inputs.length : 0;\n    const hasDefaultBlock =\n      !execute.hasTxParams(lastArg) && args.length > expectedArgsCount;\n    const hasDefaultBlockWithParams =\n      execute.hasTxParams(lastArg) && args.length - 1 > expectedArgsCount;\n    return hasDefaultBlock || hasDefaultBlockWithParams;\n  },\n\n  // -----------------------------------  Methods --------------------------------------------------\n\n  /**\n   * Executes method as .call and processes optional `defaultBlock` argument.\n   * @param  {Function} fn         method\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}             Return value of the call.\n   */\n  call: function (fn, methodABI, address) {\n    const constructor = this;\n\n    return function () {\n      let defaultBlock = constructor.web3.eth.defaultBlock || \"latest\";\n      const args = Array.prototype.slice.call(arguments);\n      const lastArg = args[args.length - 1];\n      const promiEvent = new PromiEvent();\n\n      // Extract defaultBlock parameter\n      if (execute.hasDefaultBlock(args, lastArg, methodABI)) {\n        defaultBlock = args.pop();\n      }\n      //skipNetworkCheck flag passed to skip network call for read data (calls type) methods invocation\n      const skipNetworkCheck = true;\n      execute\n        .prepareCall(constructor, methodABI, args, skipNetworkCheck)\n        .then(async ({ args, params }) => {\n          let result;\n\n          params.to = address;\n\n          promiEvent.eventEmitter.emit(\"execute:call:method\", {\n            fn: fn,\n            args: args,\n            address: address,\n            abi: methodABI,\n            contract: constructor\n          });\n\n          result = fn //null fn is used for instance.call()\n            ? await fn(...args).call(params, defaultBlock)\n            : await constructor.web3.eth.call(params, defaultBlock);\n          result = reformat.numbers.call(\n            constructor,\n            result,\n            methodABI ? methodABI.outputs : []\n          );\n          return promiEvent.resolve(result);\n        })\n        .catch(promiEvent.reject);\n\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Executes method as .send\n   * @param  {Function} fn         Method to invoke\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @param  {String}   address    Deployed address of the targeted instance\n   * @return {PromiEvent}          Resolves a transaction receipt (via the receipt handler)\n   */\n  send: function (fn, methodABI, address) {\n    const constructor = this;\n    const web3 = constructor.web3;\n\n    return function () {\n      const promiEvent = new PromiEvent(false, constructor.debugger);\n\n      execute\n        .prepareCall(constructor, methodABI, arguments)\n        .then(async ({ args, params, network }) => {\n          const context = {\n            contract: constructor, // Can't name this field `constructor` or `_constructor`\n            promiEvent: promiEvent,\n            blockLimit: network.blockLimit,\n            params: params\n          };\n\n          params.to = address;\n          params.data = fn ? fn(...args).encodeABI() : params.data;\n\n          promiEvent.eventEmitter.emit(\"execute:send:method\", {\n            fn,\n            args,\n            address,\n            abi: methodABI,\n            contract: constructor\n          });\n\n          params.gas = await execute.getGasEstimate.call(\n            constructor,\n            params,\n            network.blockLimit,\n            promiEvent.debug //apply stacktracing mode if promiEvent.debug is true\n          );\n\n          execute\n            .sendTransaction(web3, params, promiEvent, context) //the crazy things we do for stacktracing...\n            .then(receipt => {\n              if (promiEvent.debug) {\n                // in this case, we need to manually invoke the handler since it\n                // hasn't been set up (hack?)\n                handlers.receipt(context, receipt);\n              }\n              //otherwise, just let the handlers handle things\n            })\n            .catch(override.start.bind(constructor, context));\n        })\n        .catch(promiEvent.reject);\n\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Deploys an instance\n   * @param  {Object} constructorABI  Constructor ABI segment w/ inputs & outputs keys\n   * @return {PromiEvent}             Resolves a TruffleContract instance\n   */\n  deploy: function (constructorABI) {\n    const constructor = this;\n    const web3 = constructor.web3;\n\n    return function () {\n      let deferred;\n      const promiEvent = new PromiEvent(false, constructor.debugger, true);\n\n      execute\n        .prepareCall(constructor, constructorABI, arguments)\n        .then(async ({ args, params, network }) => {\n          const { blockLimit } = network;\n\n          utils.checkLibraries.apply(constructor);\n\n          // Promievent and flag that allows instance to resolve (rather than just receipt)\n          const context = {\n            contract: constructor,\n            promiEvent,\n            blockLimit,\n            onlyEmitReceipt: true\n          };\n\n          const options = {\n            data: constructor.binary,\n            arguments: args\n          };\n\n          const contract = new web3.eth.Contract(constructor.abi);\n          params.data = contract.deploy(options).encodeABI();\n\n          params.gas = await execute.getGasEstimate.call(\n            constructor,\n            params,\n            blockLimit,\n            promiEvent.debug //apply stacktracing mode if promiEvent.debug is true\n          );\n\n          context.params = params;\n\n          promiEvent.eventEmitter.emit(\"execute:deploy:method\", {\n            args,\n            abi: constructorABI,\n            contract: constructor\n          });\n\n          deferred = execute.sendTransaction(web3, params, promiEvent, context); //the crazy things we do for stacktracing...\n\n          try {\n            const receipt = await deferred;\n            if (receipt.status !== undefined && !receipt.status) {\n              const reason = await Reason.get(params, web3);\n\n              const error = new StatusError(\n                params,\n                context.transactionHash,\n                receipt,\n                reason\n              );\n\n              return context.promiEvent.reject(error);\n            }\n\n            const web3Instance = new web3.eth.Contract(\n              constructor.abi,\n              receipt.contractAddress\n            );\n            web3Instance.transactionHash = context.transactionHash;\n\n            context.promiEvent.resolve(new constructor(web3Instance));\n          } catch (web3Error) {\n            // Manage web3's 50 blocks' timeout error.\n            // Web3's own subscriptions go dead here.\n            await override.start.call(constructor, context, web3Error);\n          }\n        })\n        .catch(promiEvent.reject);\n\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Begins listening for an event OR manages the event callback\n   * @param  {Function} fn  Solidity event method\n   * @return {Emitter}      Event emitter\n   */\n  event: function (fn) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    let currentLogID = null;\n\n    // Someone upstream is firing duplicates :/\n    function dedupe(id) {\n      return id === currentLogID ? false : (currentLogID = id);\n    }\n\n    return function (params, callback) {\n      if (typeof params === \"function\") {\n        callback = params;\n        params = {};\n      }\n\n      // As callback\n      if (callback !== undefined) {\n        const intermediary = function (err, e) {\n          if (err) return callback(err);\n          if (!dedupe(e.id)) return;\n          callback(null, decode.call(constructor, e, true)[0]);\n        };\n\n        return constructor\n          .detectNetwork()\n          .then(() => fn.call(constructor.events, params, intermediary));\n      }\n\n      // As EventEmitter\n      const emitter = new EventEmitter();\n\n      constructor.detectNetwork().then(() => {\n        const event = fn(params);\n\n        event.on(\n          \"data\",\n          e =>\n            dedupe(e.id) &&\n            emitter.emit(\"data\", decode.call(constructor, e, true)[0])\n        );\n        event.on(\n          \"changed\",\n          e =>\n            dedupe(e.id) &&\n            emitter.emit(\"changed\", decode.call(constructor, e, true)[0])\n        );\n        event.on(\"error\", e => emitter.emit(\"error\", e));\n      });\n\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `allEvents`, with additional log decoding\n   * @return {PromiEvent}  EventEmitter\n   */\n  allEvents: function (web3Instance) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    let currentLogID = null;\n\n    // Someone upstream is firing duplicates :/\n    function dedupe(id) {\n      return id === currentLogID ? false : (currentLogID = id);\n    }\n\n    return function (params) {\n      const emitter = new EventEmitter();\n\n      constructor.detectNetwork().then(() => {\n        const event = web3Instance.events.allEvents(params);\n\n        event.on(\n          \"data\",\n          e =>\n            dedupe(e.id) &&\n            emitter.emit(\"data\", decode.call(constructor, e, true)[0])\n        );\n        event.on(\n          \"changed\",\n          e =>\n            dedupe(e.id) &&\n            emitter.emit(\"changed\", decode.call(constructor, e, true)[0])\n        );\n        event.on(\"error\", e => emitter.emit(\"error\", e));\n      });\n\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `getPastEvents`, with additional log decoding\n   * @return {Promise}  Resolves array of event objects\n   */\n  getPastEvents: function (web3Instance) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n\n    return function (event, options) {\n      return web3Instance\n        .getPastEvents(event, options)\n        .then(events => decode.call(constructor, events, false));\n    };\n  },\n\n  /**\n   * Estimates gas cost of a method invocation\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  estimate: function (fn, methodABI, address) {\n    const constructor = this;\n    return function () {\n      return execute\n        .prepareCall(constructor, methodABI, arguments)\n        .then(async res =>\n          fn //null fn is used for instance.estimateGas()\n            ? await fn(...res.args).estimateGas(res.params)\n            : await constructor.web3.eth.estimateGas({\n                ...res.params,\n                to: address\n              })\n        );\n    };\n  },\n\n  /**\n   *\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  request: function (fn, methodABI, address) {\n    const constructor = this;\n    return function () {\n      return execute\n        .prepareCall(constructor, methodABI, arguments)\n        .then(res => {\n          //clone res.params\n          let tx = {};\n          for (let key in res.params) {\n            tx[key] = res.params[key];\n          }\n          //set to\n          tx.to = address;\n          //set data\n          tx.data = fn(...res.args).encodeABI();\n          return tx;\n        });\n    };\n  },\n\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `estimateGas`\n  estimateDeployment: function () {\n    const constructor = this;\n\n    const constructorABI = constructor.abi.filter(\n      i => i.type === \"constructor\"\n    )[0];\n\n    return execute\n      .prepareCall(constructor, constructorABI, arguments)\n      .then(res => {\n        const options = {\n          data: constructor.binary,\n          arguments: res.args\n        };\n\n        delete res.params[\"data\"]; // Is this necessary?\n\n        const instance = new constructor.web3.eth.Contract(\n          constructor.abi,\n          res.params\n        );\n        return instance.deploy(options).estimateGas(res.params);\n      });\n  },\n\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `request`\n  requestDeployment: function () {\n    const constructor = this;\n\n    const constructorABI = constructor.abi.filter(\n      i => i.type === \"constructor\"\n    )[0];\n\n    return execute\n      .prepareCall(constructor, constructorABI, arguments)\n      .then(res => {\n        //clone res.params\n        let tx = {};\n        for (let key in res.params) {\n          tx[key] = res.params[key];\n        }\n\n        const options = {\n          data: constructor.binary,\n          arguments: res.args\n        };\n\n        const instance = new constructor.web3.eth.Contract(\n          constructor.abi,\n          res.params\n        );\n        tx.data = instance.deploy(options).encodeABI();\n        return tx;\n      });\n  },\n\n  //our own custom sendTransaction function, made to mimic web3's,\n  //while also being able to do things, like, say, store the transaction\n  //hash even in case of failure.  it's not as powerful in some ways,\n  //as it just returns an ordinary Promise rather than web3's PromiEvent,\n  //but it's more suited to our purposes (we're not using that PromiEvent\n  //functionality here anyway)\n  //input works the same as input to web3.sendTransaction\n  //(well, OK, it's lacking some things there too, but again, good enough\n  //for our purposes)\n  sendTransaction: async function (web3, params, promiEvent, context) {\n    //if we don't need the debugger, let's not risk any errors on our part,\n    //and just have web3 do everything\n    if (!promiEvent || !promiEvent.debug) {\n      const deferred = web3.eth.sendTransaction(params);\n      handlers.setup(deferred, context);\n      return deferred;\n    }\n    //otherwise, do things manually!\n    //(and skip the PromiEvent stuff :-/ )\n    return sendTransactionManual(web3, params, promiEvent);\n  }\n};\n\nmodule.exports = execute;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}