{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cleanBool = exports.countDecimalPlaces = exports.shiftBigDown = exports.shiftBigUp = exports.stringToBytes = exports.toBytes = exports.toHexString = exports.toBig = exports.toBigInt = exports.toSignedBN = exports.isBig = exports.toBN = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:conversion\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst big_js_1 = __importDefault(require(\"big.js\"));\nconst utf8_1 = __importDefault(require(\"utf8\"));\n/**\n * @param bytes - undefined | string | number | BN | Uint8Array | Big\n * @return {BN}\n */\nfunction toBN(bytes) {\n  if (bytes === undefined) {\n    return undefined;\n  } else if (typeof bytes === \"string\") {\n    return new bn_js_1.default(bytes, 16);\n  } else if (typeof bytes === \"bigint\") {\n    return new bn_js_1.default(bytes.toString(16), 16);\n  } else if (typeof bytes == \"number\" || bn_js_1.default.isBN(bytes)) {\n    return new bn_js_1.default(bytes);\n  } else if (isBig(bytes)) {\n    return new bn_js_1.default(bytes.toFixed()); //warning, better hope input is integer!\n    //note: going through string may seem silly but it's actually not terrible here,\n    //since BN is binary-based and Big is decimal-based\n    //[toFixed is like toString except it guarantees scientific notation is not used]\n  } else if (typeof bytes.reduce === \"function\") {\n    return bytes.reduce((num, byte) => num.shln(8).addn(byte), new bn_js_1.default(0));\n  }\n}\nexports.toBN = toBN;\n//Big doesnt provide this function, so we'll make one ourselves\n//HACK\nfunction isBig(input) {\n  return typeof input === \"object\" && input !== null && (input.s === 1 || input.s === -1) && typeof input.e === \"number\" && Array.isArray(input.c) &&\n  //we want to be sure this is *not* a BigNumber instead,\n  //but we can't use isBigNumber here because we don't want\n  //to import that library here, so, HACK, we'll check that\n  //it lacks a particular BigNumber method that would be meaningless\n  //for Bigs\n  !input.isFinite;\n  //(BigNumbers have this method because it supports Infinity and NaN,\n  //but Big doesn't, so this method doesn't exist, because it would\n  //be pointless)\n}\n\nexports.isBig = isBig;\n/**\n * @param bytes - Uint8Array\n * @return {BN}\n */\nfunction toSignedBN(bytes) {\n  if (bytes[0] < 0x80) {\n    // if first bit is 0\n    return toBN(bytes);\n  } else {\n    return toBN(bytes.map(b => 0xff - b)).addn(1).neg();\n  }\n}\nexports.toSignedBN = toSignedBN;\nfunction toBigInt(value) {\n  //BN is binary-based, so we convert by means of a hex string in order\n  //to avoid having to do a binary-decimal conversion and back :P\n  return !value.isNeg() ? BigInt(\"0x\" + value.toString(16)) : -BigInt(\"0x\" + value.neg().toString(16)); //can't directly make negative BigInt from hex string\n}\n\nexports.toBigInt = toBigInt;\nfunction toBig(value) {\n  //note: going through string may seem silly but it's actually not terrible here,\n  //since BN (& number) is binary-based and Big is decimal-based\n  return new big_js_1.default(value.toString());\n}\nexports.toBig = toBig;\n/**\n * @param bytes - Uint8Array | BN | bigint\n * @param padLength - number - minimum desired byte length (left-pad with zeroes)\n * @param padRight - boolean - causes padding to occur on right instead of left\n * @return {string}\n */\nfunction toHexString(bytes) {\n  let padLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let padRight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (bn_js_1.default.isBN(bytes) || typeof bytes === \"bigint\" || typeof bytes === \"number\" || isBig(bytes)) {\n    bytes = toBytes(bytes);\n  }\n  const pad = s => `${\"00\".slice(0, 2 - s.length)}${s}`;\n  //                                          0  1  2  3  4\n  //                                 0  1  2  3  4  5  6  7\n  // bytes.length:        5  -  0x(          e5 c2 aa 09 11 )\n  // length (preferred):  8  -  0x( 00 00 00 e5 c2 aa 09 11 )\n  //                                `--.---'\n  //                                     offset 3\n  if (bytes.length < padLength) {\n    let prior = bytes;\n    bytes = new Uint8Array(padLength);\n    if (padRight) {\n      //unusual case: pad on right\n      bytes.set(prior);\n    } else {\n      //usual case\n      bytes.set(prior, padLength - prior.length);\n    }\n  }\n  debug(\"bytes: %o\", bytes);\n  let string = bytes.reduce((str, byte) => `${str}${pad(byte.toString(16))}`, \"\");\n  return `0x${string}`;\n}\nexports.toHexString = toHexString;\nfunction toBytes(data) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  //note that length is a minimum output length\n  //strings will be 0-padded on left\n  //numbers/BNs will be sign-padded on left\n  //NOTE: if a number/BN is passed in that is too big for the given length,\n  //you will get an error!\n  //(note that strings passed in should be hex strings; this is not for converting\n  //generic strings to hex)\n  if (typeof data === \"bigint\") {\n    data = data.toString(16);\n  }\n  if (typeof data === \"string\") {\n    let hex = data; //renaming for clarity\n    if (hex.startsWith(\"0x\")) {\n      hex = hex.slice(2);\n    }\n    if (hex === \"\") {\n      //this special case is necessary because the match below will return null,\n      //not an empty array, when given an empty string\n      return new Uint8Array(0);\n    }\n    if (hex.length % 2 == 1) {\n      hex = `0${hex}`;\n    }\n    let bytes = new Uint8Array(hex.match(/.{2}/g).map(byte => parseInt(byte, 16)));\n    if (bytes.length < length) {\n      let prior = bytes;\n      bytes = new Uint8Array(length);\n      bytes.set(prior, length - prior.length);\n    }\n    return bytes;\n  } else {\n    // BN/Big/number case\n    if (typeof data === \"number\") {\n      data = new bn_js_1.default(data);\n    } else if (isBig(data)) {\n      //note: going through string may seem silly but it's actually not terrible here,\n      //since BN is binary-based and Big is decimal-based\n      data = new bn_js_1.default(data.toFixed());\n      //[toFixed is like toString except it guarantees scientific notation is not used]\n    }\n    //note that the argument for toTwos is given in bits\n    return data.toTwos(length * 8).toArrayLike(Uint8Array, \"be\", length);\n    //big-endian\n  }\n}\n\nexports.toBytes = toBytes;\nfunction stringToBytes(input) {\n  input = utf8_1.default.encode(input);\n  let bytes = new Uint8Array(input.length);\n  for (let i = 0; i < input.length; i++) {\n    bytes[i] = input.charCodeAt(i);\n  }\n  return bytes;\n  //NOTE: this will throw an error if the string contained malformed UTF-16!\n  //but, well, it shouldn't contain that...\n}\n\nexports.stringToBytes = stringToBytes;\n//computes value * 10**decimalPlaces\nfunction shiftBigUp(value, decimalPlaces) {\n  let newValue = new big_js_1.default(value);\n  newValue.e += decimalPlaces;\n  return newValue;\n}\nexports.shiftBigUp = shiftBigUp;\n//computes value * 10**-decimalPlaces\nfunction shiftBigDown(value, decimalPlaces) {\n  let newValue = new big_js_1.default(value);\n  newValue.e -= decimalPlaces;\n  return newValue;\n}\nexports.shiftBigDown = shiftBigDown;\nfunction countDecimalPlaces(value) {\n  return Math.max(0, value.c.length - value.e - 1);\n}\nexports.countDecimalPlaces = countDecimalPlaces;\n//converts out of range booleans to true; something of a HACK\n//NOTE: does NOT do this recursively inside structs, arrays, etc!\n//I mean, those aren't elementary and therefore aren't in the domain\n//anyway, but still\nfunction cleanBool(result) {\n  switch (result.kind) {\n    case \"value\":\n      return result;\n    case \"error\":\n      switch (result.error.kind) {\n        case \"BoolOutOfRangeError\":\n          //return true\n          return {\n            type: result.type,\n            kind: \"value\",\n            value: {\n              asBoolean: true\n            }\n          };\n        default:\n          return result;\n      }\n  }\n}\nexports.cleanBool = cleanBool;","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","bn_js_1","big_js_1","utf8_1","toBN","bytes","undefined","toString","isBN","isBig","toFixed","reduce","num","byte","shln","addn","exports","input","s","e","Array","isArray","c","isFinite","toSignedBN","map","b","neg","toBigInt","value","isNeg","BigInt","toBig","toHexString","padLength","arguments","length","padRight","toBytes","pad","slice","prior","Uint8Array","set","string","str","data","hex","startsWith","match","parseInt","toTwos","toArrayLike","stringToBytes","encode","i","charCodeAt","shiftBigUp","decimalPlaces","newValue","shiftBigDown","countDecimalPlaces","Math","max","cleanBool","result","kind","error","type","asBoolean"],"sources":["../../lib/conversion.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}