{"ast":null,"code":"\"use strict\";\n\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.definitionToStoredType = exports.definitionToType = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:ast:import\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst Compiler = __importStar(require(\"../../compiler\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst import_1 = require(\"../../contexts/import\");\n//NOTE: the following function will *not* work for arbitrary nodes! It will,\n//however, work well enough for what we need.  I.e., it will:\n//1. work when given the actual variable definition as the node,\n//2. work when given an elementary type as the node,\n//3. work when given a user-defined type as the node,\n//4. produce something of the correct size in all cases.\n//Use beyond that is at your own risk!\n//NOTE: set forceLocation to *null* to force no location. leave it undefined\n//to not force a location.\nfunction definitionToType(definition, compilationId, compiler, forceLocation) {\n  let typeClass = Utils.typeClass(definition);\n  let typeHint = Utils.typeStringWithoutLocation(definition);\n  switch (typeClass) {\n    case \"bool\":\n      return {\n        typeClass,\n        typeHint\n      };\n    case \"address\":\n      {\n        switch (Compiler.Utils.solidityFamily(compiler)) {\n          case \"unknown\": //I guess?\n          case \"pre-0.5.0\":\n            return {\n              typeClass,\n              kind: \"general\",\n              typeHint\n            };\n          default:\n            return {\n              typeClass,\n              kind: \"specific\",\n              payable: Utils.typeIdentifier(definition) === \"t_address_payable\"\n            };\n        }\n        break; //to satisfy typescript\n      }\n\n    case \"uint\":\n      {\n        let bytes = Utils.specifiedSize(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          typeHint\n        };\n      }\n    case \"int\":\n      {\n        //typeScript won't let me group these for some reason\n        let bytes = Utils.specifiedSize(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          typeHint\n        };\n      }\n    case \"fixed\":\n      {\n        //typeScript won't let me group these for some reason\n        let bytes = Utils.specifiedSize(definition);\n        let places = Utils.decimalPlaces(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          places,\n          typeHint\n        };\n      }\n    case \"ufixed\":\n      {\n        let bytes = Utils.specifiedSize(definition);\n        let places = Utils.decimalPlaces(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          places,\n          typeHint\n        };\n      }\n    case \"string\":\n      {\n        if (forceLocation === null) {\n          return {\n            typeClass,\n            typeHint\n          };\n        }\n        let location = forceLocation || Utils.referenceType(definition);\n        return {\n          typeClass,\n          location,\n          typeHint\n        };\n      }\n    case \"bytes\":\n      {\n        let length = Utils.specifiedSize(definition);\n        if (length !== null) {\n          return {\n            typeClass,\n            kind: \"static\",\n            length,\n            typeHint\n          };\n        } else {\n          if (forceLocation === null) {\n            return {\n              typeClass,\n              kind: \"dynamic\",\n              typeHint\n            };\n          }\n          let location = forceLocation || Utils.referenceType(definition);\n          return {\n            typeClass,\n            kind: \"dynamic\",\n            location,\n            typeHint\n          };\n        }\n      }\n    case \"array\":\n      {\n        let baseDefinition = Utils.baseDefinition(definition);\n        let baseType = definitionToType(baseDefinition, compilationId, compiler, forceLocation);\n        let location = forceLocation || Utils.referenceType(definition);\n        if (Utils.isDynamicArray(definition)) {\n          if (forceLocation !== null) {\n            return {\n              typeClass,\n              baseType,\n              kind: \"dynamic\",\n              location,\n              typeHint\n            };\n          } else {\n            return {\n              typeClass,\n              baseType,\n              kind: \"dynamic\",\n              typeHint\n            };\n          }\n        } else {\n          let length = new bn_js_1.default(Utils.staticLengthAsString(definition));\n          if (forceLocation !== null) {\n            return {\n              typeClass,\n              baseType,\n              kind: \"static\",\n              length,\n              location,\n              typeHint\n            };\n          } else {\n            return {\n              typeClass,\n              baseType,\n              kind: \"static\",\n              length,\n              typeHint\n            };\n          }\n        }\n      }\n    case \"mapping\":\n      {\n        let keyDefinition = Utils.keyDefinition(definition);\n        //note that we can skip the scopes argument here! that's only needed when\n        //a general node, rather than a declaration, is being passed in\n        let keyType = definitionToType(keyDefinition, compilationId, compiler, null);\n        //suppress the location on the key type (it'll be given as memory but\n        //this is meaningless)\n        //also, we have to tell TypeScript ourselves that this will be an elementary\n        //type; it has no way of knowing that\n        debug(\"definition: %O\", definition);\n        let valueDefinition = Utils.valueDefinition(definition);\n        let valueType = definitionToType(valueDefinition, compilationId, compiler, forceLocation);\n        if (forceLocation === null) {\n          return {\n            typeClass,\n            keyType,\n            valueType\n          };\n        }\n        return {\n          typeClass,\n          keyType,\n          valueType,\n          location: \"storage\"\n        };\n      }\n    case \"function\":\n      {\n        //WARNING! This case will not work unless given the actual\n        //definition!  It should return something *roughly* usable, though.\n        let visibility = Utils.visibility(definition); //undefined if bad node\n        let mutability = Utils.mutability(definition); //undefined if bad node\n        let [inputParameters, outputParameters] = Utils.parameters(definition) || [[], []]; //HACK\n        //note: don't force a location on these! use the listed location!\n        let inputParameterTypes = inputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));\n        let outputParameterTypes = outputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));\n        switch (visibility) {\n          case \"internal\":\n            return {\n              typeClass,\n              visibility,\n              mutability,\n              inputParameterTypes,\n              outputParameterTypes\n            };\n          case \"external\":\n            return {\n              typeClass,\n              visibility,\n              kind: \"specific\",\n              mutability,\n              inputParameterTypes,\n              outputParameterTypes\n            };\n        }\n        break; //to satisfy typescript\n      }\n\n    case \"struct\":\n      {\n        let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);\n        let qualifiedName = typeHint.match(/struct (.*)/)[1];\n        let definingContractName;\n        let typeName;\n        if (qualifiedName.includes(\".\")) {\n          [definingContractName, typeName] = qualifiedName.split(\".\");\n        } else {\n          typeName = qualifiedName;\n          //leave definingContractName undefined\n        }\n\n        if (forceLocation === null) {\n          if (definingContractName) {\n            return {\n              typeClass,\n              kind: \"local\",\n              id,\n              typeName,\n              definingContractName\n            };\n          } else {\n            return {\n              typeClass,\n              kind: \"global\",\n              id,\n              typeName\n            };\n          }\n        }\n        let location = forceLocation || Utils.referenceType(definition);\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            location\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName,\n            location\n          };\n        }\n      }\n    case \"enum\":\n      {\n        let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);\n        let qualifiedName = typeHint.match(/enum (.*)/)[1];\n        let definingContractName;\n        let typeName;\n        if (qualifiedName.includes(\".\")) {\n          [definingContractName, typeName] = qualifiedName.split(\".\");\n        } else {\n          typeName = qualifiedName;\n          //leave definingContractName undefined\n        }\n\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName\n          };\n        }\n      }\n    case \"userDefinedValueType\":\n      {\n        let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);\n        let definingContractName;\n        let typeName;\n        if (typeHint.includes(\".\")) {\n          [definingContractName, typeName] = typeHint.split(\".\");\n        } else {\n          typeName = typeHint;\n          //leave definingContractName undefined\n        }\n\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName\n          };\n        }\n      }\n    case \"contract\":\n      {\n        let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);\n        let typeName = typeHint.match(/(contract|library|interface) (.*)/)[2];\n        //note: we use the type string rather than the type identifier\n        //in order to avoid having to deal with the underscore problem\n        let contractKind = Utils.contractKind(definition);\n        return {\n          typeClass,\n          kind: \"native\",\n          id,\n          typeName,\n          contractKind\n        };\n      }\n    case \"magic\":\n      {\n        let typeIdentifier = Utils.typeIdentifier(definition);\n        let variable = typeIdentifier.match(/^t_magic_(.*)$/)[1];\n        return {\n          typeClass,\n          variable\n        };\n      }\n  }\n}\nexports.definitionToType = definitionToType;\n//whereas the above takes variable definitions, this takes the actual type\n//definition\nfunction definitionToStoredType(definition, compilationId, compiler, referenceDeclarations) {\n  switch (definition.nodeType) {\n    case \"StructDefinition\":\n      {\n        const {\n          id,\n          typeName,\n          definingContractName,\n          definingContract\n        } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n        const memberTypes = definition.members.map(member => ({\n          name: member.name,\n          type: definitionToType(member, compilationId, compiler, null)\n        }));\n        if (definingContract) {\n          return {\n            typeClass: \"struct\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            memberTypes\n          };\n        } else {\n          return {\n            typeClass: \"struct\",\n            kind: \"global\",\n            id,\n            typeName,\n            memberTypes\n          };\n        }\n      }\n    case \"EnumDefinition\":\n      {\n        const {\n          id,\n          typeName,\n          definingContractName,\n          definingContract\n        } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n        const options = definition.members.map(member => member.name);\n        if (definingContract) {\n          return {\n            typeClass: \"enum\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            options\n          };\n        } else {\n          return {\n            typeClass: \"enum\",\n            kind: \"global\",\n            id,\n            typeName,\n            options\n          };\n        }\n      }\n    case \"UserDefinedValueTypeDefinition\":\n      {\n        const {\n          id,\n          typeName,\n          definingContractName,\n          definingContract\n        } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n        let underlyingType =\n        //we know it's that, TS doesn't\n        definitionToType(definition.underlyingType, compilationId, compiler, null); //final null doesn't matter here\n        if (definingContract) {\n          return {\n            typeClass: \"userDefinedValueType\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            underlyingType\n          };\n        } else {\n          return {\n            typeClass: \"userDefinedValueType\",\n            kind: \"global\",\n            id,\n            typeName,\n            underlyingType\n          };\n        }\n      }\n    case \"ContractDefinition\":\n      {\n        let id = (0, import_1.makeTypeId)(definition.id, compilationId);\n        let typeName = definition.name;\n        let contractKind = definition.contractKind;\n        let payable = Utils.isContractPayable(definition);\n        return {\n          typeClass: \"contract\",\n          kind: \"native\",\n          id,\n          typeName,\n          contractKind,\n          payable\n        };\n      }\n  }\n}\nexports.definitionToStoredType = definitionToStoredType;\nfunction getDefiningInfo(definition, compilationId, compiler, referenceDeclarations) {\n  const id = (0, import_1.makeTypeId)(definition.id, compilationId);\n  let definingContractName;\n  let typeName;\n  if (definition.canonicalName) {\n    if (definition.canonicalName.includes(\".\")) {\n      [definingContractName, typeName] = definition.canonicalName.split(\".\");\n    } else {\n      typeName = definition.canonicalName;\n    }\n  } else {\n    //due to a bug, in 0.8.8 UDVTs lack a canonicalName.\n    //so we'll set typeName based on name instead of canonicalName,\n    //and set definingContractName below based on definingContract.\n    //(this does mean that we'll mess up a bit if referenceDeclarations\n    //is not passed... but realistically that shouldn't come up?  really the\n    //same kind of hapepns for every type)\n    typeName = definition.name;\n  }\n  let definingContract = undefined;\n  ;\n  if (referenceDeclarations) {\n    let contractDefinition = Object.values(referenceDeclarations).find(node => node.nodeType === \"ContractDefinition\" && node.nodes.some(subNode => (0, import_1.makeTypeId)(subNode.id, compilationId) === id));\n    if (contractDefinition) {\n      definingContract = definitionToStoredType(contractDefinition, compilationId, compiler); //can skip reference declarations\n      if (!definingContractName) {\n        definingContractName = contractDefinition.name;\n      }\n    }\n  }\n  return {\n    definingContract,\n    definingContractName,\n    typeName,\n    id\n  };\n}","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","bn_js_1","Compiler","__importStar","Utils","import_1","definitionToType","definition","compilationId","compiler","forceLocation","typeClass","typeHint","typeStringWithoutLocation","solidityFamily","kind","payable","typeIdentifier","bytes","specifiedSize","bits","places","decimalPlaces","location","referenceType","length","baseDefinition","baseType","isDynamicArray","staticLengthAsString","keyDefinition","keyType","valueDefinition","valueType","visibility","mutability","inputParameters","outputParameters","parameters","inputParameterTypes","map","parameter","outputParameterTypes","id","makeTypeId","typeId","qualifiedName","match","definingContractName","typeName","includes","split","contractKind","variable","exports","definitionToStoredType","referenceDeclarations","nodeType","definingContract","getDefiningInfo","memberTypes","members","member","name","type","options","underlyingType","isContractPayable","canonicalName","undefined","contractDefinition","Object","values","find","node","nodes","some","subNode"],"sources":["../../../../lib/ast/import/index.ts"],"sourcesContent":[null],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,MAAAA,OAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,MAAMC,KAAK,GAAG,IAAAH,OAAA,CAAAI,OAAW,EAAC,kBAAkB,CAAC;AAE7C,MAAAC,OAAA,GAAAJ,eAAA,CAAAC,OAAA;AAGA,MAAAI,QAAA,GAAAC,YAAA,CAAAL,OAAA;AACA,MAAAM,KAAA,GAAAD,YAAA,CAAAL,OAAA;AAEA,MAAAO,QAAA,GAAAP,OAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAgBQ,gBAAgBA,CAC9BC,UAAmB,EACnBC,aAAqB,EACrBC,QAAkC,EAClCC,aAAsC;EAEtC,IAAIC,SAAS,GAAGP,KAAK,CAACO,SAAS,CAACJ,UAAU,CAAC;EAC3C,IAAIK,QAAQ,GAAGR,KAAK,CAACS,yBAAyB,CAACN,UAAU,CAAC;EAC1D,QAAQI,SAAS;IACf,KAAK,MAAM;MACT,OAAO;QACLA,SAAS;QACTC;OACD;IACH,KAAK,SAAS;MAAE;QACd,QAAQV,QAAQ,CAACE,KAAK,CAACU,cAAc,CAACL,QAAQ,CAAC;UAC7C,KAAK,SAAS,CAAC,CAAC;UAChB,KAAK,WAAW;YACd,OAAO;cACLE,SAAS;cACTI,IAAI,EAAE,SAAS;cACfH;aACD;UACH;YACE,OAAO;cACLD,SAAS;cACTI,IAAI,EAAE,UAAU;cAChBC,OAAO,EAAEZ,KAAK,CAACa,cAAc,CAACV,UAAU,CAAC,KAAK;aAC/C;;QAEL,MAAM,CAAC;;;IAET,KAAK,MAAM;MAAE;QACX,IAAIW,KAAK,GAAGd,KAAK,CAACe,aAAa,CAACZ,UAAU,CAAC;QAC3C,OAAO;UACLI,SAAS;UACTS,IAAI,EAAEF,KAAK,GAAG,CAAC;UACfN;SACD;;IAEH,KAAK,KAAK;MAAE;QACV;QACA,IAAIM,KAAK,GAAGd,KAAK,CAACe,aAAa,CAACZ,UAAU,CAAC;QAC3C,OAAO;UACLI,SAAS;UACTS,IAAI,EAAEF,KAAK,GAAG,CAAC;UACfN;SACD;;IAEH,KAAK,OAAO;MAAE;QACZ;QACA,IAAIM,KAAK,GAAGd,KAAK,CAACe,aAAa,CAACZ,UAAU,CAAC;QAC3C,IAAIc,MAAM,GAAGjB,KAAK,CAACkB,aAAa,CAACf,UAAU,CAAC;QAC5C,OAAO;UACLI,SAAS;UACTS,IAAI,EAAEF,KAAK,GAAG,CAAC;UACfG,MAAM;UACNT;SACD;;IAEH,KAAK,QAAQ;MAAE;QACb,IAAIM,KAAK,GAAGd,KAAK,CAACe,aAAa,CAACZ,UAAU,CAAC;QAC3C,IAAIc,MAAM,GAAGjB,KAAK,CAACkB,aAAa,CAACf,UAAU,CAAC;QAC5C,OAAO;UACLI,SAAS;UACTS,IAAI,EAAEF,KAAK,GAAG,CAAC;UACfG,MAAM;UACNT;SACD;;IAEH,KAAK,QAAQ;MAAE;QACb,IAAIF,aAAa,KAAK,IAAI,EAAE;UAC1B,OAAO;YACLC,SAAS;YACTC;WACD;;QAEH,IAAIW,QAAQ,GAAGb,aAAa,IAAIN,KAAK,CAACoB,aAAa,CAACjB,UAAU,CAAC;QAC/D,OAAO;UACLI,SAAS;UACTY,QAAQ;UACRX;SACD;;IAEH,KAAK,OAAO;MAAE;QACZ,IAAIa,MAAM,GAAGrB,KAAK,CAACe,aAAa,CAACZ,UAAU,CAAC;QAC5C,IAAIkB,MAAM,KAAK,IAAI,EAAE;UACnB,OAAO;YACLd,SAAS;YACTI,IAAI,EAAE,QAAQ;YACdU,MAAM;YACNb;WACD;SACF,MAAM;UACL,IAAIF,aAAa,KAAK,IAAI,EAAE;YAC1B,OAAO;cACLC,SAAS;cACTI,IAAI,EAAE,SAAS;cACfH;aACD;;UAEH,IAAIW,QAAQ,GAAGb,aAAa,IAAIN,KAAK,CAACoB,aAAa,CAACjB,UAAU,CAAC;UAC/D,OAAO;YACLI,SAAS;YACTI,IAAI,EAAE,SAAS;YACfQ,QAAQ;YACRX;WACD;;;IAGL,KAAK,OAAO;MAAE;QACZ,IAAIc,cAAc,GAAGtB,KAAK,CAACsB,cAAc,CAACnB,UAAU,CAAC;QACrD,IAAIoB,QAAQ,GAAGrB,gBAAgB,CAC7BoB,cAAc,EACdlB,aAAa,EACbC,QAAQ,EACRC,aAAa,CACd;QACD,IAAIa,QAAQ,GAAGb,aAAa,IAAIN,KAAK,CAACoB,aAAa,CAACjB,UAAU,CAAC;QAC/D,IAAIH,KAAK,CAACwB,cAAc,CAACrB,UAAU,CAAC,EAAE;UACpC,IAAIG,aAAa,KAAK,IAAI,EAAE;YAC1B,OAAO;cACLC,SAAS;cACTgB,QAAQ;cACRZ,IAAI,EAAE,SAAS;cACfQ,QAAQ;cACRX;aACD;WACF,MAAM;YACL,OAAO;cACLD,SAAS;cACTgB,QAAQ;cACRZ,IAAI,EAAE,SAAS;cACfH;aACD;;SAEJ,MAAM;UACL,IAAIa,MAAM,GAAG,IAAIxB,OAAA,CAAAD,OAAE,CAACI,KAAK,CAACyB,oBAAoB,CAACtB,UAAU,CAAC,CAAC;UAC3D,IAAIG,aAAa,KAAK,IAAI,EAAE;YAC1B,OAAO;cACLC,SAAS;cACTgB,QAAQ;cACRZ,IAAI,EAAE,QAAQ;cACdU,MAAM;cACNF,QAAQ;cACRX;aACD;WACF,MAAM;YACL,OAAO;cACLD,SAAS;cACTgB,QAAQ;cACRZ,IAAI,EAAE,QAAQ;cACdU,MAAM;cACNb;aACD;;;;IAIP,KAAK,SAAS;MAAE;QACd,IAAIkB,aAAa,GAAG1B,KAAK,CAAC0B,aAAa,CAACvB,UAAU,CAAC;QACnD;QACA;QACA,IAAIwB,OAAO,GACTzB,gBAAgB,CAACwB,aAAa,EAAEtB,aAAa,EAAEC,QAAQ,EAAE,IAAI,CAC9D;QACD;QACA;QACA;QACA;QACAV,KAAK,CAAC,gBAAgB,EAAEQ,UAAU,CAAC;QACnC,IAAIyB,eAAe,GAAG5B,KAAK,CAAC4B,eAAe,CAACzB,UAAU,CAAC;QACvD,IAAI0B,SAAS,GAAG3B,gBAAgB,CAC9B0B,eAAe,EACfxB,aAAa,EACbC,QAAQ,EACRC,aAAa,CACd;QACD,IAAIA,aAAa,KAAK,IAAI,EAAE;UAC1B,OAAO;YACLC,SAAS;YACToB,OAAO;YACPE;WACD;;QAEH,OAAO;UACLtB,SAAS;UACToB,OAAO;UACPE,SAAS;UACTV,QAAQ,EAAE;SACX;;IAEH,KAAK,UAAU;MAAE;QACf;QACA;QACA,IAAIW,UAAU,GAAG9B,KAAK,CAAC8B,UAAU,CAAC3B,UAAU,CAAC,CAAC,CAAC;QAC/C,IAAI4B,UAAU,GAAG/B,KAAK,CAAC+B,UAAU,CAAC5B,UAAU,CAAC,CAAC,CAAC;QAC/C,IAAI,CAAC6B,eAAe,EAAEC,gBAAgB,CAAC,GAAGjC,KAAK,CAACkC,UAAU,CACxD/B,UAAU,CACX,IAAI,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;QACf;QACA,IAAIgC,mBAAmB,GAAGH,eAAe,CAACI,GAAG,CAACC,SAAS,IACrDnC,gBAAgB,CAACmC,SAAS,EAAEjC,aAAa,EAAEC,QAAQ,CAAC,CACrD;QACD,IAAIiC,oBAAoB,GAAGL,gBAAgB,CAACG,GAAG,CAACC,SAAS,IACvDnC,gBAAgB,CAACmC,SAAS,EAAEjC,aAAa,EAAEC,QAAQ,CAAC,CACrD;QACD,QAAQyB,UAAU;UAChB,KAAK,UAAU;YACb,OAAO;cACLvB,SAAS;cACTuB,UAAU;cACVC,UAAU;cACVI,mBAAmB;cACnBG;aACD;UACH,KAAK,UAAU;YACb,OAAO;cACL/B,SAAS;cACTuB,UAAU;cACVnB,IAAI,EAAE,UAAU;cAChBoB,UAAU;cACVI,mBAAmB;cACnBG;aACD;;QAEL,MAAM,CAAC;;;IAET,KAAK,QAAQ;MAAE;QACb,IAAIC,EAAE,GAAG,IAAAtC,QAAA,CAAAuC,UAAU,EAACxC,KAAK,CAACyC,MAAM,CAACtC,UAAU,CAAC,EAAEC,aAAa,CAAC;QAC5D,IAAIsC,aAAa,GAAGlC,QAAQ,CAACmC,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;QACpD,IAAIC,oBAA4B;QAChC,IAAIC,QAAgB;QACpB,IAAIH,aAAa,CAACI,QAAQ,CAAC,GAAG,CAAC,EAAE;UAC/B,CAACF,oBAAoB,EAAEC,QAAQ,CAAC,GAAGH,aAAa,CAACK,KAAK,CAAC,GAAG,CAAC;SAC5D,MAAM;UACLF,QAAQ,GAAGH,aAAa;UACxB;;;QAEF,IAAIpC,aAAa,KAAK,IAAI,EAAE;UAC1B,IAAIsC,oBAAoB,EAAE;YACxB,OAAO;cACLrC,SAAS;cACTI,IAAI,EAAE,OAAO;cACb4B,EAAE;cACFM,QAAQ;cACRD;aACD;WACF,MAAM;YACL,OAAO;cACLrC,SAAS;cACTI,IAAI,EAAE,QAAQ;cACd4B,EAAE;cACFM;aACD;;;QAGL,IAAI1B,QAAQ,GAAGb,aAAa,IAAIN,KAAK,CAACoB,aAAa,CAACjB,UAAU,CAAC;QAC/D,IAAIyC,oBAAoB,EAAE;UACxB,OAAO;YACLrC,SAAS;YACTI,IAAI,EAAE,OAAO;YACb4B,EAAE;YACFM,QAAQ;YACRD,oBAAoB;YACpBzB;WACD;SACF,MAAM;UACL,OAAO;YACLZ,SAAS;YACTI,IAAI,EAAE,QAAQ;YACd4B,EAAE;YACFM,QAAQ;YACR1B;WACD;;;IAGL,KAAK,MAAM;MAAE;QACX,IAAIoB,EAAE,GAAG,IAAAtC,QAAA,CAAAuC,UAAU,EAACxC,KAAK,CAACyC,MAAM,CAACtC,UAAU,CAAC,EAAEC,aAAa,CAAC;QAC5D,IAAIsC,aAAa,GAAGlC,QAAQ,CAACmC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QAClD,IAAIC,oBAA4B;QAChC,IAAIC,QAAgB;QACpB,IAAIH,aAAa,CAACI,QAAQ,CAAC,GAAG,CAAC,EAAE;UAC/B,CAACF,oBAAoB,EAAEC,QAAQ,CAAC,GAAGH,aAAa,CAACK,KAAK,CAAC,GAAG,CAAC;SAC5D,MAAM;UACLF,QAAQ,GAAGH,aAAa;UACxB;;;QAEF,IAAIE,oBAAoB,EAAE;UACxB,OAAO;YACLrC,SAAS;YACTI,IAAI,EAAE,OAAO;YACb4B,EAAE;YACFM,QAAQ;YACRD;WACD;SACF,MAAM;UACL,OAAO;YACLrC,SAAS;YACTI,IAAI,EAAE,QAAQ;YACd4B,EAAE;YACFM;WACD;;;IAGL,KAAK,sBAAsB;MAAE;QAC3B,IAAIN,EAAE,GAAG,IAAAtC,QAAA,CAAAuC,UAAU,EAACxC,KAAK,CAACyC,MAAM,CAACtC,UAAU,CAAC,EAAEC,aAAa,CAAC;QAC5D,IAAIwC,oBAA4B;QAChC,IAAIC,QAAgB;QACpB,IAAIrC,QAAQ,CAACsC,QAAQ,CAAC,GAAG,CAAC,EAAE;UAC1B,CAACF,oBAAoB,EAAEC,QAAQ,CAAC,GAAGrC,QAAQ,CAACuC,KAAK,CAAC,GAAG,CAAC;SACvD,MAAM;UACLF,QAAQ,GAAGrC,QAAQ;UACnB;;;QAEF,IAAIoC,oBAAoB,EAAE;UACxB,OAAO;YACLrC,SAAS;YACTI,IAAI,EAAE,OAAO;YACb4B,EAAE;YACFM,QAAQ;YACRD;WACD;SACF,MAAM;UACL,OAAO;YACLrC,SAAS;YACTI,IAAI,EAAE,QAAQ;YACd4B,EAAE;YACFM;WACD;;;IAGL,KAAK,UAAU;MAAE;QACf,IAAIN,EAAE,GAAG,IAAAtC,QAAA,CAAAuC,UAAU,EAACxC,KAAK,CAACyC,MAAM,CAACtC,UAAU,CAAC,EAAEC,aAAa,CAAC;QAC5D,IAAIyC,QAAQ,GAAGrC,QAAQ,CAACmC,KAAK,CAAC,mCAAmC,CAAC,CAAC,CAAC,CAAC;QACrE;QACA;QACA,IAAIK,YAAY,GAAGhD,KAAK,CAACgD,YAAY,CAAC7C,UAAU,CAAC;QACjD,OAAO;UACLI,SAAS;UACTI,IAAI,EAAE,QAAQ;UACd4B,EAAE;UACFM,QAAQ;UACRG;SACD;;IAEH,KAAK,OAAO;MAAE;QACZ,IAAInC,cAAc,GAAGb,KAAK,CAACa,cAAc,CAACV,UAAU,CAAC;QACrD,IAAI8C,QAAQ,GACVpC,cAAc,CAAC8B,KAAK,CAAC,gBAAgB,CAAC,CAAC,CAAC,CACzC;QACD,OAAO;UACLpC,SAAS;UACT0C;SACD;;;AAGP;AApWAC,OAAA,CAAAhD,gBAAA,GAAAA,gBAAA;AAsWA;AACA;AACA,SAAgBiD,sBAAsBA,CACpChD,UAAmB,EACnBC,aAAqB,EACrBC,QAAkC,EAClC+C,qBAAgC;EAEhC,QAAQjD,UAAU,CAACkD,QAAQ;IACzB,KAAK,kBAAkB;MAAE;QACvB,MAAM;UACJd,EAAE;UACFM,QAAQ;UACRD,oBAAoB;UACpBU;QAAgB,CACjB,GAAGC,eAAe,CACjBpD,UAAU,EACVC,aAAa,EACbC,QAAQ,EACR+C,qBAAqB,CACtB;QACD,MAAMI,WAAW,GAGXrD,UAAU,CAACsD,OAAO,CAACrB,GAAG,CAACsB,MAAM,KAAK;UACtCC,IAAI,EAAED,MAAM,CAACC,IAAI;UACjBC,IAAI,EAAE1D,gBAAgB,CAACwD,MAAM,EAAEtD,aAAa,EAAEC,QAAQ,EAAE,IAAI;SAC7D,CAAC,CAAC;QACH,IAAIiD,gBAAgB,EAAE;UACpB,OAAO;YACL/C,SAAS,EAAE,QAAQ;YACnBI,IAAI,EAAE,OAAO;YACb4B,EAAE;YACFM,QAAQ;YACRD,oBAAoB;YACpBU,gBAAgB;YAChBE;WACD;SACF,MAAM;UACL,OAAO;YACLjD,SAAS,EAAE,QAAQ;YACnBI,IAAI,EAAE,QAAQ;YACd4B,EAAE;YACFM,QAAQ;YACRW;WACD;;;IAGL,KAAK,gBAAgB;MAAE;QACrB,MAAM;UACJjB,EAAE;UACFM,QAAQ;UACRD,oBAAoB;UACpBU;QAAgB,CACjB,GAAGC,eAAe,CACjBpD,UAAU,EACVC,aAAa,EACbC,QAAQ,EACR+C,qBAAqB,CACtB;QACD,MAAMS,OAAO,GAAG1D,UAAU,CAACsD,OAAO,CAACrB,GAAG,CAACsB,MAAM,IAAIA,MAAM,CAACC,IAAI,CAAC;QAC7D,IAAIL,gBAAgB,EAAE;UACpB,OAAO;YACL/C,SAAS,EAAE,MAAM;YACjBI,IAAI,EAAE,OAAO;YACb4B,EAAE;YACFM,QAAQ;YACRD,oBAAoB;YACpBU,gBAAgB;YAChBO;WACD;SACF,MAAM;UACL,OAAO;YACLtD,SAAS,EAAE,MAAM;YACjBI,IAAI,EAAE,QAAQ;YACd4B,EAAE;YACFM,QAAQ;YACRgB;WACD;;;IAGL,KAAK,gCAAgC;MAAE;QACrC,MAAM;UACJtB,EAAE;UACFM,QAAQ;UACRD,oBAAoB;UACpBU;QAAgB,CACjB,GAAGC,eAAe,CACjBpD,UAAU,EACVC,aAAa,EACbC,QAAQ,EACR+C,qBAAqB,CACtB;QACD,IAAIU,cAAc;QAAmC;QACnD5D,gBAAgB,CAACC,UAAU,CAAC2D,cAAc,EAAE1D,aAAa,EAAEC,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC;QAC9E,IAAIiD,gBAAgB,EAAE;UACpB,OAAO;YACL/C,SAAS,EAAE,sBAAsB;YACjCI,IAAI,EAAE,OAAO;YACb4B,EAAE;YACFM,QAAQ;YACRD,oBAAoB;YACpBU,gBAAgB;YAChBQ;WACD;SACF,MAAM;UACL,OAAO;YACLvD,SAAS,EAAE,sBAAsB;YACjCI,IAAI,EAAE,QAAQ;YACd4B,EAAE;YACFM,QAAQ;YACRiB;WACD;;;IAGL,KAAK,oBAAoB;MAAE;QACzB,IAAIvB,EAAE,GAAG,IAAAtC,QAAA,CAAAuC,UAAU,EAACrC,UAAU,CAACoC,EAAE,EAAEnC,aAAa,CAAC;QACjD,IAAIyC,QAAQ,GAAG1C,UAAU,CAACwD,IAAI;QAC9B,IAAIX,YAAY,GAAG7C,UAAU,CAAC6C,YAAY;QAC1C,IAAIpC,OAAO,GAAGZ,KAAK,CAAC+D,iBAAiB,CAAC5D,UAAU,CAAC;QACjD,OAAO;UACLI,SAAS,EAAE,UAAU;UACrBI,IAAI,EAAE,QAAQ;UACd4B,EAAE;UACFM,QAAQ;UACRG,YAAY;UACZpC;SACD;;;AAGP;AAhIAsC,OAAA,CAAAC,sBAAA,GAAAA,sBAAA;AAyIA,SAASI,eAAeA,CACtBpD,UAAmB,EACnBC,aAAqB,EACrBC,QAAkC,EAClC+C,qBAAgC;EAEhC,MAAMb,EAAE,GAAG,IAAAtC,QAAA,CAAAuC,UAAU,EAACrC,UAAU,CAACoC,EAAE,EAAEnC,aAAa,CAAC;EACnD,IAAIwC,oBAAwC;EAC5C,IAAIC,QAAgB;EACpB,IAAI1C,UAAU,CAAC6D,aAAa,EAAE;IAC5B,IAAI7D,UAAU,CAAC6D,aAAa,CAAClB,QAAQ,CAAC,GAAG,CAAC,EAAE;MAC1C,CAACF,oBAAoB,EAAEC,QAAQ,CAAC,GAAG1C,UAAU,CAAC6D,aAAa,CAACjB,KAAK,CAAC,GAAG,CAAC;KACvE,MAAM;MACLF,QAAQ,GAAG1C,UAAU,CAAC6D,aAAa;;GAEtC,MAAM;IACL;IACA;IACA;IACA;IACA;IACA;IACAnB,QAAQ,GAAG1C,UAAU,CAACwD,IAAI;;EAE5B,IAAIL,gBAAgB,GAAgDW,SAAS;EAAC;EAC9E,IAAIb,qBAAqB,EAAE;IACzB,IAAIc,kBAAkB,GAAGC,MAAM,CAACC,MAAM,CAAChB,qBAAqB,CAAC,CAACiB,IAAI,CAChEC,IAAI,IACFA,IAAI,CAACjB,QAAQ,KAAK,oBAAoB,IACtCiB,IAAI,CAACC,KAAK,CAACC,IAAI,CACZC,OAAgB,IAAK,IAAAxE,QAAA,CAAAuC,UAAU,EAACiC,OAAO,CAAClC,EAAE,EAAEnC,aAAa,CAAC,KAAKmC,EAAE,CACnE,CACJ;IACD,IAAI2B,kBAAkB,EAAE;MACtBZ,gBAAgB,GACdH,sBAAsB,CAACe,kBAAkB,EAAE9D,aAAa,EAAEC,QAAQ,CACnE,CAAC,CAAC;MACH,IAAI,CAACuC,oBAAoB,EAAE;QACzBA,oBAAoB,GAAGsB,kBAAkB,CAACP,IAAI;;;;EAIpD,OAAO;IACLL,gBAAgB;IAChBV,oBAAoB;IACpBC,QAAQ;IACRN;GACD;AACH"},"metadata":{},"sourceType":"script","externalDependencies":[]}