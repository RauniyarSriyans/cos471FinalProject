{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveAndWrap = exports.wrapForMethod = exports.wrapMultiple = exports.Messages = exports.wrap = exports.BadResponseTypeError = exports.TypeMismatchError = exports.NoUniqueBestOverloadError = exports.NoOverloadsMatchedError = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap\");\nconst priority_1 = require(\"./priority\");\nconst errors_1 = require(\"./errors\");\nObject.defineProperty(exports, \"NoOverloadsMatchedError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.NoOverloadsMatchedError;\n  }\n});\nObject.defineProperty(exports, \"NoUniqueBestOverloadError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.NoUniqueBestOverloadError;\n  }\n});\nObject.defineProperty(exports, \"TypeMismatchError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.TypeMismatchError;\n  }\n});\nObject.defineProperty(exports, \"BadResponseTypeError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.BadResponseTypeError;\n  }\n});\n__exportStar(require(\"./errors\"), exports);\nconst wrap_1 = require(\"./wrap\");\nObject.defineProperty(exports, \"wrap\", {\n  enumerable: true,\n  get: function () {\n    return wrap_1.wrap;\n  }\n});\n__exportStar(require(\"./types\"), exports);\nexports.Messages = __importStar(require(\"./messages\"));\nfunction* wrapMultiple(types, inputs, wrapOptions) {\n  //just wrap the types in a tuple and defer to wrap()\n  const combinedType = {\n    typeClass: \"tuple\",\n    memberTypes: types\n  };\n  debug(\"wrapping multiple\");\n  const wrappedTogether = yield* (0, wrap_1.wrap)(combinedType, inputs, wrapOptions);\n  return wrappedTogether.value.map(_ref => {\n    let {\n      value\n    } = _ref;\n    return value;\n  });\n}\nexports.wrapMultiple = wrapMultiple;\n//note: turns on loose\nfunction* wrapForMethod(method, inputs, resolveOptions) {\n  const wrapped = yield* wrapForMethodRaw(method, inputs, resolveOptions, true);\n  return wrappingToResolution(method, wrapped);\n}\nexports.wrapForMethod = wrapForMethod;\nfunction wrappingToResolution(method, wrapped) {\n  if (wrapped.length > 0 && wrapped[wrapped.length - 1].type.typeClass === \"options\") {\n    //there's options\n    const wrappedArguments = wrapped.slice(0, -1); //cut off options\n    const options = wrapped[wrapped.length - 1].value;\n    return {\n      method,\n      arguments: wrappedArguments,\n      options\n    };\n  } else {\n    //no options\n    return {\n      method,\n      arguments: wrapped,\n      options: {}\n    };\n  }\n}\n//doesn't separate out options from arguments & doesn't turn on loose\nfunction wrapForMethodRaw(method, inputs, _ref2) {\n  let {\n    userDefinedTypes,\n    allowOptions,\n    allowJson,\n    strictBooleans\n  } = _ref2;\n  let loose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return function* () {\n    debug(\"wrapping for method\");\n    if (method.inputs.length === inputs.length) {\n      //no options case\n      debug(\"no options\");\n      return yield* wrapMultiple(method.inputs, inputs, {\n        userDefinedTypes,\n        oldOptionsBehavior: true,\n        loose,\n        name: \"<arguments>\",\n        allowJson,\n        strictBooleans\n      });\n    } else if (allowOptions && method.inputs.length === inputs.length - 1) {\n      //options case\n      debug(\"options\");\n      const inputsWithOptions = [...method.inputs, {\n        name: \"<options>\",\n        type: {\n          typeClass: \"options\"\n        }\n      }];\n      return yield* wrapMultiple(inputsWithOptions, inputs, {\n        userDefinedTypes,\n        oldOptionsBehavior: true,\n        loose,\n        name: \"<arguments>\",\n        allowJson,\n        strictBooleans\n      });\n    } else {\n      //invalid length case\n      const orOneMore = allowOptions ? ` (or ${method.inputs.length + 1} counting transaction options)` : \"\";\n      throw new errors_1.TypeMismatchError({\n        typeClass: \"tuple\",\n        memberTypes: method.inputs\n      }, inputs, \"<arguments>\", 5, `Incorrect number of arguments (expected ${method.inputs.length}${orOneMore}, got ${inputs.length})`);\n    }\n  }();\n}\nfunction resolveAndWrap(methods, inputs, _ref3) {\n  let {\n    userDefinedTypes,\n    allowOptions,\n    allowJson,\n    strictBooleans\n  } = _ref3;\n  return function* () {\n    //despite us having a good system for overload resolution, we want to\n    //use it as little as possible!  That's because using it means we don't\n    //get great error messages.  As such, we're going to do a bunch to filter\n    //things beforehand, so that we get good error messages.\n    if (methods.length === 1) {\n      //if there's only one possibility, we just defer to wrapForMethod\n      //if we ignore error messages this is silly... but we're not!\n      //this is important for good error messages in this case\n      return yield* wrapForMethod(methods[0], inputs, {\n        userDefinedTypes,\n        allowOptions,\n        allowJson,\n        strictBooleans\n      });\n    }\n    //OK, so, there are multiple possibilities then.  let's try to filter things down by length.\n    const possibleMatches = methods.filter(method => method.inputs.length === inputs.length);\n    //but, we've also got to account for the possibility of options\n    let possibleMatchesWithOptions = [];\n    let possibleOptions = {};\n    if (allowOptions && inputs.length > 0) {\n      //if options are allowed, we'll have to account for that.\n      //*however*, in order to minimize the number of possibilities, we won't\n      //use these unless the last argument of inputs actually looks like an options!\n      const lastInput = inputs[inputs.length - 1];\n      let isOptionsPossible = true;\n      try {\n        const wrappedOptions = yield* (0, wrap_1.wrap)({\n          typeClass: \"options\"\n        }, lastInput, {\n          name: \"<options>\",\n          loose: true,\n          oldOptionsBehavior: true,\n          userDefinedTypes,\n          allowJson,\n          strictBooleans\n        });\n        possibleOptions = wrappedOptions.value;\n      } catch (error) {\n        if (error instanceof errors_1.TypeMismatchError) {\n          isOptionsPossible = false;\n        } else {\n          throw error; //rethrow unexpected errors\n        }\n      }\n\n      if (isOptionsPossible) {\n        possibleMatchesWithOptions = methods.filter(method => method.inputs.length === inputs.length - 1);\n      }\n    }\n    debug(\"possibleMatches: %o\", possibleMatches);\n    debug(\"possibleMatchesWithOptions: %o\", possibleMatchesWithOptions);\n    //if there's now only one possibility, great!\n    if (possibleMatches.length === 1 && possibleMatchesWithOptions.length === 0) {\n      //only one possibility, no options. we can just defer to wrapMultiple.\n      //(again, point is to have good error messaging)\n      debug(\"only one possibility, no options\");\n      const method = possibleMatches[0];\n      return {\n        method,\n        arguments: yield* wrapMultiple(method.inputs, inputs, {\n          userDefinedTypes,\n          loose: true,\n          name: \"<arguments>\",\n          allowJson,\n          strictBooleans\n        }),\n        options: {}\n      };\n    } else if (possibleMatchesWithOptions.length === 1 && possibleMatches.length === 0) {\n      //only one possibility, with options.  moreover, we already determined the options\n      //above, so we can once again just defer to wrapMultiple\n      debug(\"only one possiblity, with options\");\n      const method = possibleMatchesWithOptions[0];\n      return {\n        method,\n        arguments: yield* wrapMultiple(method.inputs, inputs, {\n          userDefinedTypes,\n          loose: true,\n          name: \"<arguments>\",\n          allowJson,\n          strictBooleans\n        }),\n        options: possibleOptions\n      };\n    } else if (possibleMatches.length === 0 && possibleMatchesWithOptions.length === 0) {\n      debug(\"no possibilities\");\n      //nothing matches!\n      throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);\n    }\n    //if all of our attempts to avoid it have failed, we'll have to actually use\n    //our overload resolution system. note how we do *not* turn on loose in this\n    //case!\n    debug(\"attempting overload resolution\");\n    let resolutions = [];\n    for (const method of methods) {\n      let wrapped;\n      try {\n        //note this part takes care of options for us...\n        //although yes this means options will be re-wrapped, oh well\n        wrapped = yield* wrapForMethodRaw(method, inputs, {\n          userDefinedTypes,\n          allowOptions,\n          allowJson,\n          strictBooleans\n        });\n      } catch (error) {\n        //if there's an error, don't add it\n        debug(\"failed: %O\", method);\n        debug(\"because: %O\", error);\n        continue;\n      }\n      //note that options and arguments here are both not correct, but we'll\n      //fix them up later!\n      debug(\"adding: %O\", method);\n      resolutions.push({\n        method,\n        arguments: wrapped,\n        options: {}\n      });\n    }\n    //now: narrow it down to the most specific one(s)\n    debug(\"resolutions: %O\", resolutions);\n    resolutions = resolutions.filter(resolution => resolutions.every(comparisonResolution => !(0, priority_1.isMoreSpecificMultiple)(comparisonResolution.arguments, resolution.arguments, userDefinedTypes) ||\n    //because the comparison is nonstrict, this comparison is added to\n    //effectively make it strict\n    // i.e. we have !(x<=y) but we want !(x<y), i.e.,\n    // !(x<=y) | x=y, i.e., !(x<=y) | (x<=y & y<=x),\n    // i.e., !(x<=y) | y<=x\n    (0, priority_1.isMoreSpecificMultiple)(resolution.arguments, comparisonResolution.arguments, userDefinedTypes)));\n    debug(\"resolutions remaining: %O\", resolutions);\n    switch (resolutions.length) {\n      case 0:\n        //no resolution worked\n        throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);\n      case 1:\n        //there was a most specific resolution; fix up options and arguments\n        //before returning\n        const {\n          method,\n          arguments: wrapped\n        } = resolutions[0];\n        return wrappingToResolution(method, wrapped);\n      default:\n        //no unique most-specific resolution\n        throw new errors_1.NoUniqueBestOverloadError(resolutions);\n    }\n  }();\n}\nexports.resolveAndWrap = resolveAndWrap;","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","priority_1","errors_1","Object","defineProperty","exports","enumerable","get","NoOverloadsMatchedError","NoUniqueBestOverloadError","TypeMismatchError","BadResponseTypeError","__exportStar","wrap_1","wrap","Messages","__importStar","wrapMultiple","types","inputs","wrapOptions","combinedType","typeClass","memberTypes","wrappedTogether","value","map","_ref","wrapForMethod","method","resolveOptions","wrapped","wrapForMethodRaw","wrappingToResolution","length","type","wrappedArguments","slice","options","arguments","_ref2","userDefinedTypes","allowOptions","allowJson","strictBooleans","loose","undefined","oldOptionsBehavior","name","inputsWithOptions","orOneMore","resolveAndWrap","methods","_ref3","possibleMatches","filter","possibleMatchesWithOptions","possibleOptions","lastInput","isOptionsPossible","wrappedOptions","error","resolutions","push","resolution","every","comparisonResolution","isMoreSpecificMultiple"],"sources":["../../../lib/wrap/index.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAAA,OAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,MAAMC,KAAK,GAAG,IAAAH,OAAA,CAAAI,OAAW,EAAC,YAAY,CAAC;AAMvC,MAAAC,UAAA,GAAAH,OAAA;AACA,MAAAI,QAAA,GAAAJ,OAAA;AAWEK,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAVAL,QAAA,CAAAM,uBAAuB;EAAA;AAAA;AAWvBL,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAVAL,QAAA,CAAAO,yBAAyB;EAAA;AAAA;AAWzBN,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAVAL,QAAA,CAAAQ,iBAAiB;EAAA;AAAA;AAWjBP,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAVAL,QAAA,CAAAS,oBAAoB;EAAA;AAAA;AAEtBC,YAAA,CAAAd,OAAA,cAAAO,OAAA;AACA,MAAAQ,MAAA,GAAAf,OAAA;AASSK,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OATAM,MAAA,CAAAC,IAAI;EAAA;AAAA;AAUbF,YAAA,CAAAd,OAAA,aAAAO,OAAA;AACAA,OAAA,CAAAU,QAAA,GAAAC,YAAA,CAAAlB,OAAA;AAEA,UAAiBmB,YAAYA,CAC3BC,KAAyC,EACzCC,MAAiB,EACjBC,WAAwB;EAExB;EACA,MAAMC,YAAY,GAA2B;IAC3CC,SAAS,EAAE,OAAO;IAClBC,WAAW,EAAEL;GACd;EACDnB,KAAK,CAAC,mBAAmB,CAAC;EAC1B,MAAMyB,eAAe,GACnB,OAAO,IAAAX,MAAA,CAAAC,IAAI,EAACO,YAAY,EAAEF,MAAM,EAAEC,WAAW,CAC9C;EACD,OAAOI,eAAe,CAACC,KAAK,CAACC,GAAG,CAACC,IAAA;IAAA,IAAC;MAAEF;IAAK,CAAE,GAAAE,IAAA;IAAA,OAA0BF,KAAK;EAAA,EAAC;AAC7E;AAfApB,OAAA,CAAAY,YAAA,GAAAA,YAAA;AAiBA;AACA,UAAiBW,aAAaA,CAC5BC,MAAc,EACdV,MAAiB,EACjBW,cAA8B;EAE9B,MAAMC,OAAO,GAAG,OAAOC,gBAAgB,CAACH,MAAM,EAAEV,MAAM,EAAEW,cAAc,EAAE,IAAI,CAAC;EAC7E,OAAOG,oBAAoB,CAACJ,MAAM,EAAEE,OAAO,CAAC;AAC9C;AAPA1B,OAAA,CAAAuB,aAAA,GAAAA,aAAA;AASA,SAASK,oBAAoBA,CAC3BJ,MAAc,EACdE,OAA8B;EAE9B,IACEA,OAAO,CAACG,MAAM,GAAG,CAAC,IAClBH,OAAO,CAACA,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC,CAACC,IAAI,CAACb,SAAS,KAAK,SAAS,EACxD;IACA;IACA,MAAMc,gBAAgB,GAAGL,OAAO,CAACM,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/C,MAAMC,OAAO,GAAgCP,OAAO,CAACA,OAAO,CAACG,MAAM,GAAG,CAAC,CAAE,CACtET,KAAK;IACR,OAAO;MACLI,MAAM;MACNU,SAAS,EAAEH,gBAAgB;MAC3BE;KACD;GACF,MAAM;IACL;IACA,OAAO;MACLT,MAAM;MACNU,SAAS,EAAER,OAAO;MAClBO,OAAO,EAAE;KACV;;AAEL;AAEA;AACA,SAAUN,gBAAgBA,CACxBH,MAAc,EACdV,MAAiB,EAAAqB,KAAA;EAAA,IACjB;IAAEC,gBAAgB;IAAEC,YAAY;IAAEC,SAAS;IAAEC;EAAc,CAAkB,GAAAJ,KAAA;EAAA,IAC7EK,KAAA,GAAAN,SAAA,CAAAL,MAAA,QAAAK,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAiB,KAAK;EAAA;IAEtBxC,KAAK,CAAC,qBAAqB,CAAC;IAC5B,IAAI8B,MAAM,CAACV,MAAM,CAACe,MAAM,KAAKf,MAAM,CAACe,MAAM,EAAE;MAC1C;MACAnC,KAAK,CAAC,YAAY,CAAC;MACnB,OAAO,OAAOkB,YAAY,CAACY,MAAM,CAACV,MAAM,EAAEA,MAAM,EAAE;QAChDsB,gBAAgB;QAChBM,kBAAkB,EAAE,IAAI;QACxBF,KAAK;QACLG,IAAI,EAAE,aAAa;QACnBL,SAAS;QACTC;OACD,CAAC;KACH,MAAM,IAAIF,YAAY,IAAIb,MAAM,CAACV,MAAM,CAACe,MAAM,KAAKf,MAAM,CAACe,MAAM,GAAG,CAAC,EAAE;MACrE;MACAnC,KAAK,CAAC,SAAS,CAAC;MAChB,MAAMkD,iBAAiB,GAAG,CACxB,GAAGpB,MAAM,CAACV,MAAM,EAChB;QAAE6B,IAAI,EAAE,WAAW;QAAEb,IAAI,EAAE;UAAEb,SAAS,EAAE;QAAkB;MAAE,CAAE,CAC/D;MACD,OAAO,OAAOL,YAAY,CAACgC,iBAAiB,EAAE9B,MAAM,EAAE;QACpDsB,gBAAgB;QAChBM,kBAAkB,EAAE,IAAI;QACxBF,KAAK;QACLG,IAAI,EAAE,aAAa;QACnBL,SAAS;QACTC;OACD,CAAC;KACH,MAAM;MACL;MACA,MAAMM,SAAS,GAAGR,YAAY,GAC1B,QAAQb,MAAM,CAACV,MAAM,CAACe,MAAM,GAAG,CAAC,gCAAgC,GAChE,EAAE;MACN,MAAM,IAAIhC,QAAA,CAAAQ,iBAAiB,CACzB;QAAEY,SAAS,EAAE,OAAO;QAAEC,WAAW,EAAEM,MAAM,CAACV;MAAM,CAAE,EAClDA,MAAM,EACN,aAAa,EACb,CAAC,EACD,2CAA2CU,MAAM,CAACV,MAAM,CAACe,MAAM,GAAGgB,SAAS,SAAS/B,MAAM,CAACe,MAAM,GAAG,CACrG;;EAEL,CAAC;AAAA;AAED,SAAiBiB,cAAcA,CAC7BC,OAAiB,EACjBjC,MAAiB,EAAAkC,KAAA;EAAA,IACjB;IAAEZ,gBAAgB;IAAEC,YAAY;IAAEC,SAAS;IAAEC;EAAc,CAAkB,GAAAS,KAAA;EAAA;IAE7E;IACA;IACA;IACA;IACA,IAAID,OAAO,CAAClB,MAAM,KAAK,CAAC,EAAE;MACxB;MACA;MACA;MACA,OAAO,OAAON,aAAa,CAACwB,OAAO,CAAC,CAAC,CAAC,EAAEjC,MAAM,EAAE;QAC9CsB,gBAAgB;QAChBC,YAAY;QACZC,SAAS;QACTC;OACD,CAAC;;IAEJ;IACA,MAAMU,eAAe,GAAGF,OAAO,CAACG,MAAM,CACpC1B,MAAM,IAAIA,MAAM,CAACV,MAAM,CAACe,MAAM,KAAKf,MAAM,CAACe,MAAM,CACjD;IACD;IACA,IAAIsB,0BAA0B,GAAa,EAAE;IAC7C,IAAIC,eAAe,GAAmB,EAAE;IACxC,IAAIf,YAAY,IAAIvB,MAAM,CAACe,MAAM,GAAG,CAAC,EAAE;MACrC;MACA;MACA;MACA,MAAMwB,SAAS,GAAGvC,MAAM,CAACA,MAAM,CAACe,MAAM,GAAG,CAAC,CAAC;MAC3C,IAAIyB,iBAAiB,GAAY,IAAI;MACrC,IAAI;QACF,MAAMC,cAAc,GAClB,OAAO,IAAA/C,MAAA,CAAAC,IAAI,EAAC;UAAEQ,SAAS,EAAE;QAAS,CAAE,EAAEoC,SAAS,EAAE;UAC/CV,IAAI,EAAE,WAAW;UACjBH,KAAK,EAAE,IAAI;UACXE,kBAAkB,EAAE,IAAI;UACxBN,gBAAgB;UAChBE,SAAS;UACTC;SACD,CACF;QACDa,eAAe,GAAGG,cAAc,CAACnC,KAAK;OACvC,CAAC,OAAOoC,KAAK,EAAE;QACd,IAAIA,KAAK,YAAY3D,QAAA,CAAAQ,iBAAiB,EAAE;UACtCiD,iBAAiB,GAAG,KAAK;SAC1B,MAAM;UACL,MAAME,KAAK,CAAC,CAAC;;;;MAGjB,IAAIF,iBAAiB,EAAE;QACrBH,0BAA0B,GAAGJ,OAAO,CAACG,MAAM,CACzC1B,MAAM,IAAIA,MAAM,CAACV,MAAM,CAACe,MAAM,KAAKf,MAAM,CAACe,MAAM,GAAG,CAAC,CACrD;;;IAGLnC,KAAK,CAAC,qBAAqB,EAAEuD,eAAe,CAAC;IAC7CvD,KAAK,CAAC,gCAAgC,EAAEyD,0BAA0B,CAAC;IACnE;IACA,IAAIF,eAAe,CAACpB,MAAM,KAAK,CAAC,IAAIsB,0BAA0B,CAACtB,MAAM,KAAK,CAAC,EAAE;MAC3E;MACA;MACAnC,KAAK,CAAC,kCAAkC,CAAC;MACzC,MAAM8B,MAAM,GAAGyB,eAAe,CAAC,CAAC,CAAC;MACjC,OAAO;QACLzB,MAAM;QACNU,SAAS,EAAE,OAAOtB,YAAY,CAACY,MAAM,CAACV,MAAM,EAAEA,MAAM,EAAE;UACpDsB,gBAAgB;UAChBI,KAAK,EAAE,IAAI;UACXG,IAAI,EAAE,aAAa;UACnBL,SAAS;UACTC;SACD,CAAC;QACFN,OAAO,EAAE;OACV;KACF,MAAM,IACLkB,0BAA0B,CAACtB,MAAM,KAAK,CAAC,IACvCoB,eAAe,CAACpB,MAAM,KAAK,CAAC,EAC5B;MACA;MACA;MACAnC,KAAK,CAAC,mCAAmC,CAAC;MAC1C,MAAM8B,MAAM,GAAG2B,0BAA0B,CAAC,CAAC,CAAC;MAC5C,OAAO;QACL3B,MAAM;QACNU,SAAS,EAAE,OAAOtB,YAAY,CAACY,MAAM,CAACV,MAAM,EAAEA,MAAM,EAAE;UACpDsB,gBAAgB;UAChBI,KAAK,EAAE,IAAI;UACXG,IAAI,EAAE,aAAa;UACnBL,SAAS;UACTC;SACD,CAAC;QACFN,OAAO,EAAEmB;OACV;KACF,MAAM,IACLH,eAAe,CAACpB,MAAM,KAAK,CAAC,IAC5BsB,0BAA0B,CAACtB,MAAM,KAAK,CAAC,EACvC;MACAnC,KAAK,CAAC,kBAAkB,CAAC;MACzB;MACA,MAAM,IAAIG,QAAA,CAAAM,uBAAuB,CAAC4C,OAAO,EAAEjC,MAAM,EAAEsB,gBAAgB,CAAC;;IAEtE;IACA;IACA;IACA1C,KAAK,CAAC,gCAAgC,CAAC;IACvC,IAAI+D,WAAW,GAAiB,EAAE;IAClC,KAAK,MAAMjC,MAAM,IAAIuB,OAAO,EAAE;MAC5B,IAAIrB,OAA8B;MAClC,IAAI;QACF;QACA;QACAA,OAAO,GAAG,OAAOC,gBAAgB,CAACH,MAAM,EAAEV,MAAM,EAAE;UAChDsB,gBAAgB;UAChBC,YAAY;UACZC,SAAS;UACTC;SACD,CAAC;OACH,CAAC,OAAOiB,KAAK,EAAE;QACd;QACA9D,KAAK,CAAC,YAAY,EAAE8B,MAAM,CAAC;QAC3B9B,KAAK,CAAC,aAAa,EAAE8D,KAAK,CAAC;QAC3B;;MAEF;MACA;MACA9D,KAAK,CAAC,YAAY,EAAE8B,MAAM,CAAC;MAC3BiC,WAAW,CAACC,IAAI,CAAC;QAAElC,MAAM;QAAEU,SAAS,EAAER,OAAO;QAAEO,OAAO,EAAE;MAAE,CAAE,CAAC;;IAE/D;IACAvC,KAAK,CAAC,iBAAiB,EAAE+D,WAAW,CAAC;IACrCA,WAAW,GAAGA,WAAW,CAACP,MAAM,CAACS,UAAU,IACzCF,WAAW,CAACG,KAAK,CACfC,oBAAoB,IAClB,CAAC,IAAAjE,UAAA,CAAAkE,sBAAsB,EACrBD,oBAAoB,CAAC3B,SAAS,EAC9ByB,UAAU,CAACzB,SAAS,EACpBE,gBAAgB,CACjB;IACD;IACA;IACA;IACA;IACA;IACA,IAAAxC,UAAA,CAAAkE,sBAAsB,EACpBH,UAAU,CAACzB,SAAS,EACpB2B,oBAAoB,CAAC3B,SAAS,EAC9BE,gBAAgB,CACjB,CACJ,CACF;IACD1C,KAAK,CAAC,2BAA2B,EAAE+D,WAAW,CAAC;IAC/C,QAAQA,WAAW,CAAC5B,MAAM;MACxB,KAAK,CAAC;QACJ;QACA,MAAM,IAAIhC,QAAA,CAAAM,uBAAuB,CAAC4C,OAAO,EAAEjC,MAAM,EAAEsB,gBAAgB,CAAC;MACtE,KAAK,CAAC;QACJ;QACA;QACA,MAAM;UAAEZ,MAAM;UAAEU,SAAS,EAAER;QAAO,CAAE,GAAG+B,WAAW,CAAC,CAAC,CAAC;QACrD,OAAO7B,oBAAoB,CAACJ,MAAM,EAAEE,OAAO,CAAC;MAC9C;QACE;QACA,MAAM,IAAI7B,QAAA,CAAAO,yBAAyB,CAACqD,WAAW,CAAC;;EAEtD,CAAC;AAAA;AAvKDzD,OAAA,CAAA8C,cAAA,GAAAA,cAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}