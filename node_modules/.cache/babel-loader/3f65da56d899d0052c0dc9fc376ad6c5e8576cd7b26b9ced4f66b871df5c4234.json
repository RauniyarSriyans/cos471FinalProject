{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tie = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:format:utils:circularity\");\nfunction tie(untied) {\n  return tieWithTable(untied, []);\n}\nexports.tie = tie;\nfunction tieWithTable(untied, seenSoFar) {\n  if (untied.kind === \"error\") {\n    return untied;\n  }\n  let reference;\n  switch (untied.type.typeClass) {\n    case \"array\":\n      const untiedAsArray = untied; //dammit TS\n      reference = untiedAsArray.reference;\n      if (reference === undefined) {\n        //we need to do some pointer stuff here, so let's first create our new\n        //object we'll be pointing to\n        //[we don't want to alter the original accidentally so let's clone a bit]\n        let tied = Object.assign(Object.assign({}, untiedAsArray), {\n          value: [...untiedAsArray.value]\n        });\n        //now, we can't use a map here, or we'll screw things up!\n        //we want to *mutate* value, not replace it with a new object\n        //note: this used to be a for-in loop, changed to avoid problems with VSCode\n        for (let index = 0; index < tied.value.length; index++) {\n          tied.value[index] = tieWithTable(tied.value[index], [tied, ...seenSoFar]);\n        }\n        return tied;\n      } else {\n        return Object.assign(Object.assign({}, seenSoFar[reference - 1]), {\n          reference\n        });\n      }\n    case \"struct\":\n      const untiedAsStruct = untied; //dammit TS\n      reference = untiedAsStruct.reference;\n      if (reference === undefined) {\n        //we need to do some pointer stuff here, so let's first create our new\n        //object we'll be pointing to\n        //[we don't want to alter the original accidentally so let's clone a bit]\n        let tied = Object.assign(Object.assign({}, untiedAsStruct), {\n          value: untiedAsStruct.value.map(component => Object.assign({}, component))\n        });\n        //now, we can't use a map here, or we'll screw things up!\n        //we want to *mutate* value, not replace it with a new object\n        //note: this used to be a for-in loop, changed to avoid problems with VSCode\n        for (let index = 0; index < tied.value.length; index++) {\n          tied.value[index] = Object.assign(Object.assign({}, tied.value[index]), {\n            value: tieWithTable(tied.value[index].value, [tied, ...seenSoFar])\n          });\n        }\n        return tied;\n      } else {\n        return Object.assign(Object.assign({}, seenSoFar[reference - 1]), {\n          reference\n        });\n      }\n    case \"tuple\":\n      //currently there are no memory tuples, but may as well\n      //can't be circular, just recurse\n      //note we can just recurse with a straight tie here; don't need tieWithTable\n      const untiedAsTuple = untied; //dammit TS\n      //we need to do some pointer stuff here, so let's first create our new\n      //object we'll be pointing to\n      let tied = Object.assign({}, untiedAsTuple);\n      tied.value = tied.value.map(component => Object.assign(Object.assign({}, component), {\n        value: tie(component.value)\n      }));\n      return tied;\n    default:\n      //other types either:\n      //1. aren't containers and so need no recursion\n      //2. are containers but can't go in or contain memory things\n      //and so still need no recursion\n      //(or, in the case of mappings, can't contain *nontrivial* memory\n      //things)\n      return untied;\n  }\n}","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","tie","untied","tieWithTable","exports","seenSoFar","kind","reference","type","typeClass","untiedAsArray","undefined","tied","Object","assign","value","index","length","untiedAsStruct","map","component","untiedAsTuple"],"sources":["../../../../lib/format/utils/circularity.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}