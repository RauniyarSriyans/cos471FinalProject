{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommandsArbitrary = void 0;\nconst Arbitrary_1 = require(\"../../check/arbitrary/definition/Arbitrary\");\nconst Value_1 = require(\"../../check/arbitrary/definition/Value\");\nconst CommandsIterable_1 = require(\"../../check/model/commands/CommandsIterable\");\nconst CommandWrapper_1 = require(\"../../check/model/commands/CommandWrapper\");\nconst ReplayPath_1 = require(\"../../check/model/ReplayPath\");\nconst LazyIterableIterator_1 = require(\"../../stream/LazyIterableIterator\");\nconst Stream_1 = require(\"../../stream/Stream\");\nconst oneof_1 = require(\"../oneof\");\nconst RestrictedIntegerArbitraryBuilder_1 = require(\"./builders/RestrictedIntegerArbitraryBuilder\");\nclass CommandsArbitrary extends Arbitrary_1.Arbitrary {\n  constructor(commandArbs, maxGeneratedCommands, maxCommands, sourceReplayPath, disableReplayLog) {\n    super();\n    this.sourceReplayPath = sourceReplayPath;\n    this.disableReplayLog = disableReplayLog;\n    this.oneCommandArb = (0, oneof_1.oneof)(...commandArbs).map(c => new CommandWrapper_1.CommandWrapper(c));\n    this.lengthArb = (0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(0, maxGeneratedCommands, maxCommands);\n    this.replayPath = [];\n    this.replayPathPosition = 0;\n  }\n  metadataForReplay() {\n    return this.disableReplayLog ? '' : `replayPath=${JSON.stringify(ReplayPath_1.ReplayPath.stringify(this.replayPath))}`;\n  }\n  buildValueFor(items, shrunkOnce) {\n    const commands = items.map(item => item.value_);\n    const context = {\n      shrunkOnce,\n      items\n    };\n    return new Value_1.Value(new CommandsIterable_1.CommandsIterable(commands, () => this.metadataForReplay()), context);\n  }\n  generate(mrng) {\n    const size = this.lengthArb.generate(mrng, undefined);\n    const sizeValue = size.value;\n    const items = Array(sizeValue);\n    for (let idx = 0; idx !== sizeValue; ++idx) {\n      const item = this.oneCommandArb.generate(mrng, undefined);\n      items[idx] = item;\n    }\n    this.replayPathPosition = 0;\n    return this.buildValueFor(items, false);\n  }\n  canShrinkWithoutContext(value) {\n    return false;\n  }\n  filterOnExecution(itemsRaw) {\n    const items = [];\n    for (const c of itemsRaw) {\n      if (c.value_.hasRan) {\n        this.replayPath.push(true);\n        items.push(c);\n      } else this.replayPath.push(false);\n    }\n    return items;\n  }\n  filterOnReplay(itemsRaw) {\n    return itemsRaw.filter((c, idx) => {\n      const state = this.replayPath[this.replayPathPosition + idx];\n      if (state === undefined) throw new Error(`Too short replayPath`);\n      if (!state && c.value_.hasRan) throw new Error(`Mismatch between replayPath and real execution`);\n      return state;\n    });\n  }\n  filterForShrinkImpl(itemsRaw) {\n    if (this.replayPathPosition === 0) {\n      this.replayPath = this.sourceReplayPath !== null ? ReplayPath_1.ReplayPath.parse(this.sourceReplayPath) : [];\n    }\n    const items = this.replayPathPosition < this.replayPath.length ? this.filterOnReplay(itemsRaw) : this.filterOnExecution(itemsRaw);\n    this.replayPathPosition += itemsRaw.length;\n    return items;\n  }\n  shrink(_value, context) {\n    if (context === undefined) {\n      return Stream_1.Stream.nil();\n    }\n    const safeContext = context;\n    const shrunkOnce = safeContext.shrunkOnce;\n    const itemsRaw = safeContext.items;\n    const items = this.filterForShrinkImpl(itemsRaw);\n    if (items.length === 0) {\n      return Stream_1.Stream.nil();\n    }\n    const rootShrink = shrunkOnce ? Stream_1.Stream.nil() : new Stream_1.Stream([[]][Symbol.iterator]());\n    const nextShrinks = [];\n    for (let numToKeep = 0; numToKeep !== items.length; ++numToKeep) {\n      nextShrinks.push((0, LazyIterableIterator_1.makeLazy)(() => {\n        const fixedStart = items.slice(0, numToKeep);\n        return this.lengthArb.shrink(items.length - 1 - numToKeep, undefined).map(l => fixedStart.concat(items.slice(items.length - (l.value + 1))));\n      }));\n    }\n    for (let itemAt = 0; itemAt !== items.length; ++itemAt) {\n      nextShrinks.push((0, LazyIterableIterator_1.makeLazy)(() => this.oneCommandArb.shrink(items[itemAt].value_, items[itemAt].context).map(v => items.slice(0, itemAt).concat([v], items.slice(itemAt + 1)))));\n    }\n    return rootShrink.join(...nextShrinks).map(shrinkables => {\n      return this.buildValueFor(shrinkables.map(c => new Value_1.Value(c.value_.clone(), c.context)), true);\n    });\n  }\n}\nexports.CommandsArbitrary = CommandsArbitrary;","map":{"version":3,"names":["Object","defineProperty","exports","value","CommandsArbitrary","Arbitrary_1","require","Value_1","CommandsIterable_1","CommandWrapper_1","ReplayPath_1","LazyIterableIterator_1","Stream_1","oneof_1","RestrictedIntegerArbitraryBuilder_1","Arbitrary","constructor","commandArbs","maxGeneratedCommands","maxCommands","sourceReplayPath","disableReplayLog","oneCommandArb","oneof","map","c","CommandWrapper","lengthArb","restrictedIntegerArbitraryBuilder","replayPath","replayPathPosition","metadataForReplay","JSON","stringify","ReplayPath","buildValueFor","items","shrunkOnce","commands","item","value_","context","Value","CommandsIterable","generate","mrng","size","undefined","sizeValue","Array","idx","canShrinkWithoutContext","filterOnExecution","itemsRaw","hasRan","push","filterOnReplay","filter","state","Error","filterForShrinkImpl","parse","length","shrink","_value","Stream","nil","safeContext","rootShrink","Symbol","iterator","nextShrinks","numToKeep","makeLazy","fixedStart","slice","l","concat","itemAt","v","join","shrinkables","clone"],"sources":["/Users/karimelbarbary/Desktop/test4/devote/node_modules/fast-check/lib/arbitrary/_internals/CommandsArbitrary.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommandsArbitrary = void 0;\nconst Arbitrary_1 = require(\"../../check/arbitrary/definition/Arbitrary\");\nconst Value_1 = require(\"../../check/arbitrary/definition/Value\");\nconst CommandsIterable_1 = require(\"../../check/model/commands/CommandsIterable\");\nconst CommandWrapper_1 = require(\"../../check/model/commands/CommandWrapper\");\nconst ReplayPath_1 = require(\"../../check/model/ReplayPath\");\nconst LazyIterableIterator_1 = require(\"../../stream/LazyIterableIterator\");\nconst Stream_1 = require(\"../../stream/Stream\");\nconst oneof_1 = require(\"../oneof\");\nconst RestrictedIntegerArbitraryBuilder_1 = require(\"./builders/RestrictedIntegerArbitraryBuilder\");\nclass CommandsArbitrary extends Arbitrary_1.Arbitrary {\n    constructor(commandArbs, maxGeneratedCommands, maxCommands, sourceReplayPath, disableReplayLog) {\n        super();\n        this.sourceReplayPath = sourceReplayPath;\n        this.disableReplayLog = disableReplayLog;\n        this.oneCommandArb = (0, oneof_1.oneof)(...commandArbs).map((c) => new CommandWrapper_1.CommandWrapper(c));\n        this.lengthArb = (0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(0, maxGeneratedCommands, maxCommands);\n        this.replayPath = [];\n        this.replayPathPosition = 0;\n    }\n    metadataForReplay() {\n        return this.disableReplayLog ? '' : `replayPath=${JSON.stringify(ReplayPath_1.ReplayPath.stringify(this.replayPath))}`;\n    }\n    buildValueFor(items, shrunkOnce) {\n        const commands = items.map((item) => item.value_);\n        const context = { shrunkOnce, items };\n        return new Value_1.Value(new CommandsIterable_1.CommandsIterable(commands, () => this.metadataForReplay()), context);\n    }\n    generate(mrng) {\n        const size = this.lengthArb.generate(mrng, undefined);\n        const sizeValue = size.value;\n        const items = Array(sizeValue);\n        for (let idx = 0; idx !== sizeValue; ++idx) {\n            const item = this.oneCommandArb.generate(mrng, undefined);\n            items[idx] = item;\n        }\n        this.replayPathPosition = 0;\n        return this.buildValueFor(items, false);\n    }\n    canShrinkWithoutContext(value) {\n        return false;\n    }\n    filterOnExecution(itemsRaw) {\n        const items = [];\n        for (const c of itemsRaw) {\n            if (c.value_.hasRan) {\n                this.replayPath.push(true);\n                items.push(c);\n            }\n            else\n                this.replayPath.push(false);\n        }\n        return items;\n    }\n    filterOnReplay(itemsRaw) {\n        return itemsRaw.filter((c, idx) => {\n            const state = this.replayPath[this.replayPathPosition + idx];\n            if (state === undefined)\n                throw new Error(`Too short replayPath`);\n            if (!state && c.value_.hasRan)\n                throw new Error(`Mismatch between replayPath and real execution`);\n            return state;\n        });\n    }\n    filterForShrinkImpl(itemsRaw) {\n        if (this.replayPathPosition === 0) {\n            this.replayPath = this.sourceReplayPath !== null ? ReplayPath_1.ReplayPath.parse(this.sourceReplayPath) : [];\n        }\n        const items = this.replayPathPosition < this.replayPath.length\n            ? this.filterOnReplay(itemsRaw)\n            : this.filterOnExecution(itemsRaw);\n        this.replayPathPosition += itemsRaw.length;\n        return items;\n    }\n    shrink(_value, context) {\n        if (context === undefined) {\n            return Stream_1.Stream.nil();\n        }\n        const safeContext = context;\n        const shrunkOnce = safeContext.shrunkOnce;\n        const itemsRaw = safeContext.items;\n        const items = this.filterForShrinkImpl(itemsRaw);\n        if (items.length === 0) {\n            return Stream_1.Stream.nil();\n        }\n        const rootShrink = shrunkOnce\n            ? Stream_1.Stream.nil()\n            : new Stream_1.Stream([[]][Symbol.iterator]());\n        const nextShrinks = [];\n        for (let numToKeep = 0; numToKeep !== items.length; ++numToKeep) {\n            nextShrinks.push((0, LazyIterableIterator_1.makeLazy)(() => {\n                const fixedStart = items.slice(0, numToKeep);\n                return this.lengthArb\n                    .shrink(items.length - 1 - numToKeep, undefined)\n                    .map((l) => fixedStart.concat(items.slice(items.length - (l.value + 1))));\n            }));\n        }\n        for (let itemAt = 0; itemAt !== items.length; ++itemAt) {\n            nextShrinks.push((0, LazyIterableIterator_1.makeLazy)(() => this.oneCommandArb\n                .shrink(items[itemAt].value_, items[itemAt].context)\n                .map((v) => items.slice(0, itemAt).concat([v], items.slice(itemAt + 1)))));\n        }\n        return rootShrink.join(...nextShrinks).map((shrinkables) => {\n            return this.buildValueFor(shrinkables.map((c) => new Value_1.Value(c.value_.clone(), c.context)), true);\n        });\n    }\n}\nexports.CommandsArbitrary = CommandsArbitrary;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}