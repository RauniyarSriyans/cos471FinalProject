{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyFlagsOnChars = exports.computeFlagsFromChars = exports.computeTogglePositions = exports.computeNextFlags = exports.countToggledBits = void 0;\nfunction countToggledBits(n) {\n  let count = 0;\n  while (n > BigInt(0)) {\n    if (n & BigInt(1)) ++count;\n    n >>= BigInt(1);\n  }\n  return count;\n}\nexports.countToggledBits = countToggledBits;\nfunction computeNextFlags(flags, nextSize) {\n  const allowedMask = (BigInt(1) << BigInt(nextSize)) - BigInt(1);\n  const preservedFlags = flags & allowedMask;\n  let numMissingFlags = countToggledBits(flags - preservedFlags);\n  let nFlags = preservedFlags;\n  for (let mask = BigInt(1); mask <= allowedMask && numMissingFlags !== 0; mask <<= BigInt(1)) {\n    if (!(nFlags & mask)) {\n      nFlags |= mask;\n      --numMissingFlags;\n    }\n  }\n  return nFlags;\n}\nexports.computeNextFlags = computeNextFlags;\nfunction computeTogglePositions(chars, toggleCase) {\n  const positions = [];\n  for (let idx = chars.length - 1; idx !== -1; --idx) {\n    if (toggleCase(chars[idx]) !== chars[idx]) positions.push(idx);\n  }\n  return positions;\n}\nexports.computeTogglePositions = computeTogglePositions;\nfunction computeFlagsFromChars(untoggledChars, toggledChars, togglePositions) {\n  let flags = BigInt(0);\n  for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {\n    if (untoggledChars[togglePositions[idx]] !== toggledChars[togglePositions[idx]]) {\n      flags |= mask;\n    }\n  }\n  return flags;\n}\nexports.computeFlagsFromChars = computeFlagsFromChars;\nfunction applyFlagsOnChars(chars, flags, togglePositions, toggleCase) {\n  for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {\n    if (flags & mask) chars[togglePositions[idx]] = toggleCase(chars[togglePositions[idx]]);\n  }\n}\nexports.applyFlagsOnChars = applyFlagsOnChars;","map":{"version":3,"names":["Object","defineProperty","exports","value","applyFlagsOnChars","computeFlagsFromChars","computeTogglePositions","computeNextFlags","countToggledBits","n","count","BigInt","flags","nextSize","allowedMask","preservedFlags","numMissingFlags","nFlags","mask","chars","toggleCase","positions","idx","length","push","untoggledChars","toggledChars","togglePositions"],"sources":["/Users/karimelbarbary/Desktop/test4/devote/node_modules/fast-check/lib/arbitrary/_internals/helpers/ToggleFlags.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyFlagsOnChars = exports.computeFlagsFromChars = exports.computeTogglePositions = exports.computeNextFlags = exports.countToggledBits = void 0;\nfunction countToggledBits(n) {\n    let count = 0;\n    while (n > BigInt(0)) {\n        if (n & BigInt(1))\n            ++count;\n        n >>= BigInt(1);\n    }\n    return count;\n}\nexports.countToggledBits = countToggledBits;\nfunction computeNextFlags(flags, nextSize) {\n    const allowedMask = (BigInt(1) << BigInt(nextSize)) - BigInt(1);\n    const preservedFlags = flags & allowedMask;\n    let numMissingFlags = countToggledBits(flags - preservedFlags);\n    let nFlags = preservedFlags;\n    for (let mask = BigInt(1); mask <= allowedMask && numMissingFlags !== 0; mask <<= BigInt(1)) {\n        if (!(nFlags & mask)) {\n            nFlags |= mask;\n            --numMissingFlags;\n        }\n    }\n    return nFlags;\n}\nexports.computeNextFlags = computeNextFlags;\nfunction computeTogglePositions(chars, toggleCase) {\n    const positions = [];\n    for (let idx = chars.length - 1; idx !== -1; --idx) {\n        if (toggleCase(chars[idx]) !== chars[idx])\n            positions.push(idx);\n    }\n    return positions;\n}\nexports.computeTogglePositions = computeTogglePositions;\nfunction computeFlagsFromChars(untoggledChars, toggledChars, togglePositions) {\n    let flags = BigInt(0);\n    for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {\n        if (untoggledChars[togglePositions[idx]] !== toggledChars[togglePositions[idx]]) {\n            flags |= mask;\n        }\n    }\n    return flags;\n}\nexports.computeFlagsFromChars = computeFlagsFromChars;\nfunction applyFlagsOnChars(chars, flags, togglePositions, toggleCase) {\n    for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {\n        if (flags & mask)\n            chars[togglePositions[idx]] = toggleCase(chars[togglePositions[idx]]);\n    }\n}\nexports.applyFlagsOnChars = applyFlagsOnChars;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}