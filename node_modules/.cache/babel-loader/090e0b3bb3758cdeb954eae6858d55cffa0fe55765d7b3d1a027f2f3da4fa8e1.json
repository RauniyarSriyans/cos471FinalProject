{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forBytecode = exports.forContract = void 0;\nfunction forContract(contract) {\n  const {\n    contractName,\n    sourcePath,\n    source,\n    sourceMap,\n    deployedSourceMap,\n    legacyAST,\n    ast,\n    abi,\n    metadata,\n    bytecode,\n    deployedBytecode,\n    compiler,\n    devdoc,\n    userdoc,\n    immutableReferences,\n    generatedSources,\n    deployedGeneratedSources,\n    db\n  } = contract;\n  return {\n    contract_name: contractName,\n    sourcePath,\n    source,\n    sourceMap,\n    deployedSourceMap,\n    legacyAST,\n    ast,\n    abi,\n    metadata,\n    bytecode: forBytecode(bytecode),\n    deployedBytecode: forBytecode(deployedBytecode),\n    unlinked_binary: forBytecode(bytecode),\n    compiler,\n    devdoc,\n    userdoc,\n    immutableReferences,\n    generatedSources,\n    deployedGeneratedSources,\n    db\n  };\n}\nexports.forContract = forContract;\nfunction forBytecode(bytecode) {\n  if (!bytecode) {\n    return bytecode;\n  }\n  if (typeof bytecode === \"string\") {\n    return bytecode;\n  }\n  let {\n    bytes,\n    linkReferences\n  } = bytecode;\n  linkReferences = linkReferences || [];\n  // inline link references - start by flattening the offsets\n  const flattenedLinkReferences = linkReferences\n  // map each link ref to array of link refs with only one offset\n  .map(_ref => {\n    let {\n      offsets,\n      length,\n      name\n    } = _ref;\n    return offsets.map(offset => ({\n      offset,\n      length,\n      name\n    }));\n  })\n  // flatten\n  .reduce((a, b) => [...a, ...b], []);\n  // then overwite bytes with link reference\n  bytes = flattenedLinkReferences.reduce((bytes, _ref2) => {\n    let {\n      offset,\n      name,\n      length\n    } = _ref2;\n    // length is a byte offset\n    const characterLength = length * 2;\n    let linkId = `__${name.slice(0, characterLength - 2)}`;\n    while (linkId.length < characterLength) {\n      linkId += \"_\";\n    }\n    const start = offset * 2;\n    return `${bytes.substring(0, start)}${linkId}${bytes.substring(start + characterLength)}`;\n  }, bytes);\n  return `0x${bytes}`;\n}\nexports.forBytecode = forBytecode;","map":{"version":3,"names":["forContract","contract","contractName","sourcePath","source","sourceMap","deployedSourceMap","legacyAST","ast","abi","metadata","bytecode","deployedBytecode","compiler","devdoc","userdoc","immutableReferences","generatedSources","deployedGeneratedSources","db","contract_name","forBytecode","unlinked_binary","exports","bytes","linkReferences","flattenedLinkReferences","map","_ref","offsets","length","name","offset","reduce","a","b","_ref2","characterLength","linkId","slice","start","substring"],"sources":["/Users/karimelbarbary/Desktop/test4/devote/node_modules/@truffle/compile-common/src/shims/NewToLegacy.ts"],"sourcesContent":["import type { LinkReference, CompiledContract } from \"../types\";\n\nexport function forContract(contract: CompiledContract): any {\n  const {\n    contractName,\n    sourcePath,\n    source,\n    sourceMap,\n    deployedSourceMap,\n    legacyAST,\n    ast,\n    abi,\n    metadata,\n    bytecode,\n    deployedBytecode,\n    compiler,\n    devdoc,\n    userdoc,\n    immutableReferences,\n    generatedSources,\n    deployedGeneratedSources,\n    db\n  } = contract;\n\n  return {\n    contract_name: contractName,\n    sourcePath,\n    source,\n    sourceMap,\n    deployedSourceMap,\n    legacyAST,\n    ast,\n    abi,\n    metadata,\n    bytecode: forBytecode(bytecode),\n    deployedBytecode: forBytecode(deployedBytecode),\n    unlinked_binary: forBytecode(bytecode),\n    compiler,\n    devdoc,\n    userdoc,\n    immutableReferences,\n    generatedSources,\n    deployedGeneratedSources,\n    db\n  };\n}\n\nexport function forBytecode(bytecode: any): any {\n  if (!bytecode) {\n    return bytecode;\n  }\n  if (typeof bytecode === \"string\") {\n    return bytecode;\n  }\n\n  let { bytes, linkReferences } = bytecode;\n\n  linkReferences = linkReferences || [];\n\n  // inline link references - start by flattening the offsets\n  const flattenedLinkReferences = linkReferences\n    // map each link ref to array of link refs with only one offset\n    .map(({ offsets, length, name }: LinkReference) =>\n      offsets.map(offset => ({ offset, length, name }))\n    )\n    // flatten\n    .reduce((a: object[], b: object[]) => [...a, ...b], []);\n\n  // then overwite bytes with link reference\n  bytes = flattenedLinkReferences.reduce(\n    (\n      bytes: string,\n      { offset, name, length }: { offset: number; name: string; length: number }\n    ) => {\n      // length is a byte offset\n      const characterLength = length * 2;\n\n      let linkId = `__${name.slice(0, characterLength - 2)}`;\n      while (linkId.length < characterLength) {\n        linkId += \"_\";\n      }\n\n      const start = offset * 2;\n\n      return `${bytes.substring(0, start)}${linkId}${bytes.substring(\n        start + characterLength\n      )}`;\n    },\n    bytes\n  );\n\n  return `0x${bytes}`;\n}\n"],"mappings":";;;;;;AAEA,SAAgBA,WAAWA,CAACC,QAA0B;EACpD,MAAM;IACJC,YAAY;IACZC,UAAU;IACVC,MAAM;IACNC,SAAS;IACTC,iBAAiB;IACjBC,SAAS;IACTC,GAAG;IACHC,GAAG;IACHC,QAAQ;IACRC,QAAQ;IACRC,gBAAgB;IAChBC,QAAQ;IACRC,MAAM;IACNC,OAAO;IACPC,mBAAmB;IACnBC,gBAAgB;IAChBC,wBAAwB;IACxBC;EAAE,CACH,GAAGlB,QAAQ;EAEZ,OAAO;IACLmB,aAAa,EAAElB,YAAY;IAC3BC,UAAU;IACVC,MAAM;IACNC,SAAS;IACTC,iBAAiB;IACjBC,SAAS;IACTC,GAAG;IACHC,GAAG;IACHC,QAAQ;IACRC,QAAQ,EAAEU,WAAW,CAACV,QAAQ,CAAC;IAC/BC,gBAAgB,EAAES,WAAW,CAACT,gBAAgB,CAAC;IAC/CU,eAAe,EAAED,WAAW,CAACV,QAAQ,CAAC;IACtCE,QAAQ;IACRC,MAAM;IACNC,OAAO;IACPC,mBAAmB;IACnBC,gBAAgB;IAChBC,wBAAwB;IACxBC;GACD;AACH;AA3CAI,OAAA,CAAAvB,WAAA,GAAAA,WAAA;AA6CA,SAAgBqB,WAAWA,CAACV,QAAa;EACvC,IAAI,CAACA,QAAQ,EAAE;IACb,OAAOA,QAAQ;;EAEjB,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;IAChC,OAAOA,QAAQ;;EAGjB,IAAI;IAAEa,KAAK;IAAEC;EAAc,CAAE,GAAGd,QAAQ;EAExCc,cAAc,GAAGA,cAAc,IAAI,EAAE;EAErC;EACA,MAAMC,uBAAuB,GAAGD;EAC9B;EAAA,CACCE,GAAG,CAACC,IAAA;IAAA,IAAC;MAAEC,OAAO;MAAEC,MAAM;MAAEC;IAAI,CAAiB,GAAAH,IAAA;IAAA,OAC5CC,OAAO,CAACF,GAAG,CAACK,MAAM,KAAK;MAAEA,MAAM;MAAEF,MAAM;MAAEC;IAAI,CAAE,CAAC,CAAC;EAAA;EAEnD;EAAA,CACCE,MAAM,CAAC,CAACC,CAAW,EAAEC,CAAW,KAAK,CAAC,GAAGD,CAAC,EAAE,GAAGC,CAAC,CAAC,EAAE,EAAE,CAAC;EAEzD;EACAX,KAAK,GAAGE,uBAAuB,CAACO,MAAM,CACpC,CACET,KAAa,EAAAY,KAAA,KAEX;IAAA,IADF;MAAEJ,MAAM;MAAED,IAAI;MAAED;IAAM,CAAoD,GAAAM,KAAA;IAE1E;IACA,MAAMC,eAAe,GAAGP,MAAM,GAAG,CAAC;IAElC,IAAIQ,MAAM,GAAG,KAAKP,IAAI,CAACQ,KAAK,CAAC,CAAC,EAAEF,eAAe,GAAG,CAAC,CAAC,EAAE;IACtD,OAAOC,MAAM,CAACR,MAAM,GAAGO,eAAe,EAAE;MACtCC,MAAM,IAAI,GAAG;;IAGf,MAAME,KAAK,GAAGR,MAAM,GAAG,CAAC;IAExB,OAAO,GAAGR,KAAK,CAACiB,SAAS,CAAC,CAAC,EAAED,KAAK,CAAC,GAAGF,MAAM,GAAGd,KAAK,CAACiB,SAAS,CAC5DD,KAAK,GAAGH,eAAe,CACxB,EAAE;EACL,CAAC,EACDb,KAAK,CACN;EAED,OAAO,KAAKA,KAAK,EAAE;AACrB;AA7CAD,OAAA,CAAAF,WAAA,GAAAA,WAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}