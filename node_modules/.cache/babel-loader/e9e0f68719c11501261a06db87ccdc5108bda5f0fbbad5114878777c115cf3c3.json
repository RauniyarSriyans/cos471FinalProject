{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.storageSize = exports.getStateAllocations = exports.getStorageAllocations = exports.UnknownBaseContractIdError = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:storage:allocate\");\nconst Compiler = __importStar(require(\"../../compiler\"));\nconst Common = __importStar(require(\"../../common\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst Ast = __importStar(require(\"../../ast\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst Format = __importStar(require(\"../../format\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst partition_1 = __importDefault(require(\"lodash/partition\"));\nclass UnknownBaseContractIdError extends Error {\n  constructor(derivedId, derivedName, derivedKind, baseId) {\n    const message = `Cannot locate base contract ID ${baseId} of ${derivedKind} ${derivedName} (ID ${derivedId})`;\n    super(message);\n    this.name = \"UnknownBaseContractIdError\";\n    this.derivedId = derivedId;\n    this.derivedName = derivedName;\n    this.derivedKind = derivedKind;\n    this.baseId = baseId;\n  }\n}\nexports.UnknownBaseContractIdError = UnknownBaseContractIdError;\n//contracts contains only the contracts to be allocated; any base classes not\n//being allocated should just be in referenceDeclarations\nfunction getStorageAllocations(userDefinedTypesByCompilation) {\n  let allocations = {};\n  for (const compilation of Object.values(userDefinedTypesByCompilation)) {\n    const {\n      compiler,\n      types: userDefinedTypes\n    } = compilation;\n    for (const dataType of Object.values(compilation.types)) {\n      if (dataType.typeClass === \"struct\") {\n        try {\n          allocations = allocateStruct(dataType, userDefinedTypes, allocations, compiler);\n        } catch (_a) {\n          //if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n          //note: a better way of handling this would probably be to *mark* it\n          //as failed rather than throwing an exception as that would lead to less\n          //recomputation, but this is simpler and I don't think the recomputation\n          //should really be a problem\n        }\n      }\n    }\n  }\n  return allocations;\n}\nexports.getStorageAllocations = getStorageAllocations;\n/**\n * This function gets allocations for the state variables of the contracts;\n * this is distinct from getStorageAllocations, which gets allocations for\n * storage structs.\n *\n * While mostly state variables are kept in storage, constant ones are not.\n * And immutable ones, once those are introduced, will be kept in code!\n * (But those don't exist yet so this function doesn't handle them yet.)\n */\nfunction getStateAllocations(contracts, referenceDeclarations, userDefinedTypes, storageAllocations) {\n  let existingAllocations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  let allocations = existingAllocations;\n  for (const contractInfo of contracts) {\n    let {\n      contractNode: contract,\n      immutableReferences,\n      compiler,\n      compilationId\n    } = contractInfo;\n    try {\n      allocations = allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations[compilationId], userDefinedTypes, storageAllocations, allocations);\n    } catch (_a) {\n      //we're just going to allow failure here and catch the problem elsewhere\n    }\n  }\n  return allocations;\n}\nexports.getStateAllocations = getStateAllocations;\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations, compiler) {\n  //NOTE: dataType here should be a *stored* type!\n  //it is up to the caller to take care of this\n  return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations, compiler);\n}\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations, compiler) {\n  let offset = 0; //will convert to BN when placing in slot\n  let index = Evm.Utils.WORD_SIZE - 1;\n  //don't allocate things that have already been allocated\n  if (parentId in existingAllocations) {\n    return existingAllocations;\n  }\n  let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n  //otherwise, we need to allocate\n  let memberAllocations = [];\n  for (const member of members) {\n    let size;\n    ({\n      size,\n      allocations\n    } = storageSizeAndAllocate(member.type, userDefinedTypes, allocations, compiler));\n    //if it's sized in words (and we're not at the start of slot) we need to start on a new slot\n    //if it's sized in bytes but there's not enough room, we also need a new slot\n    if (Utils.isWordsLength(size) ? index < Evm.Utils.WORD_SIZE - 1 : size.bytes > index + 1) {\n      index = Evm.Utils.WORD_SIZE - 1;\n      offset += 1;\n    }\n    //otherwise, we remain in place\n    let range;\n    if (Utils.isWordsLength(size)) {\n      //words case\n      range = {\n        from: {\n          slot: {\n            offset: new bn_js_1.default(offset) //start at the current slot...\n          },\n\n          index: 0 //...at the beginning of the word.\n        },\n\n        to: {\n          slot: {\n            offset: new bn_js_1.default(offset + size.words - 1) //end at the current slot plus # of words minus 1...\n          },\n\n          index: Evm.Utils.WORD_SIZE - 1 //...at the end of the word.\n        }\n      };\n    } else {\n      //bytes case\n      range = {\n        from: {\n          slot: {\n            offset: new bn_js_1.default(offset) //start at the current slot...\n          },\n\n          index: index - (size.bytes - 1) //...early enough to fit what's being allocated.\n        },\n\n        to: {\n          slot: {\n            offset: new bn_js_1.default(offset) //end at the current slot...\n          },\n\n          index: index //...at the current position.\n        }\n      };\n    }\n\n    memberAllocations.push({\n      name: member.name,\n      type: member.type,\n      pointer: {\n        location: \"storage\",\n        range\n      }\n    });\n    //finally, adjust the current position.\n    //if it was sized in words, move down that many slots and reset position w/in slot\n    if (Utils.isWordsLength(size)) {\n      offset += size.words;\n      index = Evm.Utils.WORD_SIZE - 1;\n    }\n    //if it was sized in bytes, move down an appropriate number of bytes.\n    else {\n      index -= size.bytes;\n      //but if this puts us into the next word, move to the next word.\n      if (index < 0) {\n        index = Evm.Utils.WORD_SIZE - 1;\n        offset += 1;\n      }\n    }\n  }\n  //finally, let's determine the overall siz; we're dealing with a struct, so\n  //the size is measured in words\n  //it's one plus the last word used, i.e. one plus the current word... unless the\n  //current word remains entirely unused, then it's just the current word\n  //SPECIAL CASE: if *nothing* has been used, allocate a single word (that's how\n  //empty structs behave in versions where they're legal)\n  let totalSize;\n  if (index === Evm.Utils.WORD_SIZE - 1 && offset !== 0) {\n    totalSize = {\n      words: offset\n    };\n  } else {\n    totalSize = {\n      words: offset + 1\n    };\n  }\n  //having made our allocation, let's add it to allocations!\n  allocations[parentId] = {\n    members: memberAllocations,\n    size: totalSize\n  };\n  //...and we're done!\n  return allocations;\n}\nfunction getStateVariables(contractNode) {\n  // process for state variables\n  return contractNode.nodes.filter(node => node.nodeType === \"VariableDeclaration\" && node.stateVariable);\n}\nfunction allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations, userDefinedTypes, storageAllocations) {\n  let existingAllocations = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n  //we're going to do a 2-deep clone here\n  let allocations = Object.assign({}, ...Object.entries(existingAllocations).map(_ref => {\n    let [compilationId, compilationAllocations] = _ref;\n    return {\n      [compilationId]: Object.assign({}, compilationAllocations)\n    };\n  }));\n  if (!immutableReferences) {\n    immutableReferences = {}; //also, let's set this up for convenience\n  }\n  //base contracts are listed from most derived to most base, so we\n  //have to reverse before processing, but reverse() is in place, so we\n  //clone with slice first\n  let linearizedBaseContractsFromBase = contract.linearizedBaseContracts.slice().reverse();\n  //first, let's get all the variables under consideration\n  let variables = [].concat(...linearizedBaseContractsFromBase.map(id => {\n    let baseNode = referenceDeclarations[id];\n    if (baseNode === undefined) {\n      throw new UnknownBaseContractIdError(contract.id, contract.name, contract.contractKind, id);\n    }\n    return getStateVariables(baseNode).map(definition => ({\n      definition,\n      definedIn: baseNode\n    }));\n  }));\n  //just in case the constant field ever gets removed\n  const isConstant = definition => definition.constant || definition.mutability === \"constant\";\n  //now: we split the variables into storage, constant, and code\n  let [constantVariables, variableVariables] = (0, partition_1.default)(variables, variable => isConstant(variable.definition));\n  //why use this function instead of just checking\n  //definition.mutability?\n  //because of a bug in Solidity 0.6.5 that causes the mutability field\n  //not to exist.  So, we also have to check against immutableReferences.\n  const isImmutable = definition => definition.mutability === \"immutable\" || definition.id.toString() in immutableReferences;\n  let [immutableVariables, storageVariables] = (0, partition_1.default)(variableVariables, variable => isImmutable(variable.definition));\n  //transform storage variables into data types\n  const storageVariableTypes = storageVariables.map(variable => ({\n    name: variable.definition.name,\n    type: Ast.Import.definitionToType(variable.definition, compilationId, compiler)\n  }));\n  //let's allocate the storage variables using a fictitious ID\n  const id = \"-1\";\n  const storageVariableStorageAllocations = allocateMembers(id, storageVariableTypes, userDefinedTypes, storageAllocations, compiler)[id];\n  //transform to new format\n  const storageVariableAllocations = storageVariables.map((_ref2, index) => {\n    let {\n      definition,\n      definedIn\n    } = _ref2;\n    return {\n      definition,\n      definedIn,\n      compilationId,\n      pointer: storageVariableStorageAllocations.members[index].pointer\n    };\n  });\n  //now let's create allocations for the immutables\n  let immutableVariableAllocations = immutableVariables.map(_ref3 => {\n    let {\n      definition,\n      definedIn\n    } = _ref3;\n    let references = immutableReferences[definition.id.toString()] || [];\n    let pointer;\n    if (references.length === 0) {\n      pointer = {\n        location: \"nowhere\"\n      };\n    } else {\n      pointer = {\n        location: \"code\",\n        start: references[0].start,\n        length: references[0].length\n      };\n    }\n    return {\n      definition,\n      definedIn,\n      compilationId,\n      pointer\n    };\n  });\n  //and let's create allocations for the constants\n  let constantVariableAllocations = constantVariables.map(_ref4 => {\n    let {\n      definition,\n      definedIn\n    } = _ref4;\n    return {\n      definition,\n      definedIn,\n      compilationId,\n      pointer: {\n        location: \"definition\",\n        definition: definition.value\n      }\n    };\n  });\n  //now, reweave the three together\n  let contractAllocation = [];\n  for (let variable of variables) {\n    let arrayToGrabFrom = isConstant(variable.definition) ? constantVariableAllocations : isImmutable(variable.definition) ? immutableVariableAllocations : storageVariableAllocations;\n    contractAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n  }\n  //finally, set things and return\n  if (!allocations[compilationId]) {\n    allocations[compilationId] = {};\n  }\n  allocations[compilationId][contract.id] = {\n    members: contractAllocation\n  };\n  return allocations;\n}\n//NOTE: This wrapper function is for use in decoding ONLY, after allocation is done.\n//The allocator should (and does) instead use a direct call to storageSizeAndAllocate,\n//not to the wrapper, because it may need the allocations returned.\nfunction storageSize(dataType, userDefinedTypes, allocations, compiler) {\n  return storageSizeAndAllocate(dataType, userDefinedTypes, allocations, compiler).size;\n}\nexports.storageSize = storageSize;\nfunction storageSizeAndAllocate(dataType, userDefinedTypes, existingAllocations, compiler) {\n  //we'll only directly handle reference types here;\n  //direct types will be handled by dispatching to Basic.Allocate.byteLength\n  //in the default case\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      {\n        switch (dataType.kind) {\n          case \"static\":\n            //really a basic type :)\n            return {\n              size: {\n                bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n              },\n              allocations: existingAllocations\n            };\n          case \"dynamic\":\n            return {\n              size: {\n                words: 1\n              },\n              allocations: existingAllocations\n            };\n        }\n      }\n    case \"string\":\n    case \"mapping\":\n      return {\n        size: {\n          words: 1\n        },\n        allocations: existingAllocations\n      };\n    case \"array\":\n      {\n        switch (dataType.kind) {\n          case \"dynamic\":\n            return {\n              size: {\n                words: 1\n              },\n              allocations: existingAllocations\n            };\n          case \"static\":\n            //static array case\n            const length = dataType.length.toNumber(); //warning! but if it's too big we have a problem\n            if (length === 0) {\n              //in versions of Solidity where it's legal, arrays of length 0 still take up 1 word\n              return {\n                size: {\n                  words: 1\n                },\n                allocations: existingAllocations\n              };\n            }\n            let {\n              size: baseSize,\n              allocations\n            } = storageSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);\n            if (!Utils.isWordsLength(baseSize)) {\n              //bytes case\n              const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n              debug(\"length %o\", length);\n              const numWords = Math.ceil(length / perWord);\n              return {\n                size: {\n                  words: numWords\n                },\n                allocations\n              };\n            } else {\n              //words case\n              return {\n                size: {\n                  words: baseSize.words * length\n                },\n                allocations\n              };\n            }\n        }\n      }\n    case \"struct\":\n      {\n        let allocations = existingAllocations;\n        let allocation = allocations[dataType.id]; //may be undefined!\n        if (allocation === undefined) {\n          //if we don't find an allocation, we'll have to do the allocation ourselves\n          const storedType = userDefinedTypes[dataType.id];\n          if (!storedType) {\n            throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n          }\n          allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n          allocation = allocations[dataType.id];\n        }\n        //having found our allocation, we can just look up its size\n        return {\n          size: allocation.size,\n          allocations\n        };\n      }\n    case \"userDefinedValueType\":\n      if (Compiler.Utils.solidityFamily(compiler) === \"0.8.7+\") {\n        //UDVTs were introduced in Solidity 0.8.8.  However, in that version,\n        //and that version only, they have a bug where they always take up a\n        //full word in storage regardless of the size of the underlying type.\n        return {\n          size: {\n            words: 1\n          },\n          allocations: existingAllocations\n        };\n      }\n    //otherwise, treat them normally\n    //DELIBERATE FALL-TRHOUGH\n    default:\n      //otherwise, it's a direct type\n      return {\n        size: {\n          bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n        },\n        allocations: existingAllocations\n      };\n  }\n}","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","Compiler","__importStar","Common","Basic","Utils","Ast","Evm","Format","bn_js_1","partition_1","UnknownBaseContractIdError","Error","constructor","derivedId","derivedName","derivedKind","baseId","message","name","exports","getStorageAllocations","userDefinedTypesByCompilation","allocations","compilation","Object","values","compiler","types","userDefinedTypes","dataType","typeClass","allocateStruct","_a","getStateAllocations","contracts","referenceDeclarations","storageAllocations","existingAllocations","arguments","length","undefined","contractInfo","contractNode","contract","immutableReferences","compilationId","allocateContractState","allocateMembers","id","memberTypes","parentId","members","offset","index","WORD_SIZE","assign","memberAllocations","member","size","storageSizeAndAllocate","type","isWordsLength","bytes","range","from","slot","to","words","push","pointer","location","totalSize","getStateVariables","nodes","filter","node","nodeType","stateVariable","entries","map","_ref","compilationAllocations","linearizedBaseContractsFromBase","linearizedBaseContracts","slice","reverse","variables","concat","baseNode","contractKind","definition","definedIn","isConstant","constant","mutability","constantVariables","variableVariables","variable","isImmutable","toString","immutableVariables","storageVariables","storageVariableTypes","Import","definitionToType","storageVariableStorageAllocations","storageVariableAllocations","_ref2","immutableVariableAllocations","_ref3","references","start","constantVariableAllocations","_ref4","value","contractAllocation","arrayToGrabFrom","shift","storageSize","kind","Allocate","byteLength","toNumber","baseSize","baseType","perWord","Math","floor","numWords","ceil","allocation","storedType","UnknownUserDefinedTypeError","Types","typeString","solidityFamily"],"sources":["../../../../lib/storage/allocate/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}