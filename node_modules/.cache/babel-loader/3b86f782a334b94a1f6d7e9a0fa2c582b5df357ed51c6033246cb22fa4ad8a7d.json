{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEventAllocations = exports.getReturndataAllocations = exports.getCalldataAllocations = exports.abiSizeInfo = exports.getAbiAllocations = exports.FallbackOutputAllocation = exports.Utils = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:abi-data:allocate\");\nexports.Utils = __importStar(require(\"./utils\"));\nconst Import = __importStar(require(\"../import\"));\nconst AbiDataUtils = __importStar(require(\"../utils\"));\nconst web3_utils_1 = __importDefault(require(\"web3-utils\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst Common = __importStar(require(\"../../common\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Ast = __importStar(require(\"../../ast\"));\nconst import_1 = require(\"../../contexts/import\");\nconst Format = __importStar(require(\"../../format\"));\nconst partition_1 = __importDefault(require(\"lodash/partition\"));\nexports.FallbackOutputAllocation = {\n  kind: \"returnmessage\",\n  selector: new Uint8Array(),\n  allocationMode: \"full\"\n};\nfunction getAbiAllocations(userDefinedTypes) {\n  let allocations = {};\n  for (const dataType of Object.values(userDefinedTypes)) {\n    if (dataType.typeClass === \"struct\") {\n      try {\n        allocations = allocateStruct(dataType, userDefinedTypes, allocations);\n      } catch (_) {\n        //if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n        //note: a better way of handling this would probably be to *mark* it\n        //as failed rather than throwing an exception as that would lead to less\n        //recomputation, but this is simpler and I don't think the recomputation\n        //should really be a problem\n      }\n    }\n  }\n  return allocations;\n}\nexports.getAbiAllocations = getAbiAllocations;\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations) {\n  //NOTE: dataType here should be a *stored* type!\n  //it is up to the caller to take care of this\n  return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);\n}\n//note: we will still allocate circular structs, even though they're not allowed in the abi, because it's\n//not worth the effort to detect them.  However on mappings or internal functions, we'll vomit (allocate null)\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations) {\n  let start = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let dynamic = false;\n  //note that we will mutate the start argument also!\n  //don't allocate things that have already been allocated\n  if (parentId in existingAllocations) {\n    return existingAllocations;\n  }\n  let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n  let memberAllocations = [];\n  for (const member of members) {\n    let length;\n    let dynamicMember;\n    ({\n      size: length,\n      dynamic: dynamicMember,\n      allocations\n    } = abiSizeAndAllocate(member.type, userDefinedTypes, allocations));\n    //vomit on illegal types in calldata -- note the short-circuit!\n    if (length === undefined) {\n      allocations[parentId] = null;\n      return allocations;\n    }\n    let pointer = {\n      location: \"abi\",\n      start,\n      length\n    };\n    memberAllocations.push({\n      name: member.name,\n      type: member.type,\n      pointer\n    });\n    start += length;\n    dynamic = dynamic || dynamicMember;\n  }\n  allocations[parentId] = {\n    members: memberAllocations,\n    length: dynamic ? Evm.Utils.WORD_SIZE : start,\n    dynamic\n  };\n  return allocations;\n}\n//first return value is the actual size.\n//second return value is whether the type is dynamic\n//both will be undefined if type is a mapping or internal function\n//third return value is resulting allocations, INCLUDING the ones passed in\nfunction abiSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {\n  switch (dataType.typeClass) {\n    case \"bool\":\n    case \"address\":\n    case \"contract\":\n    case \"int\":\n    case \"uint\":\n    case \"fixed\":\n    case \"ufixed\":\n    case \"enum\":\n    case \"userDefinedValueType\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: false,\n        allocations: existingAllocations\n      };\n    case \"string\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: true,\n        allocations: existingAllocations\n      };\n    case \"bytes\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: dataType.kind === \"dynamic\",\n        allocations: existingAllocations\n      };\n    case \"mapping\":\n      return {\n        allocations: existingAllocations\n      };\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          return {\n            size: Evm.Utils.WORD_SIZE,\n            dynamic: false,\n            allocations: existingAllocations\n          };\n        case \"internal\":\n          return {\n            allocations: existingAllocations\n          };\n      }\n    case \"array\":\n      {\n        switch (dataType.kind) {\n          case \"dynamic\":\n            return {\n              size: Evm.Utils.WORD_SIZE,\n              dynamic: true,\n              allocations: existingAllocations\n            };\n          case \"static\":\n            if (dataType.length.isZero()) {\n              //arrays of length 0 are static regardless of base type\n              return {\n                size: 0,\n                dynamic: false,\n                allocations: existingAllocations\n              };\n            }\n            const {\n              size: baseSize,\n              dynamic,\n              allocations\n            } = abiSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);\n            return {\n              //WARNING!  The use of toNumber() here may throw an exception!\n              //I'm judging this OK since if you have arrays that large we have bigger problems :P\n              size: dataType.length.toNumber() * baseSize,\n              dynamic,\n              allocations\n            };\n        }\n      }\n    case \"struct\":\n      {\n        let allocations = existingAllocations;\n        let allocation = allocations[dataType.id];\n        if (allocation === undefined) {\n          //if we don't find an allocation, we'll have to do the allocation ourselves\n          const storedType = userDefinedTypes[dataType.id];\n          if (!storedType) {\n            throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n          }\n          allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n          allocation = allocations[storedType.id];\n        }\n        //having found our allocation, if it's not null, we can just look up its size and dynamicity\n        if (allocation !== null) {\n          return {\n            size: allocation.length,\n            dynamic: allocation.dynamic,\n            allocations\n          };\n        }\n        //if it is null, this type doesn't go in the abi\n        else {\n          return {\n            allocations\n          };\n        }\n      }\n    case \"tuple\":\n      {\n        //Warning! Yucky wasteful recomputation here!\n        let size = 0;\n        let dynamic = false;\n        //note that we don't just invoke allocateStruct here!\n        //why not? because it has no ID to store the result in!\n        //and we can't use a fake like -1 because there might be a recursive call to it,\n        //and then the results would overwrite each other\n        //I mean, we could do some hashing thing or something, but I think it's easier to just\n        //copy the logic in this one case (sorry)\n        for (let member of dataType.memberTypes) {\n          let {\n            size: memberSize,\n            dynamic: memberDynamic\n          } = abiSizeAndAllocate(member.type, userDefinedTypes, existingAllocations);\n          size += memberSize;\n          dynamic = dynamic || memberDynamic;\n        }\n        return {\n          size,\n          dynamic,\n          allocations: existingAllocations\n        };\n      }\n  }\n}\n//assumes you've already done allocation! don't use if you haven't!\n/**\n * @protected\n */\nfunction abiSizeInfo(dataType, allocations) {\n  let {\n    size,\n    dynamic\n  } = abiSizeAndAllocate(dataType, null, allocations);\n  //the above line should work fine... as long as allocation is already done!\n  //the middle argument, userDefinedTypes, is only needed during allocation\n  //again, this function is only for use if allocation is done, so it's safe to pass null here\n  return {\n    size,\n    dynamic\n  };\n}\nexports.abiSizeInfo = abiSizeInfo;\n//allocates an external call\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\n//NOTE: returns undefined if attempting to allocate a constructor but we don't have the\n//bytecode for the constructor\nfunction allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext) {\n  //first: determine the corresponding function node\n  //(simultaneously: determine the offset)\n  let node = undefined;\n  let inputParametersFull;\n  let outputParametersFull;\n  let inputParametersAbi;\n  let outputParametersAbi;\n  let offset; //refers to INPUT offset; output offset is always 0\n  debug(\"allocating calldata and returndata\");\n  switch (abiEntry.type) {\n    case \"constructor\":\n      if (!constructorContext) {\n        return undefined;\n      }\n      let rawLength = constructorContext.binary.length;\n      offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n      //for a constructor, we only want to search the particular contract\n      if (contractNode) {\n        node = contractNode.nodes.find(functionNode => AbiDataUtils.definitionMatchesAbi(\n        //note this needn't actually be a function node, but then it will\n        //return false (well, unless it's a getter node!)\n        abiEntry, functionNode, referenceDeclarations));\n      }\n      //if we can't find it, we'll handle this below\n      break;\n    case \"function\":\n      offset = Evm.Utils.SELECTOR_SIZE;\n      //search through base contracts, from most derived (left) to most base (right)\n      if (contractNode) {\n        const linearizedBaseContracts = contractNode.linearizedBaseContracts;\n        debug(\"linearized: %O\", linearizedBaseContracts);\n        node = findNodeAndContract(linearizedBaseContracts, referenceDeclarations, functionNode => AbiDataUtils.definitionMatchesAbi(abiEntry, functionNode, referenceDeclarations), contractNode).node; //may be undefined!  that's OK!\n        debug(\"found node: %o\", Boolean(node));\n      }\n      break;\n  }\n  //now: get the parameters (both full-mode & ABI)\n  if (node) {\n    switch (node.nodeType) {\n      case \"FunctionDefinition\":\n        //normal case\n        inputParametersFull = node.parameters.parameters;\n        outputParametersFull = node.returnParameters.parameters; //this exists even for constructors!\n        break;\n      case \"VariableDeclaration\":\n        //getter case\n        ({\n          inputs: inputParametersFull,\n          outputs: outputParametersFull\n        } = Ast.Utils.getterParameters(node, referenceDeclarations));\n        break;\n    }\n  } else {\n    inputParametersFull = undefined;\n    outputParametersFull = undefined;\n  }\n  inputParametersAbi = abiEntry.inputs;\n  switch (abiEntry.type) {\n    case \"function\":\n      outputParametersAbi = abiEntry.outputs;\n      break;\n    case \"constructor\":\n      //we just leave this empty for constructors\n      outputParametersAbi = [];\n      break;\n  }\n  //now: do the allocation!\n  let {\n    allocation: abiAllocationInput,\n    mode: inputMode\n  } = allocateDataArguments(inputParametersFull, inputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, offset);\n  let {\n    allocation: abiAllocationOutput,\n    mode: outputMode\n  } = allocateDataArguments(outputParametersFull, outputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler\n  //note no offset\n  );\n\n  debug(\"modes: %s in, %s out\", inputMode, outputMode);\n  //finally: transform the allocation appropriately\n  let inputArgumentsAllocation = abiAllocationInput.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"calldata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  let outputArgumentsAllocation = abiAllocationOutput.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"returndata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  let inputsAllocation = {\n    abi: abiEntry,\n    offset,\n    arguments: inputArgumentsAllocation,\n    allocationMode: inputMode\n  };\n  let outputsAllocation;\n  switch (abiEntry.type) {\n    case \"function\":\n      outputsAllocation = {\n        selector: new Uint8Array(),\n        arguments: outputArgumentsAllocation,\n        allocationMode: outputMode,\n        kind: \"return\"\n      };\n      break;\n    case \"constructor\":\n      outputsAllocation = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, outputMode);\n      break;\n  }\n  return {\n    input: inputsAllocation,\n    output: outputsAllocation\n  }; //TS chokes on this for some reason\n}\n//note: allocateEvent doesn't use this because it needs additional\n//handling for indexed parameters (maybe these can be unified in\n//the future though?)\nfunction allocateDataArguments(fullModeParameters, abiParameters, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let offset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  let allocationMode = fullModeParameters ? \"full\" : \"abi\"; //can degrade\n  let parameterTypes;\n  let abiAllocation;\n  if (allocationMode === \"full\") {\n    let id = \"-1\"; //fake ID that doesn't matter\n    parameterTypes = fullModeParameters.map(parameter => ({\n      name: parameter.name,\n      type: Ast.Import.definitionToType(parameter, compilationId, compiler) //if node is defined, compiler had also better be!\n    }));\n\n    debug(\"parameterTypes: %O\", parameterTypes);\n    //now: perform the allocation!\n    try {\n      abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n    } catch (_a) {\n      //if something goes wrong, switch to ABI mdoe\n      debug(\"falling back to ABI due to exception!\");\n      allocationMode = \"abi\";\n    }\n  }\n  if (allocationMode === \"abi\") {\n    //THIS IS DELIBERATELY NOT AN ELSE\n    //this is the ABI case.  we end up here EITHER\n    //if node doesn't exist, OR if something went wrong\n    //during allocation\n    let id = \"-1\"; //fake irrelevant ID\n    parameterTypes = abiParameters.map(parameter => ({\n      name: parameter.name,\n      type: Import.abiParameterToType(parameter)\n    }));\n    abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n  }\n  return {\n    allocation: abiAllocation,\n    mode: allocationMode\n  };\n}\n//allocates an event\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\nfunction allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let parameterTypes;\n  let nodeId;\n  let id;\n  //first: determine the corresponding event node\n  //search through base contracts, from most derived (right) to most base (left)\n  let node = undefined;\n  let definedIn = undefined;\n  let allocationMode = \"full\"; //degrade to abi as needed\n  debug(\"allocating ABI: %O\", abiEntry);\n  if (contractNode) {\n    //first: check same contract for the event\n    node = contractNode.nodes.find(eventNode => AbiDataUtils.definitionMatchesAbi(\n    //note this needn't actually be an event node, but then it will\n    //return false\n    abiEntry, eventNode, referenceDeclarations));\n    //if we found the node, great!  If not...\n    if (!node) {\n      debug(\"didn't find node in base contract...\");\n      //let's search for the node among the base contracts.\n      //but if we find it...\n      //[note: the following code is overcomplicated; it was used\n      //when we were trying to get the actual node, it's overcomplicated\n      //now that we're just determining its presence.  oh well]\n      let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n      linearizedBaseContractsMinusSelf.shift(); //remove self\n      debug(\"checking contracts: %o\", linearizedBaseContractsMinusSelf);\n      node = findNodeAndContract(linearizedBaseContractsMinusSelf, referenceDeclarations, eventNode => AbiDataUtils.definitionMatchesAbi(\n      //note this needn't actually be a event node, but then it will return false\n      abiEntry, eventNode, referenceDeclarations)\n      //don't pass deriveContractNode here, we're not checking the contract itself\n      ).node; //may be undefined! that's OK!\n      if (node) {\n        //...if we find the node in an ancestor, we\n        //deliberately *don't* allocate!  instead such cases\n        //will be handled during a later combination step\n        debug(\"bailing out for later handling!\");\n        debug(\"ABI: %O\", abiEntry);\n        return undefined;\n      }\n    }\n  }\n  //otherwise, leave node undefined\n  if (node) {\n    debug(\"found node\");\n    //if we found the node, let's also turn it into a type\n    definedIn = Ast.Import.definitionToStoredType(contractNode, compilationId, compiler); //can skip reference declarations argument here\n    //...and set the ID\n    id = (0, import_1.makeTypeId)(node.id, compilationId);\n  } else {\n    //if no node, have to fall back into ABI mode\n    debug(\"falling back to ABI because no node\");\n    allocationMode = \"abi\";\n  }\n  //now: construct the list of parameter types, attaching indexedness info\n  //and overall position (for later reconstruction)\n  let indexed;\n  let nonIndexed;\n  let abiAllocation; //the untransformed allocation for the non-indexed parameters\n  if (allocationMode === \"full\") {\n    nodeId = node.id.toString();\n    let parameters = node.parameters.parameters;\n    parameterTypes = parameters.map(definition => ({\n      //note: if node is defined, compiler had better be defined, too!\n      type: Ast.Import.definitionToType(definition, compilationId, compiler),\n      name: definition.name,\n      indexed: definition.indexed\n    }));\n    //now: split the list of parameters into indexed and non-indexed\n    [indexed, nonIndexed] = (0, partition_1.default)(parameterTypes, parameter => parameter.indexed);\n    try {\n      //now: perform the allocation for the non-indexed parameters!\n      abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair\n    } catch (_a) {\n      allocationMode = \"abi\";\n    }\n  }\n  if (allocationMode === \"abi\") {\n    //THIS IS DELIBERATELY NOT AN ELSE\n    nodeId = \"-1\"; //fake irrelevant ID\n    parameterTypes = abiEntry.inputs.map(abiParameter => ({\n      type: Import.abiParameterToType(abiParameter),\n      name: abiParameter.name,\n      indexed: abiParameter.indexed\n    }));\n    //now: split the list of parameters into indexed and non-indexed\n    [indexed, nonIndexed] = (0, partition_1.default)(parameterTypes, parameter => parameter.indexed);\n    //now: perform the allocation for the non-indexed parameters!\n    abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair\n  }\n  //now: transform the result appropriately\n  const nonIndexedArgumentsAllocation = abiAllocation.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"eventdata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  //now: allocate the indexed parameters\n  const startingTopic = abiEntry.anonymous ? 0 : 1; //if not anonymous, selector takes up topic 0\n  const indexedArgumentsAllocation = indexed.map((_ref, position) => {\n    let {\n      type,\n      name\n    } = _ref;\n    return {\n      type,\n      name,\n      pointer: {\n        location: \"eventtopic\",\n        topic: startingTopic + position\n      }\n    };\n  });\n  //finally: weave these back together\n  let argumentsAllocation = [];\n  for (let parameter of parameterTypes) {\n    let arrayToGrabFrom = parameter.indexed ? indexedArgumentsAllocation : nonIndexedArgumentsAllocation;\n    argumentsAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n  }\n  //...and return\n  return {\n    abi: abiEntry,\n    contextHash: undefined,\n    definedIn,\n    id,\n    arguments: argumentsAllocation,\n    allocationMode,\n    anonymous: abiEntry.anonymous\n  };\n}\nfunction allocateError(abiEntry, errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  //first: if we got passed just a node & no abi entry,\n  let id = undefined;\n  let definedIn = undefined;\n  let parametersFull = undefined;\n  const parametersAbi = abiEntry.inputs;\n  if (errorNode) {\n    //first, set parametersFull\n    parametersFull = errorNode.parameters.parameters;\n    //now, set id\n    id = (0, import_1.makeTypeId)(errorNode.id, compilationId);\n    //now, set definedIn\n    let contractNode = null;\n    for (const node of Object.values(referenceDeclarations)) {\n      if (node.nodeType === \"ContractDefinition\") {\n        if (node.nodes.some(subNode => subNode.id === errorNode.id)) {\n          contractNode = node;\n          break;\n        }\n      }\n      //if we didn't find it, then contractNode is null\n      //(and thus so will be definedIn)\n    }\n\n    if (contractNode === null) {\n      definedIn = null;\n    } else {\n      definedIn = Ast.Import.definitionToStoredType(contractNode, compilationId, compiler);\n    }\n  }\n  //otherwise, leave parametersFull, id, and definedIn undefined\n  const {\n    allocation: abiAllocation,\n    mode: allocationMode\n  } = allocateDataArguments(parametersFull, parametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, Evm.Utils.SELECTOR_SIZE //errors use a 4-byte selector\n  );\n  //finally: transform the allocation appropriately\n  const argumentsAllocation = abiAllocation.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"returndata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  const selector = Conversion.toBytes(AbiDataUtils.abiSelector(abiEntry));\n  return {\n    kind: \"revert\",\n    selector,\n    abi: abiEntry,\n    id,\n    definedIn,\n    arguments: argumentsAllocation,\n    allocationMode\n  };\n}\nfunction getCalldataAllocationsForContract(abi, contractNode, constructorContext, deployedContext, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let allocations = {\n    constructorAllocation: undefined,\n    //(if it doesn't then it will remain as default)\n    functionAllocations: {}\n  };\n  if (!abi) {\n    //if no ABI, can't do much!\n    allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n    return allocations;\n  }\n  for (let abiEntry of abi) {\n    if (AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry) || AbiDataUtils.abiEntryHasStorageParameters(abiEntry)) {\n      //the first of these conditions is a hack workaround for a Solidity bug.\n      //the second of these is because... seriously? we're not handling these\n      //(at least not for now!) (these only exist prior to Solidity 0.5.6,\n      //thankfully)\n      continue;\n    }\n    switch (abiEntry.type) {\n      case \"constructor\":\n        allocations.constructorAllocation = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n        debug(\"constructor alloc: %O\", allocations.constructorAllocation);\n        break;\n      case \"function\":\n        allocations.functionAllocations[AbiDataUtils.abiSelector(abiEntry)] = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n        break;\n      default:\n        //skip over fallback, error, and event\n        break;\n    }\n  }\n  if (!allocations.constructorAllocation) {\n    //set a default constructor allocation if we haven't allocated one yet\n    allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n    debug(\"default constructor alloc: %O\", allocations.constructorAllocation);\n  }\n  return allocations;\n}\nfunction defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext) {\n  if (!constructorContext) {\n    return undefined;\n  }\n  const rawLength = constructorContext.binary.length;\n  const offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n  const input = {\n    offset,\n    abi: AbiDataUtils.DEFAULT_CONSTRUCTOR_ABI,\n    arguments: [],\n    allocationMode: \"full\"\n  };\n  const output = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, \"full\"); //assume full, degrade as necessary\n  return {\n    input,\n    output\n  };\n}\n//note: context should be deployed context!\nfunction constructorOutputAllocation(context, contractNode, referenceDeclarations, allocationMode) {\n  if (!context) {\n    //just return a default abi mode result\n    return {\n      selector: new Uint8Array(),\n      allocationMode: \"abi\",\n      kind: \"bytecode\",\n      delegatecallGuard: false\n    };\n  }\n  const {\n    immutableReferences,\n    compilationId,\n    compiler,\n    contractKind,\n    binary\n  } = context;\n  let immutables;\n  if (allocationMode === \"full\" && immutableReferences) {\n    if (contractNode) {\n      debug(\"allocating immutables\");\n      immutables = [];\n      for (const [id, references] of Object.entries(immutableReferences)) {\n        if (references.length === 0) {\n          continue; //don't allocate immutables that don't exist\n        }\n\n        const astId = parseInt(id);\n        //get the corresponding variable node; potentially fail\n        const {\n          node: definition,\n          contract: definedIn\n        } = findNodeAndContract(contractNode.linearizedBaseContracts, referenceDeclarations, node => node.id === astId, contractNode);\n        if (!definition || definition.nodeType !== \"VariableDeclaration\") {\n          debug(\"didn't find definition for %d!\", astId);\n          allocationMode = \"abi\";\n          immutables = undefined;\n          break;\n        }\n        const definedInClass = Ast.Import.definitionToStoredType(definedIn, compilationId, compiler); //can skip reference declarations argument here\n        const dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n        immutables.push({\n          name: definition.name,\n          definedIn: definedInClass,\n          type: dataType,\n          pointer: {\n            location: \"returndata\",\n            start: references[0].start,\n            length: references[0].length\n          }\n        });\n      }\n    } else if (Object.entries(immutableReferences).length > 0) {\n      //if there are immutables, but no contract mode, go to abi mode\n      debug(\"immutables but no node!\");\n      allocationMode = \"abi\";\n    }\n  } else {\n    debug(\"no immutables\");\n  }\n  //now, is there a delegatecall guard?\n  let delegatecallGuard = false;\n  if (contractKind === \"library\") {\n    //note: I am relying on this being present!\n    //(also this part is a bit HACKy)\n    const pushAddressInstruction = (0x5f + Evm.Utils.ADDRESS_SIZE).toString(16); //\"73\"\n    const delegateCallGuardString = \"0x\" + pushAddressInstruction + \"..\".repeat(Evm.Utils.ADDRESS_SIZE);\n    if (binary.startsWith(delegateCallGuardString)) {\n      delegatecallGuard = true;\n    }\n  }\n  return {\n    selector: new Uint8Array(),\n    allocationMode,\n    kind: \"bytecode\",\n    immutables,\n    delegatecallGuard\n  };\n}\nfunction getCalldataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  let allocations = {\n    constructorAllocations: {},\n    functionAllocations: {}\n  };\n  for (let contract of contracts) {\n    const contractAllocations = getCalldataAllocationsForContract(contract.abi, contract.contractNode, contract.constructorContext, contract.deployedContext, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n    if (contract.constructorContext) {\n      allocations.constructorAllocations[contract.constructorContext.context] = contractAllocations.constructorAllocation;\n    }\n    if (contract.deployedContext) {\n      allocations.functionAllocations[contract.deployedContext.context] = contractAllocations.functionAllocations;\n      //set this up under both constructor *and* deployed! this is to handle\n      //constructor returndata decoding\n      allocations.constructorAllocations[contract.deployedContext.context] = contractAllocations.constructorAllocation;\n    }\n  }\n  return allocations;\n}\nexports.getCalldataAllocations = getCalldataAllocations;\nfunction getReturndataAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let useAst = Boolean(contractNode && contractNode.usedErrors);\n  if (useAst) {\n    const errorNodes = contractNode.usedErrors.map(errorNodeId => referenceDeclarations[errorNodeId]);\n    let abis;\n    try {\n      abis = errorNodes.map(errorNode => Ast.Utils.definitionToAbi(errorNode, referenceDeclarations));\n    } catch (_a) {\n      useAst = false;\n    }\n    if (useAst) {\n      //i.e. if the above operation succeeded\n      return contractNode.usedErrors.map(errorNodeId => referenceDeclarations[errorNodeId]).map((errorNode, index) => allocateError(abis[index], errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));\n    }\n  }\n  if (!useAst && abi) {\n    //deliberately *not* an else!\n    return abi.filter(abiEntry => abiEntry.type === \"error\").filter(abiEntry => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround\n    .map(abiEntry => allocateError(abiEntry, undefined, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));\n  }\n  //otherwise just return nothing\n  return [];\n}\nfunction getReturndataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  let allContexts = [].concat(...contracts.map(_ref2 => {\n    let {\n      deployedContext,\n      constructorContext\n    } = _ref2;\n    return [deployedContext, constructorContext];\n  })).filter(x => x) //filter out nonexistent contexts\n  .map(context => context.context);\n  allContexts.push(\"\"); //HACK: add fictional empty-string context to represent no-context\n  //holds allocations for a given context\n  let selfAllocations = {};\n  //holds allocations for *other* contexts\n  let additionalAllocations = {};\n  //now: process the allocations for each contract. we'll add each contract's\n  //allocations to *its* entries in allocations, and to every *other* entry\n  //in additionalAllocations.\n  for (const contract of contracts) {\n    const contractAllocations = getReturndataAllocationsForContract(contract.abi, contract.contractNode, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n    const contexts = [\n    //contexts for this contract\n    contract.deployedContext, contract.constructorContext].filter(x => x) //filter out nonexistent contexts\n    .map(context => context.context);\n    const otherContexts = allContexts.filter(\n    //contexts for all other contracts\n    contextHash => !contexts.includes(contextHash));\n    //add them to selfAllocations\n    for (const contextHash of contexts) {\n      selfAllocations[contextHash] = contractAllocations;\n    }\n    //add them to additionalAllocations\n    for (const contextHash of otherContexts) {\n      if (additionalAllocations[contextHash] === undefined) {\n        additionalAllocations[contextHash] = [];\n      }\n      additionalAllocations[contextHash] = additionalAllocations[contextHash].concat(contractAllocations);\n    }\n  }\n  let allocations = Object.assign({}, ...allContexts.map(contextHash => ({\n    [contextHash]: {}\n  })));\n  //now: perform coalescense!\n  for (const contract of contracts) {\n    //we're setting up contexts again, sorry >_>\n    const contexts = [\n    //contexts for this contract\n    contract.deployedContext, contract.constructorContext].filter(x => x) //filter out nonexistent contexts\n    .map(context => context.context);\n    for (const contextHash of contexts) {\n      allocations[contextHash] = coalesceReturndataAllocations(selfAllocations[contextHash] || [], additionalAllocations[contextHash] || []);\n      debug(\"allocations: %O\", allocations[contextHash]);\n    }\n  }\n  //...also coalesce the fake \"\" context\n  allocations[\"\"] = coalesceReturndataAllocations([], additionalAllocations[\"\"] || []);\n  debug(\"error allocations: %O\", allocations);\n  return allocations;\n}\nexports.getReturndataAllocations = getReturndataAllocations;\nfunction coalesceReturndataAllocations(selfAllocations, additionalAllocations) {\n  let bySelector = {};\n  //start with the additional allocations; we want to process\n  //the self allocations last, due to special handling of no-ID allocations there\n  for (const allocation of additionalAllocations) {\n    const signature = AbiDataUtils.abiSignature(allocation.abi);\n    const selector = web3_utils_1.default.soliditySha3({\n      type: \"string\",\n      value: signature\n    }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n    if (bySelector[selector]) {\n      //note: at this point, for any given signature, there should only be a\n      //no-ID allocation for that signature if it's the only one\n      if (allocation.id !== undefined) {\n        //delete anything with that signature but w/o an ID, or with this same ID\n        bySelector[selector] = bySelector[selector].filter(_ref3 => {\n          let {\n            abi,\n            id\n          } = _ref3;\n          return !(AbiDataUtils.abiSignature(abi) === signature && (id === undefined || id === allocation.id));\n        });\n        //add this allocation\n        bySelector[selector].push(allocation);\n      } else if (!bySelector[selector].some(_ref4 => {\n        let {\n          abi\n        } = _ref4;\n        return AbiDataUtils.abiSignature(abi) === signature;\n      })) {\n        //only add ID-less ones if there isn't anything of that signature already\n        bySelector[selector].push(allocation);\n      }\n    } else {\n      //if there's nothing there thus far, add it\n      bySelector[selector] = [allocation];\n    }\n  }\n  //now we're going to perform a modified version of this procedure for the self allocations:\n  //1. we're going to add to the front, not the back\n  //2. we can add an ID-less one even if there are already ones with IDs there\n  //(sorry for the copypaste)\n  for (const allocation of selfAllocations) {\n    const signature = AbiDataUtils.abiSignature(allocation.abi);\n    const selector = web3_utils_1.default.soliditySha3({\n      type: \"string\",\n      value: signature\n    }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n    if (bySelector[selector]) {\n      //delete anything with that signature but w/o an ID, or with this same ID\n      //(if this alloc has no ID, this will only delete ID-less ones :) )\n      bySelector[selector] = bySelector[selector].filter(_ref5 => {\n        let {\n          abi,\n          id\n        } = _ref5;\n        return !(AbiDataUtils.abiSignature(abi) === signature && (id === undefined || id === allocation.id));\n      });\n      //add this allocation to front, not back!\n      bySelector[selector].unshift(allocation);\n    } else {\n      //if there's nothing there thus far, add it\n      bySelector[selector] = [allocation];\n    }\n  }\n  return bySelector;\n}\nfunction getEventAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  if (!abi) {\n    //can't do much if no ABI!\n    return [];\n  }\n  return abi.filter(abiEntry => abiEntry.type === \"event\").filter(abiEntry => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround\n  .map(abiEntry => ({\n    selector: AbiDataUtils.abiSelector(abiEntry),\n    anonymous: abiEntry.anonymous,\n    topics: AbiDataUtils.topicsCount(abiEntry),\n    allocation: allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler)\n  }));\n  //note we do *not* filter out undefined allocations; we need these as placeholders\n}\n//WARNING: this function is full of hacks... sorry\nfunction getEventAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  let allowConstructorEvents = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  //first: do allocations for individual contracts\n  let individualAllocations = {};\n  let groupedAllocations = {};\n  let contextSwapMap = {}; //maps deployed to constructor & vice versa\n  let allocations = {};\n  for (const {\n    abi,\n    deployedContext,\n    constructorContext,\n    contractNode,\n    compilationId,\n    compiler\n  } of contracts) {\n    if (!deployedContext && !constructorContext && !contractNode) {\n      //we'll need *one* of these at least\n      continue;\n    }\n    const contractAllocations = getEventAllocationsForContract(abi, contractNode, referenceDeclarations[compilationId], userDefinedTypes, abiAllocations, compilationId, compiler);\n    const key = makeContractKey(deployedContext || constructorContext, contractNode ? contractNode.id : undefined, compilationId);\n    if (individualAllocations[key] === undefined) {\n      individualAllocations[key] = {};\n    }\n    for (const allocationTemporary of contractAllocations) {\n      //we'll use selector *even for anonymous* here, because it's just\n      //for determining what overrides what at this point\n      individualAllocations[key][allocationTemporary.selector] = {\n        context: deployedContext || constructorContext,\n        contractNode,\n        allocationTemporary,\n        compilationId\n      };\n    }\n    //also: set up the swap map\n    if (deployedContext && constructorContext) {\n      contextSwapMap[deployedContext.context] = constructorContext.context;\n      contextSwapMap[constructorContext.context] = deployedContext.context;\n    }\n  }\n  //now: put things together for inheritance\n  //note how we always put things in order from most derived to most base\n  for (let contextOrId in individualAllocations) {\n    groupedAllocations[contextOrId] = {};\n    for (let selector in individualAllocations[contextOrId]) {\n      let {\n        context,\n        contractNode,\n        allocationTemporary,\n        compilationId\n      } = individualAllocations[contextOrId][selector];\n      debug(\"allocationTemporary: %O\", allocationTemporary);\n      let allocationsTemporary = allocationTemporary.allocation ? [allocationTemporary] : []; //filter out undefined allocations\n      //first, copy from individual allocations\n      groupedAllocations[contextOrId][selector] = {\n        context,\n        contractNode,\n        allocationsTemporary\n      };\n      //if no contract node, that's all.  if there is...\n      if (contractNode) {\n        //...we have to do inheritance processing\n        debug(\"contract Id: %d\", contractNode.id);\n        debug(\"base contracts: %o\", contractNode.linearizedBaseContracts);\n        let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n        linearizedBaseContractsMinusSelf.shift(); //remove contract itself; only want ancestors\n        for (let baseId of linearizedBaseContractsMinusSelf) {\n          debug(\"checking baseId: %d\", baseId);\n          let baseNode = referenceDeclarations[compilationId][baseId];\n          if (!baseNode || baseNode.nodeType !== \"ContractDefinition\") {\n            debug(\"failed to find node for baseId: %d\", baseId);\n            break; //not a continue!\n            //if we can't find the base node, it's better to stop the loop,\n            //rather than continue to potentially erroneous things\n          }\n          //note: we're not actually going to *use* the baseNode here.\n          //we're just checking for whether we can *find* it\n          //why? because if we couldn't find it, that means that events defined in\n          //base contracts *weren't* skipped earlier, and so we shouldn't now add them in\n          let baseContractInfo = contracts.find(contractAllocationInfo => contractAllocationInfo.compilationId === compilationId && contractAllocationInfo.contractNode && contractAllocationInfo.contractNode.id === baseId);\n          if (!baseContractInfo) {\n            //similar to above... this failure case can happen when there are\n            //two contracts with the same name and you attempt to use the\n            //artifacts; say you have contracts A, B, and B', where A inherits\n            //from B, and B and B' have the same name, and B' is the one that\n            //gets the artifact; B will end up in reference declarations and so\n            //get found above, but it won't appear in contracts, causing the\n            //problem here.  Unfortunately I don't know any great way to handle this,\n            //so, uh, we treat it as a failure same as above.\n            debug(\"failed to find contract info for baseId: %d\", baseId);\n            break;\n          }\n          let baseContext = baseContractInfo.deployedContext || baseContractInfo.constructorContext;\n          let baseKey = makeContractKey(baseContext, baseId, compilationId);\n          if (individualAllocations[baseKey][selector] !== undefined) {\n            let baseAllocation = individualAllocations[baseKey][selector].allocationTemporary;\n            debug(\"(probably) pushing inherited alloc from baseId: %d\", baseId);\n            if (baseAllocation.allocation) {\n              //don't push undefined!\n              groupedAllocations[contextOrId][selector].allocationsTemporary.push(baseAllocation);\n            }\n          }\n        }\n      }\n    }\n  }\n  //finally: transform into final form & return,\n  //filtering out things w/o a context\n  for (let contractKey in groupedAllocations) {\n    if (!hasContext(contractKey)) {\n      continue;\n      //(this filters out ones that had no context and therefore were\n      //given by ID; we needed these at the previous stage but from\n      //here on they're irrelevant)\n    }\n\n    let contextHash = contextHashForKey(contractKey);\n    for (let selector in groupedAllocations[contextHash]) {\n      let {\n        allocationsTemporary,\n        context\n      } = groupedAllocations[contextHash][selector];\n      for (let {\n        anonymous,\n        topics,\n        allocation\n      } of allocationsTemporary) {\n        let contractKind = context.contractKind; //HACK: this is the wrong context, but libraries can't inherit, so it's OK\n        if (contractKind !== \"library\") {\n          contractKind = \"contract\"; //round off interfaces to being contracts for our purposes :P\n        }\n\n        allocation = Object.assign(Object.assign({}, allocation), {\n          contextHash\n        }); //the allocation's context hash at this point depends on where it was defined, but\n        //that's not what we want going in the final allocation table!\n        if (allocations[topics] === undefined) {\n          allocations[topics] = {\n            bySelector: {},\n            anonymous: {\n              contract: {},\n              library: {}\n            }\n          };\n        }\n        if (!anonymous) {\n          if (allocations[topics].bySelector[selector] === undefined) {\n            allocations[topics].bySelector[selector] = {\n              contract: {},\n              library: {}\n            };\n          }\n          //push the allocation (non-anonymous case)\n          if (allocations[topics].bySelector[selector][contractKind][contextHash] === undefined) {\n            allocations[topics].bySelector[selector][contractKind][contextHash] = [];\n          }\n          allocations[topics].bySelector[selector][contractKind][contextHash].push(allocation);\n          //...and push it in the swapped context too if that exists\n          //HACK: don't do this for libraries! library events are already\n          //considered always in play, so including them *twice* would cause\n          //problems... fortunately library constructors don't emit events!\n          if (allowConstructorEvents && contextHash in contextSwapMap && contractKind !== \"library\") {\n            const swappedHash = contextSwapMap[contextHash];\n            if (allocations[topics].bySelector[selector][contractKind][swappedHash] === undefined) {\n              allocations[topics].bySelector[selector][contractKind][swappedHash] = [];\n            }\n            allocations[topics].bySelector[selector][contractKind][swappedHash].push(allocation);\n          }\n        } else {\n          //push the allocation (anonymous case)\n          if (allocations[topics].anonymous[contractKind][contextHash] === undefined) {\n            allocations[topics].anonymous[contractKind][contextHash] = [];\n          }\n          allocations[topics].anonymous[contractKind][contextHash].push(allocation);\n          //...and push it in the swapped context too if that exists\n          //(and it's not a library, see above)\n          if (allowConstructorEvents && contextHash in contextSwapMap && contractKind !== \"library\") {\n            const swappedHash = contextSwapMap[contextHash];\n            if (allocations[topics].anonymous[contractKind][swappedHash] === undefined) {\n              allocations[topics].anonymous[contractKind][swappedHash] = [];\n            }\n            allocations[topics].anonymous[contractKind][swappedHash].push(allocation);\n          }\n        }\n      }\n    }\n  }\n  return allocations;\n}\nexports.getEventAllocations = getEventAllocations;\n//if derivedContractNode is passed, we check that before referenceDeclarations\nfunction findNodeAndContract(linearizedBaseContracts, referenceDeclarations, condition, derivedContractNode) {\n  const searchResult = linearizedBaseContracts.reduce((foundNodeAndContract, baseContractId) => {\n    if (foundNodeAndContract !== undefined) {\n      return foundNodeAndContract; //once we've found something, we don't need to keep looking\n    }\n\n    debug(\"searching contract %d\", baseContractId);\n    let baseContractNode = derivedContractNode && baseContractId === derivedContractNode.id ? derivedContractNode //skip the lookup if we already have the right node! this is to reduce errors from collision\n    : referenceDeclarations[baseContractId];\n    if (baseContractNode === undefined || baseContractNode.nodeType !== \"ContractDefinition\") {\n      debug(\"bad contract node!\");\n      return null; //return null rather than undefined so that this will propagate through\n      //(i.e. by returning null here we give up the search)\n      //(we don't want to continue due to possibility of grabbing the wrong override)\n    }\n\n    const node = baseContractNode.nodes.find(condition); //may be undefined! that's OK!\n    if (node) {\n      debug(\"found node: %o\", node);\n      return {\n        node,\n        contract: baseContractNode\n      };\n    } else {\n      return undefined;\n    }\n  }, undefined //start with no node found\n  );\n\n  return searchResult || {\n    node: undefined,\n    contract: undefined\n  };\n}\nfunction makeContractKey(context, id, compilationId) {\n  return context ? context.context : id + \":\" + compilationId; //HACK!\n}\n\nfunction hasContext(key) {\n  return key.startsWith(\"0x\"); //HACK!\n}\n\nfunction contextHashForKey(key) {\n  return hasContext(key) ? key //HACK!\n  : undefined;\n}","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","exports","Utils","__importStar","Import","AbiDataUtils","web3_utils_1","Evm","Common","Conversion","Ast","import_1","Format","partition_1","FallbackOutputAllocation","kind","selector","Uint8Array","allocationMode","getAbiAllocations","userDefinedTypes","allocations","dataType","Object","values","typeClass","allocateStruct","_","existingAllocations","allocateMembers","id","memberTypes","parentId","members","start","arguments","length","undefined","dynamic","assign","memberAllocations","member","dynamicMember","size","abiSizeAndAllocate","type","pointer","location","push","name","WORD_SIZE","visibility","isZero","baseSize","baseType","toNumber","allocation","storedType","UnknownUserDefinedTypeError","Types","typeString","memberSize","memberDynamic","abiSizeInfo","allocateCalldataAndReturndata","abiEntry","contractNode","referenceDeclarations","abiAllocations","compilationId","compiler","constructorContext","deployedContext","node","inputParametersFull","outputParametersFull","inputParametersAbi","outputParametersAbi","offset","rawLength","binary","nodes","find","functionNode","definitionMatchesAbi","SELECTOR_SIZE","linearizedBaseContracts","findNodeAndContract","Boolean","nodeType","parameters","returnParameters","inputs","outputs","getterParameters","abiAllocationInput","mode","inputMode","allocateDataArguments","abiAllocationOutput","outputMode","inputArgumentsAllocation","map","outputArgumentsAllocation","inputsAllocation","abi","outputsAllocation","constructorOutputAllocation","input","output","fullModeParameters","abiParameters","parameterTypes","abiAllocation","parameter","definitionToType","_a","abiParameterToType","allocateEvent","nodeId","definedIn","eventNode","linearizedBaseContractsMinusSelf","slice","shift","definitionToStoredType","makeTypeId","indexed","nonIndexed","toString","definition","abiParameter","nonIndexedArgumentsAllocation","startingTopic","anonymous","indexedArgumentsAllocation","_ref","position","topic","argumentsAllocation","arrayToGrabFrom","contextHash","allocateError","errorNode","parametersFull","parametersAbi","some","subNode","toBytes","abiSelector","getCalldataAllocationsForContract","constructorAllocation","functionAllocations","defaultConstructorAllocation","abiEntryIsObviouslyIllTyped","abiEntryHasStorageParameters","DEFAULT_CONSTRUCTOR_ABI","context","delegatecallGuard","immutableReferences","contractKind","immutables","references","entries","astId","parseInt","contract","definedInClass","pushAddressInstruction","ADDRESS_SIZE","delegateCallGuardString","repeat","startsWith","getCalldataAllocations","contracts","constructorAllocations","contractAllocations","getReturndataAllocationsForContract","useAst","usedErrors","errorNodes","errorNodeId","abis","definitionToAbi","index","filter","getReturndataAllocations","allContexts","concat","_ref2","x","selfAllocations","additionalAllocations","contexts","otherContexts","includes","coalesceReturndataAllocations","bySelector","signature","abiSignature","soliditySha3","value","_ref3","_ref4","_ref5","unshift","getEventAllocationsForContract","topics","topicsCount","getEventAllocations","allowConstructorEvents","individualAllocations","groupedAllocations","contextSwapMap","key","makeContractKey","allocationTemporary","contextOrId","allocationsTemporary","baseId","baseNode","baseContractInfo","contractAllocationInfo","baseContext","baseKey","baseAllocation","contractKey","hasContext","contextHashForKey","library","swappedHash","condition","derivedContractNode","searchResult","reduce","foundNodeAndContract","baseContractId","baseContractNode"],"sources":["../../../../lib/abi-data/allocate/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}