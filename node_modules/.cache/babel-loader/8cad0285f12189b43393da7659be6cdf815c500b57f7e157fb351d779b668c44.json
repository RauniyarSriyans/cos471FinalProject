{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FrequencyArbitrary = void 0;\nconst Stream_1 = require(\"../../stream/Stream\");\nconst Arbitrary_1 = require(\"../../check/arbitrary/definition/Arbitrary\");\nconst Value_1 = require(\"../../check/arbitrary/definition/Value\");\nconst DepthContext_1 = require(\"./helpers/DepthContext\");\nconst MaxLengthFromMinLength_1 = require(\"./helpers/MaxLengthFromMinLength\");\nclass FrequencyArbitrary extends Arbitrary_1.Arbitrary {\n  constructor(warbs, constraints, context) {\n    super();\n    this.warbs = warbs;\n    this.constraints = constraints;\n    this.context = context;\n    let currentWeight = 0;\n    this.cumulatedWeights = [];\n    for (let idx = 0; idx !== warbs.length; ++idx) {\n      currentWeight += warbs[idx].weight;\n      this.cumulatedWeights.push(currentWeight);\n    }\n    this.totalWeight = currentWeight;\n  }\n  static from(warbs, constraints, label) {\n    if (warbs.length === 0) {\n      throw new Error(`${label} expects at least one weighted arbitrary`);\n    }\n    let totalWeight = 0;\n    for (let idx = 0; idx !== warbs.length; ++idx) {\n      const currentArbitrary = warbs[idx].arbitrary;\n      if (currentArbitrary === undefined) {\n        throw new Error(`${label} expects arbitraries to be specified`);\n      }\n      const currentWeight = warbs[idx].weight;\n      totalWeight += currentWeight;\n      if (!Number.isInteger(currentWeight)) {\n        throw new Error(`${label} expects weights to be integer values`);\n      }\n      if (currentWeight < 0) {\n        throw new Error(`${label} expects weights to be superior or equal to 0`);\n      }\n    }\n    if (totalWeight <= 0) {\n      throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);\n    }\n    const sanitizedConstraints = {\n      depthBias: (0, MaxLengthFromMinLength_1.depthBiasFromSizeForArbitrary)(constraints.depthSize, constraints.maxDepth !== undefined),\n      maxDepth: constraints.maxDepth != undefined ? constraints.maxDepth : Number.POSITIVE_INFINITY,\n      withCrossShrink: !!constraints.withCrossShrink\n    };\n    return new FrequencyArbitrary(warbs, sanitizedConstraints, (0, DepthContext_1.getDepthContextFor)(constraints.depthIdentifier));\n  }\n  generate(mrng, biasFactor) {\n    if (this.mustGenerateFirst()) {\n      return this.safeGenerateForIndex(mrng, 0, biasFactor);\n    }\n    const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);\n    for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) {\n      if (selected < this.cumulatedWeights[idx]) {\n        return this.safeGenerateForIndex(mrng, idx, biasFactor);\n      }\n    }\n    throw new Error(`Unable to generate from fc.frequency`);\n  }\n  canShrinkWithoutContext(value) {\n    return this.canShrinkWithoutContextIndex(value) !== -1;\n  }\n  shrink(value, context) {\n    if (context !== undefined) {\n      const safeContext = context;\n      const selectedIndex = safeContext.selectedIndex;\n      const originalBias = safeContext.originalBias;\n      const originalArbitrary = this.warbs[selectedIndex].arbitrary;\n      const originalShrinks = originalArbitrary.shrink(value, safeContext.originalContext).map(v => this.mapIntoValue(selectedIndex, v, null, originalBias));\n      if (safeContext.clonedMrngForFallbackFirst !== null) {\n        if (safeContext.cachedGeneratedForFirst === undefined) {\n          safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);\n        }\n        const valueFromFirst = safeContext.cachedGeneratedForFirst;\n        return Stream_1.Stream.of(valueFromFirst).join(originalShrinks);\n      }\n      return originalShrinks;\n    }\n    const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);\n    if (potentialSelectedIndex === -1) {\n      return Stream_1.Stream.nil();\n    }\n    return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary.shrink(value, undefined).map(v => this.mapIntoValue(potentialSelectedIndex, v, null, undefined)));\n  }\n  defaultShrinkForFirst(selectedIndex) {\n    ++this.context.depth;\n    try {\n      if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === undefined) {\n        return Stream_1.Stream.nil();\n      }\n    } finally {\n      --this.context.depth;\n    }\n    const rawShrinkValue = new Value_1.Value(this.warbs[0].fallbackValue.default, undefined);\n    return Stream_1.Stream.of(this.mapIntoValue(0, rawShrinkValue, null, undefined));\n  }\n  canShrinkWithoutContextIndex(value) {\n    if (this.mustGenerateFirst()) {\n      return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;\n    }\n    try {\n      ++this.context.depth;\n      for (let idx = 0; idx !== this.warbs.length; ++idx) {\n        const warb = this.warbs[idx];\n        if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) {\n          return idx;\n        }\n      }\n      return -1;\n    } finally {\n      --this.context.depth;\n    }\n  }\n  mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {\n    const context = {\n      selectedIndex: idx,\n      originalBias: biasFactor,\n      originalContext: value.context,\n      clonedMrngForFallbackFirst\n    };\n    return new Value_1.Value(value.value, context);\n  }\n  safeGenerateForIndex(mrng, idx, biasFactor) {\n    ++this.context.depth;\n    try {\n      const value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);\n      const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;\n      return this.mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor);\n    } finally {\n      --this.context.depth;\n    }\n  }\n  mustGenerateFirst() {\n    return this.constraints.maxDepth <= this.context.depth;\n  }\n  mustFallbackToFirstInShrink(idx) {\n    return idx !== 0 && this.constraints.withCrossShrink && this.warbs[0].weight !== 0;\n  }\n  computeNegDepthBenefit() {\n    const depthBias = this.constraints.depthBias;\n    if (depthBias <= 0 || this.warbs[0].weight === 0) {\n      return 0;\n    }\n    const depthBenefit = Math.floor(Math.pow(1 + depthBias, this.context.depth)) - 1;\n    return -Math.min(this.totalWeight * depthBenefit, Number.MAX_SAFE_INTEGER) || 0;\n  }\n}\nexports.FrequencyArbitrary = FrequencyArbitrary;","map":{"version":3,"names":["Object","defineProperty","exports","value","FrequencyArbitrary","Stream_1","require","Arbitrary_1","Value_1","DepthContext_1","MaxLengthFromMinLength_1","Arbitrary","constructor","warbs","constraints","context","currentWeight","cumulatedWeights","idx","length","weight","push","totalWeight","from","label","Error","currentArbitrary","arbitrary","undefined","Number","isInteger","sanitizedConstraints","depthBias","depthBiasFromSizeForArbitrary","depthSize","maxDepth","POSITIVE_INFINITY","withCrossShrink","getDepthContextFor","depthIdentifier","generate","mrng","biasFactor","mustGenerateFirst","safeGenerateForIndex","selected","nextInt","computeNegDepthBenefit","canShrinkWithoutContext","canShrinkWithoutContextIndex","shrink","safeContext","selectedIndex","originalBias","originalArbitrary","originalShrinks","originalContext","map","v","mapIntoValue","clonedMrngForFallbackFirst","cachedGeneratedForFirst","valueFromFirst","Stream","of","join","potentialSelectedIndex","nil","defaultShrinkForFirst","depth","mustFallbackToFirstInShrink","fallbackValue","rawShrinkValue","Value","default","warb","clone","depthBenefit","Math","floor","pow","min","MAX_SAFE_INTEGER"],"sources":["/Users/karimelbarbary/Desktop/test4/devote/node_modules/fast-check/lib/arbitrary/_internals/FrequencyArbitrary.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FrequencyArbitrary = void 0;\nconst Stream_1 = require(\"../../stream/Stream\");\nconst Arbitrary_1 = require(\"../../check/arbitrary/definition/Arbitrary\");\nconst Value_1 = require(\"../../check/arbitrary/definition/Value\");\nconst DepthContext_1 = require(\"./helpers/DepthContext\");\nconst MaxLengthFromMinLength_1 = require(\"./helpers/MaxLengthFromMinLength\");\nclass FrequencyArbitrary extends Arbitrary_1.Arbitrary {\n    constructor(warbs, constraints, context) {\n        super();\n        this.warbs = warbs;\n        this.constraints = constraints;\n        this.context = context;\n        let currentWeight = 0;\n        this.cumulatedWeights = [];\n        for (let idx = 0; idx !== warbs.length; ++idx) {\n            currentWeight += warbs[idx].weight;\n            this.cumulatedWeights.push(currentWeight);\n        }\n        this.totalWeight = currentWeight;\n    }\n    static from(warbs, constraints, label) {\n        if (warbs.length === 0) {\n            throw new Error(`${label} expects at least one weighted arbitrary`);\n        }\n        let totalWeight = 0;\n        for (let idx = 0; idx !== warbs.length; ++idx) {\n            const currentArbitrary = warbs[idx].arbitrary;\n            if (currentArbitrary === undefined) {\n                throw new Error(`${label} expects arbitraries to be specified`);\n            }\n            const currentWeight = warbs[idx].weight;\n            totalWeight += currentWeight;\n            if (!Number.isInteger(currentWeight)) {\n                throw new Error(`${label} expects weights to be integer values`);\n            }\n            if (currentWeight < 0) {\n                throw new Error(`${label} expects weights to be superior or equal to 0`);\n            }\n        }\n        if (totalWeight <= 0) {\n            throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);\n        }\n        const sanitizedConstraints = {\n            depthBias: (0, MaxLengthFromMinLength_1.depthBiasFromSizeForArbitrary)(constraints.depthSize, constraints.maxDepth !== undefined),\n            maxDepth: constraints.maxDepth != undefined ? constraints.maxDepth : Number.POSITIVE_INFINITY,\n            withCrossShrink: !!constraints.withCrossShrink,\n        };\n        return new FrequencyArbitrary(warbs, sanitizedConstraints, (0, DepthContext_1.getDepthContextFor)(constraints.depthIdentifier));\n    }\n    generate(mrng, biasFactor) {\n        if (this.mustGenerateFirst()) {\n            return this.safeGenerateForIndex(mrng, 0, biasFactor);\n        }\n        const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);\n        for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) {\n            if (selected < this.cumulatedWeights[idx]) {\n                return this.safeGenerateForIndex(mrng, idx, biasFactor);\n            }\n        }\n        throw new Error(`Unable to generate from fc.frequency`);\n    }\n    canShrinkWithoutContext(value) {\n        return this.canShrinkWithoutContextIndex(value) !== -1;\n    }\n    shrink(value, context) {\n        if (context !== undefined) {\n            const safeContext = context;\n            const selectedIndex = safeContext.selectedIndex;\n            const originalBias = safeContext.originalBias;\n            const originalArbitrary = this.warbs[selectedIndex].arbitrary;\n            const originalShrinks = originalArbitrary\n                .shrink(value, safeContext.originalContext)\n                .map((v) => this.mapIntoValue(selectedIndex, v, null, originalBias));\n            if (safeContext.clonedMrngForFallbackFirst !== null) {\n                if (safeContext.cachedGeneratedForFirst === undefined) {\n                    safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);\n                }\n                const valueFromFirst = safeContext.cachedGeneratedForFirst;\n                return Stream_1.Stream.of(valueFromFirst).join(originalShrinks);\n            }\n            return originalShrinks;\n        }\n        const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);\n        if (potentialSelectedIndex === -1) {\n            return Stream_1.Stream.nil();\n        }\n        return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary\n            .shrink(value, undefined)\n            .map((v) => this.mapIntoValue(potentialSelectedIndex, v, null, undefined)));\n    }\n    defaultShrinkForFirst(selectedIndex) {\n        ++this.context.depth;\n        try {\n            if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === undefined) {\n                return Stream_1.Stream.nil();\n            }\n        }\n        finally {\n            --this.context.depth;\n        }\n        const rawShrinkValue = new Value_1.Value(this.warbs[0].fallbackValue.default, undefined);\n        return Stream_1.Stream.of(this.mapIntoValue(0, rawShrinkValue, null, undefined));\n    }\n    canShrinkWithoutContextIndex(value) {\n        if (this.mustGenerateFirst()) {\n            return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;\n        }\n        try {\n            ++this.context.depth;\n            for (let idx = 0; idx !== this.warbs.length; ++idx) {\n                const warb = this.warbs[idx];\n                if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) {\n                    return idx;\n                }\n            }\n            return -1;\n        }\n        finally {\n            --this.context.depth;\n        }\n    }\n    mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {\n        const context = {\n            selectedIndex: idx,\n            originalBias: biasFactor,\n            originalContext: value.context,\n            clonedMrngForFallbackFirst,\n        };\n        return new Value_1.Value(value.value, context);\n    }\n    safeGenerateForIndex(mrng, idx, biasFactor) {\n        ++this.context.depth;\n        try {\n            const value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);\n            const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;\n            return this.mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor);\n        }\n        finally {\n            --this.context.depth;\n        }\n    }\n    mustGenerateFirst() {\n        return this.constraints.maxDepth <= this.context.depth;\n    }\n    mustFallbackToFirstInShrink(idx) {\n        return idx !== 0 && this.constraints.withCrossShrink && this.warbs[0].weight !== 0;\n    }\n    computeNegDepthBenefit() {\n        const depthBias = this.constraints.depthBias;\n        if (depthBias <= 0 || this.warbs[0].weight === 0) {\n            return 0;\n        }\n        const depthBenefit = Math.floor(Math.pow(1 + depthBias, this.context.depth)) - 1;\n        return -Math.min(this.totalWeight * depthBenefit, Number.MAX_SAFE_INTEGER) || 0;\n    }\n}\nexports.FrequencyArbitrary = FrequencyArbitrary;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}