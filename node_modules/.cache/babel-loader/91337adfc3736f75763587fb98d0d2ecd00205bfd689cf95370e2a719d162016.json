{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abifyReturndataDecoding = exports.abifyLogDecoding = exports.abifyCalldataDecoding = exports.abifyResult = exports.abifyType = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:abify\");\nconst Format = __importStar(require(\"./format\"));\nconst Common = __importStar(require(\"./common\"));\nconst Conversion = __importStar(require(\"./conversion\"));\n/** @category ABIfication */\nfunction abifyType(dataType, userDefinedTypes) {\n  switch (dataType.typeClass) {\n    //we only need to specially handle types that don't go in\n    //the ABI, or that have some information loss when going\n    //in the ABI\n    //note that we do need to handle arrays, due to recursion!\n    //First: types that do not go in the ABI\n    case \"mapping\":\n    case \"magic\":\n    case \"type\":\n    case \"options\":\n      return undefined;\n    //Next: address & contract, these can get handled together\n    case \"address\":\n    case \"contract\":\n      return {\n        typeClass: \"address\",\n        kind: \"general\",\n        typeHint: Format.Types.typeString(dataType)\n      };\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          return {\n            typeClass: \"function\",\n            visibility: \"external\",\n            kind: \"general\",\n            typeHint: Format.Types.typeString(dataType)\n          };\n        case \"internal\":\n          //these don't go in the ABI\n          return undefined;\n      }\n      break;\n    //to satisfy TypeScript\n    //the complex cases: struct & enum\n    case \"struct\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n        if (!fullType.memberTypes) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n        const memberTypes = fullType.memberTypes.map(_ref => {\n          let {\n            name,\n            type: memberType\n          } = _ref;\n          return {\n            name,\n            type: abifyType(memberType, userDefinedTypes)\n          };\n        });\n        return {\n          typeClass: \"tuple\",\n          typeHint: Format.Types.typeString(fullType),\n          memberTypes\n        };\n      }\n    case \"enum\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n        if (!fullType.options) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n        let numOptions = fullType.options.length;\n        let bits = 8 * Math.ceil(Math.log2(numOptions) / 8);\n        return {\n          typeClass: \"uint\",\n          bits,\n          typeHint: Format.Types.typeString(fullType)\n        };\n      }\n    case \"userDefinedValueType\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n        if (!fullType.underlyingType) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n        const abifiedUnderlying = abifyType(fullType.underlyingType, userDefinedTypes);\n        return Object.assign(Object.assign({}, abifiedUnderlying), {\n          typeHint: Format.Types.typeStringWithoutLocation(dataType)\n        });\n      }\n    //finally: arrays\n    case \"array\":\n      return Object.assign(Object.assign({}, dataType), {\n        typeHint: Format.Types.typeString(dataType),\n        baseType: abifyType(dataType.baseType, userDefinedTypes)\n      });\n    //default case: just leave as-is\n    default:\n      return dataType;\n  }\n}\nexports.abifyType = abifyType;\n/** @category ABIfication */\nfunction abifyResult(result, userDefinedTypes) {\n  switch (result.type.typeClass) {\n    case \"mapping\": //doesn't go in ABI\n    case \"magic\": //doesn't go in ABI\n    case \"type\":\n      //doesn't go in ABI\n      return undefined;\n    case \"address\":\n      //abify the type but leave the value alone\n      return Object.assign(Object.assign({}, result), {\n        type: abifyType(result.type, userDefinedTypes)\n      });\n    case \"contract\":\n      {\n        let coercedResult = result;\n        switch (coercedResult.kind) {\n          case \"value\":\n            return {\n              type: abifyType(result.type, userDefinedTypes),\n              kind: \"value\",\n              value: {\n                asAddress: coercedResult.value.address,\n                rawAsHex: coercedResult.value.rawAddress\n              }\n            };\n          case \"error\":\n            switch (coercedResult.error.kind) {\n              case \"ContractPaddingError\":\n                return {\n                  type: abifyType(result.type, userDefinedTypes),\n                  kind: \"error\",\n                  error: {\n                    kind: \"AddressPaddingError\",\n                    paddingType: coercedResult.error.paddingType,\n                    raw: coercedResult.error.raw\n                  }\n                };\n              default:\n                //other contract errors are generic errors!\n                //but TS doesn't know this so we coerce\n                return Object.assign(Object.assign({}, coercedResult), {\n                  type: abifyType(result.type, userDefinedTypes)\n                });\n            }\n        }\n        break; //to satisfy typescript\n      }\n\n    case \"function\":\n      switch (result.type.visibility) {\n        case \"external\":\n          {\n            let coercedResult = result;\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n          }\n        case \"internal\":\n          //these don't go in the ABI\n          return undefined;\n      }\n      break;\n    //to satisfy TypeScript\n    case \"struct\":\n      {\n        let coercedResult = result;\n        switch (coercedResult.kind) {\n          case \"value\":\n            if (coercedResult.reference !== undefined) {\n              return undefined; //no circular values in the ABI!\n            }\n\n            let abifiedMembers = coercedResult.value.map(_ref2 => {\n              let {\n                name,\n                value: member\n              } = _ref2;\n              return {\n                name,\n                value: abifyResult(member, userDefinedTypes)\n              };\n            });\n            return {\n              kind: \"value\",\n              type: abifyType(result.type, userDefinedTypes),\n              value: abifiedMembers\n            };\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes) //note: may throw exception\n            });\n        }\n      }\n\n    case \"userDefinedValueType\":\n      {\n        const coercedResult = result;\n        switch (coercedResult.kind) {\n          case \"value\":\n            return abifyResult(coercedResult.value, userDefinedTypes);\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n        }\n        break; //to satisfy TS :P\n      }\n\n    case \"enum\":\n      {\n        //NOTE: this is the one case where errors are converted to non-error values!!\n        //(other than recursively, I mean)\n        //be aware!\n        let coercedResult = result;\n        let uintType = abifyType(result.type, userDefinedTypes); //may throw exception\n        switch (coercedResult.kind) {\n          case \"value\":\n            return {\n              type: uintType,\n              kind: \"value\",\n              value: {\n                asBN: coercedResult.value.numericAsBN.clone()\n              }\n            };\n          case \"error\":\n            switch (coercedResult.error.kind) {\n              case \"EnumOutOfRangeError\":\n                return {\n                  type: uintType,\n                  kind: \"value\",\n                  value: {\n                    asBN: coercedResult.error.rawAsBN.clone()\n                  }\n                };\n              case \"EnumPaddingError\":\n                return {\n                  type: uintType,\n                  kind: \"error\",\n                  error: {\n                    kind: \"UintPaddingError\",\n                    paddingType: coercedResult.error.paddingType,\n                    raw: coercedResult.error.raw\n                  }\n                };\n              case \"EnumNotFoundDecodingError\":\n                let numericValue = coercedResult.error.rawAsBN.clone();\n                if (numericValue.bitLength() <= uintType.bits) {\n                  return {\n                    type: uintType,\n                    kind: \"value\",\n                    value: {\n                      asBN: numericValue\n                    }\n                  };\n                } else {\n                  return {\n                    type: uintType,\n                    kind: \"error\",\n                    error: {\n                      kind: \"UintPaddingError\",\n                      paddingType: \"left\",\n                      raw: Conversion.toHexString(numericValue)\n                    }\n                  };\n                }\n              default:\n                return {\n                  type: uintType,\n                  kind: \"error\",\n                  error: coercedResult.error\n                };\n            }\n        }\n      }\n    case \"array\":\n      {\n        let coercedResult = result;\n        switch (coercedResult.kind) {\n          case \"value\":\n            if (coercedResult.reference !== undefined) {\n              return undefined; //no circular values in the ABI!\n            }\n\n            let abifiedMembers = coercedResult.value.map(member => abifyResult(member, userDefinedTypes));\n            return {\n              kind: \"value\",\n              type: abifyType(result.type, userDefinedTypes),\n              value: abifiedMembers\n            };\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n        }\n      }\n    default:\n      return result;\n    //just coerce :-/\n  }\n}\n\nexports.abifyResult = abifyResult;\n/** @category ABIfication */\nfunction abifyCalldataDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n  switch (decoding.kind) {\n    case \"function\":\n    case \"constructor\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n          value: abifyResult(argument.value, userDefinedTypes)\n        }))\n      });\n    default:\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\"\n      });\n  }\n}\nexports.abifyCalldataDecoding = abifyCalldataDecoding;\n/** @category ABIfication */\nfunction abifyLogDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n  return Object.assign(Object.assign({}, decoding), {\n    decodingMode: \"abi\",\n    arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n      value: abifyResult(argument.value, userDefinedTypes)\n    }))\n  });\n}\nexports.abifyLogDecoding = abifyLogDecoding;\n/** @category ABIfication */\nfunction abifyReturndataDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n  switch (decoding.kind) {\n    case \"return\":\n    case \"revert\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n          value: abifyResult(argument.value, userDefinedTypes)\n        }))\n      });\n    case \"bytecode\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        immutables: undefined\n      });\n    default:\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\"\n      });\n  }\n}\nexports.abifyReturndataDecoding = abifyReturndataDecoding;","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","Format","__importStar","Common","Conversion","abifyType","dataType","userDefinedTypes","typeClass","undefined","kind","typeHint","Types","typeString","visibility","fullType","memberTypes","typeToDisplay","UnknownUserDefinedTypeError","id","map","_ref","name","type","memberType","options","numOptions","length","bits","Math","ceil","log2","underlyingType","abifiedUnderlying","Object","assign","typeStringWithoutLocation","baseType","exports","abifyResult","result","coercedResult","value","asAddress","address","rawAsHex","rawAddress","error","paddingType","raw","reference","abifiedMembers","_ref2","member","uintType","asBN","numericAsBN","clone","rawAsBN","numericValue","bitLength","toHexString","abifyCalldataDecoding","decoding","decodingMode","arguments","argument","abifyLogDecoding","abifyReturndataDecoding","immutables"],"sources":["../../lib/abify.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAAA,OAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,MAAMC,KAAK,GAAG,IAAAH,OAAA,CAAAI,OAAW,EAAC,aAAa,CAAC;AAExC,MAAAC,MAAA,GAAAC,YAAA,CAAAJ,OAAA;AACA,MAAAK,MAAA,GAAAD,YAAA,CAAAJ,OAAA;AAMA,MAAAM,UAAA,GAAAF,YAAA,CAAAJ,OAAA;AAEA;AACA,SAAgBO,SAASA,CACvBC,QAA2B,EAC3BC,gBAAyC;EAEzC,QAAQD,QAAQ,CAACE,SAAS;IACxB;IACA;IACA;IACA;IACA;IACA,KAAK,SAAS;IACd,KAAK,OAAO;IACZ,KAAK,MAAM;IACX,KAAK,SAAS;MACZ,OAAOC,SAAS;IAClB;IACA,KAAK,SAAS;IACd,KAAK,UAAU;MACb,OAAO;QACLD,SAAS,EAAE,SAAS;QACpBE,IAAI,EAAE,SAAS;QACfC,QAAQ,EAAEV,MAAM,CAACW,KAAK,CAACC,UAAU,CAACP,QAAQ;OAC3C;IACH,KAAK,UAAU;MACb,QAAQA,QAAQ,CAACQ,UAAU;QACzB,KAAK,UAAU;UACb,OAAO;YACLN,SAAS,EAAE,UAAU;YACrBM,UAAU,EAAE,UAAU;YACtBJ,IAAI,EAAE,SAAS;YACfC,QAAQ,EAAEV,MAAM,CAACW,KAAK,CAACC,UAAU,CAACP,QAAQ;WAC3C;QACH,KAAK,UAAU;UAAE;UACf,OAAOG,SAAS;;MAEpB;IAAO;IACT;IACA,KAAK,QAAQ;MAAE;QACb,MAAMM,QAAQ,GACZd,MAAM,CAACW,KAAK,CAACG,QAAQ,CAACT,QAAQ,EAAEC,gBAAgB,CACjD;QACD,IAAI,CAACQ,QAAQ,CAACC,WAAW,EAAE;UACzB,IAAIC,aAAa,GAAGhB,MAAM,CAACW,KAAK,CAACC,UAAU,CAACP,QAAQ,CAAC;UACrD,MAAM,IAAIH,MAAM,CAACe,2BAA2B,CAC1CZ,QAAQ,CAACa,EAAE,EACXF,aAAa,CACd;;QAEH,MAAMD,WAAW,GAAGD,QAAQ,CAACC,WAAW,CAACI,GAAG,CAC1CC,IAAA;UAAA,IAAC;YAAEC,IAAI;YAAEC,IAAI,EAAEC;UAAU,CAAE,GAAAH,IAAA;UAAA,OAAM;YAC/BC,IAAI;YACJC,IAAI,EAAElB,SAAS,CAACmB,UAAU,EAAEjB,gBAAgB;WAC7C;QAAA,CAAC,CACH;QACD,OAAO;UACLC,SAAS,EAAE,OAAO;UAClBG,QAAQ,EAAEV,MAAM,CAACW,KAAK,CAACC,UAAU,CAACE,QAAQ,CAAC;UAC3CC;SACD;;IAEH,KAAK,MAAM;MAAE;QACX,MAAMD,QAAQ,GACZd,MAAM,CAACW,KAAK,CAACG,QAAQ,CAACT,QAAQ,EAAEC,gBAAgB,CACjD;QACD,IAAI,CAACQ,QAAQ,CAACU,OAAO,EAAE;UACrB,IAAIR,aAAa,GAAGhB,MAAM,CAACW,KAAK,CAACC,UAAU,CAACP,QAAQ,CAAC;UACrD,MAAM,IAAIH,MAAM,CAACe,2BAA2B,CAC1CZ,QAAQ,CAACa,EAAE,EACXF,aAAa,CACd;;QAEH,IAAIS,UAAU,GAAGX,QAAQ,CAACU,OAAO,CAACE,MAAM;QACxC,IAAIC,IAAI,GAAG,CAAC,GAAGC,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,IAAI,CAACL,UAAU,CAAC,GAAG,CAAC,CAAC;QACnD,OAAO;UACLlB,SAAS,EAAE,MAAM;UACjBoB,IAAI;UACJjB,QAAQ,EAAEV,MAAM,CAACW,KAAK,CAACC,UAAU,CAACE,QAAQ;SAC3C;;IAEH,KAAK,sBAAsB;MAAE;QAC3B,MAAMA,QAAQ,GACZd,MAAM,CAACW,KAAK,CAACG,QAAQ,CAACT,QAAQ,EAAEC,gBAAgB,CACjD;QACD,IAAI,CAACQ,QAAQ,CAACiB,cAAc,EAAE;UAC5B,IAAIf,aAAa,GAAGhB,MAAM,CAACW,KAAK,CAACC,UAAU,CAACP,QAAQ,CAAC;UACrD,MAAM,IAAIH,MAAM,CAACe,2BAA2B,CAC1CZ,QAAQ,CAACa,EAAE,EACXF,aAAa,CACd;;QAEH,MAAMgB,iBAAiB,GAAG5B,SAAS,CACjCU,QAAQ,CAACiB,cAAc,EACvBzB,gBAAgB,CACjB;QACD,OAAA2B,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKF,iBAAiB;UACpBtB,QAAQ,EAAEV,MAAM,CAACW,KAAK,CAACwB,yBAAyB,CAAC9B,QAAQ;QAAC;;IAG9D;IACA,KAAK,OAAO;MACV,OAAA4B,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK7B,QAAQ;QACXK,QAAQ,EAAEV,MAAM,CAACW,KAAK,CAACC,UAAU,CAACP,QAAQ,CAAC;QAC3C+B,QAAQ,EAAEhC,SAAS,CAACC,QAAQ,CAAC+B,QAAQ,EAAE9B,gBAAgB;MAAC;IAE5D;IACA;MACE,OAAOD,QAAQ;;AAErB;AA9GAgC,OAAA,CAAAjC,SAAA,GAAAA,SAAA;AAgHA;AACA,SAAgBkC,WAAWA,CACzBC,MAA4B,EAC5BjC,gBAAyC;EAEzC,QAAQiC,MAAM,CAACjB,IAAI,CAACf,SAAS;IAC3B,KAAK,SAAS,CAAC,CAAC;IAChB,KAAK,OAAO,CAAC,CAAC;IACd,KAAK,MAAM;MAAE;MACX,OAAOC,SAAS;IAClB,KAAK,SAAS;MACZ;MACA,OAAAyB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACmCK,MAAO;QACxCjB,IAAI,EAA4BlB,SAAS,CAACmC,MAAM,CAACjB,IAAI,EAAEhB,gBAAgB;MAAC;IAE5E,KAAK,UAAU;MAAE;QACf,IAAIkC,aAAa,GAAiCD,MAAM;QACxD,QAAQC,aAAa,CAAC/B,IAAI;UACxB,KAAK,OAAO;YACV,OAAO;cACLa,IAAI,EACFlB,SAAS,CAACmC,MAAM,CAACjB,IAAI,EAAEhB,gBAAgB,CACxC;cACDG,IAAI,EAAE,OAAO;cACbgC,KAAK,EAAE;gBACLC,SAAS,EAAEF,aAAa,CAACC,KAAK,CAACE,OAAO;gBACtCC,QAAQ,EAAEJ,aAAa,CAACC,KAAK,CAACI;;aAEjC;UACH,KAAK,OAAO;YACV,QAAQL,aAAa,CAACM,KAAK,CAACrC,IAAI;cAC9B,KAAK,sBAAsB;gBACzB,OAAO;kBACLa,IAAI,EACFlB,SAAS,CAACmC,MAAM,CAACjB,IAAI,EAAEhB,gBAAgB,CACxC;kBACDG,IAAI,EAAE,OAAO;kBACbqC,KAAK,EAAE;oBACLrC,IAAI,EAAE,qBAAqB;oBAC3BsC,WAAW,EAAEP,aAAa,CAACM,KAAK,CAACC,WAAW;oBAC5CC,GAAG,EAAER,aAAa,CAACM,KAAK,CAACE;;iBAE5B;cACH;gBACE;gBACA;gBACA,OAAOf,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACFM,aAAa;kBAChBlB,IAAI,EACFlB,SAAS,CAACmC,MAAM,CAACjB,IAAI,EAAEhB,gBAAgB;gBACxC,EACF;;;QAGT,MAAM,CAAC;;;IAET,KAAK,UAAU;MACb,QAAQiC,MAAM,CAACjB,IAAI,CAACT,UAAU;QAC5B,KAAK,UAAU;UAAE;YACf,IAAI2B,aAAa,GAAyCD,MAAM;YAChE,OAAAN,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKM,aAAa;cAChBlB,IAAI,EACFlB,SAAS,CAACmC,MAAM,CAACjB,IAAI,EAAEhB,gBAAgB;YACxC;;QAGL,KAAK,UAAU;UAAE;UACf,OAAOE,SAAS;;MAEpB;IAAO;IACT,KAAK,QAAQ;MAAE;QACb,IAAIgC,aAAa,GAA+BD,MAAM;QACtD,QAAQC,aAAa,CAAC/B,IAAI;UACxB,KAAK,OAAO;YACV,IAAI+B,aAAa,CAACS,SAAS,KAAKzC,SAAS,EAAE;cACzC,OAAOA,SAAS,CAAC,CAAC;;;YAEpB,IAAI0C,cAAc,GAAGV,aAAa,CAACC,KAAK,CAACtB,GAAG,CAC1CgC,KAAA;cAAA,IAAC;gBAAE9B,IAAI;gBAAEoB,KAAK,EAAEW;cAAM,CAAE,GAAAD,KAAA;cAAA,OAAM;gBAC5B9B,IAAI;gBACJoB,KAAK,EAAEH,WAAW,CAACc,MAAM,EAAE9C,gBAAgB;eAC5C;YAAA,CAAC,CACH;YACD,OAAO;cACLG,IAAI,EAAE,OAAO;cACba,IAAI,EACFlB,SAAS,CAACmC,MAAM,CAACjB,IAAI,EAAEhB,gBAAgB,CACxC;cACDmC,KAAK,EAAES;aACR;UACH,KAAK,OAAO;YACV,OAAAjB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKM,aAAa;cAChBlB,IAAI,EACFlB,SAAS,CAACmC,MAAM,CAACjB,IAAI,EAAEhB,gBAAgB,CACxC,CAAC;;;;;IAIV,KAAK,sBAAsB;MAAE;QAC3B,MAAMkC,aAAa,GAA6CD,MAAM;QACtE,QAAQC,aAAa,CAAC/B,IAAI;UACxB,KAAK,OAAO;YACV,OAAO6B,WAAW,CAACE,aAAa,CAACC,KAAK,EAAEnC,gBAAgB,CAAC;UAC3D,KAAK,OAAO;YACV,OAAO2B,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACFM,aAAa;cAChBlB,IAAI,EAAElB,SAAS,CAACmC,MAAM,CAACjB,IAAI,EAAEhB,gBAAgB;YAAC,EAC/C;;QAEL,MAAM,CAAC;;;IAET,KAAK,MAAM;MAAE;QACX;QACA;QACA;QACA,IAAIkC,aAAa,GAA6BD,MAAM;QACpD,IAAIc,QAAQ,GACVjD,SAAS,CAACmC,MAAM,CAACjB,IAAI,EAAEhB,gBAAgB,CACxC,CAAC,CAAC;QACH,QAAQkC,aAAa,CAAC/B,IAAI;UACxB,KAAK,OAAO;YACV,OAAO;cACLa,IAAI,EAAE+B,QAAQ;cACd5C,IAAI,EAAE,OAAO;cACbgC,KAAK,EAAE;gBACLa,IAAI,EAAEd,aAAa,CAACC,KAAK,CAACc,WAAW,CAACC,KAAK;;aAE9C;UACH,KAAK,OAAO;YACV,QAAQhB,aAAa,CAACM,KAAK,CAACrC,IAAI;cAC9B,KAAK,qBAAqB;gBACxB,OAAO;kBACLa,IAAI,EAAE+B,QAAQ;kBACd5C,IAAI,EAAE,OAAO;kBACbgC,KAAK,EAAE;oBACLa,IAAI,EAAEd,aAAa,CAACM,KAAK,CAACW,OAAO,CAACD,KAAK;;iBAE1C;cACH,KAAK,kBAAkB;gBACrB,OAAO;kBACLlC,IAAI,EAAE+B,QAAQ;kBACd5C,IAAI,EAAE,OAAO;kBACbqC,KAAK,EAAE;oBACLrC,IAAI,EAAE,kBAAkB;oBACxBsC,WAAW,EAAEP,aAAa,CAACM,KAAK,CAACC,WAAW;oBAC5CC,GAAG,EAAER,aAAa,CAACM,KAAK,CAACE;;iBAE5B;cACH,KAAK,2BAA2B;gBAC9B,IAAIU,YAAY,GAAGlB,aAAa,CAACM,KAAK,CAACW,OAAO,CAACD,KAAK,EAAE;gBACtD,IAAIE,YAAY,CAACC,SAAS,EAAE,IAAIN,QAAQ,CAAC1B,IAAI,EAAE;kBAC7C,OAAO;oBACLL,IAAI,EAAE+B,QAAQ;oBACd5C,IAAI,EAAE,OAAO;oBACbgC,KAAK,EAAE;sBACLa,IAAI,EAAEI;;mBAET;iBACF,MAAM;kBACL,OAAO;oBACLpC,IAAI,EAAE+B,QAAQ;oBACd5C,IAAI,EAAE,OAAO;oBACbqC,KAAK,EAAE;sBACLrC,IAAI,EAAE,kBAAkB;sBACxBsC,WAAW,EAAE,MAAM;sBACnBC,GAAG,EAAE7C,UAAU,CAACyD,WAAW,CAACF,YAAY;;mBAE3C;;cAEL;gBACE,OAAO;kBACLpC,IAAI,EAAE+B,QAAQ;kBACd5C,IAAI,EAAE,OAAO;kBACbqC,KAAK,EAAEN,aAAa,CAACM;iBACtB;;;;IAIX,KAAK,OAAO;MAAE;QACZ,IAAIN,aAAa,GAA8BD,MAAM;QACrD,QAAQC,aAAa,CAAC/B,IAAI;UACxB,KAAK,OAAO;YACV,IAAI+B,aAAa,CAACS,SAAS,KAAKzC,SAAS,EAAE;cACzC,OAAOA,SAAS,CAAC,CAAC;;;YAEpB,IAAI0C,cAAc,GAAGV,aAAa,CAACC,KAAK,CAACtB,GAAG,CAACiC,MAAM,IACjDd,WAAW,CAACc,MAAM,EAAE9C,gBAAgB,CAAC,CACtC;YACD,OAAO;cACLG,IAAI,EAAE,OAAO;cACba,IAAI,EACFlB,SAAS,CAACmC,MAAM,CAACjB,IAAI,EAAEhB,gBAAgB,CACxC;cACDmC,KAAK,EAAES;aACR;UACH,KAAK,OAAO;YACV,OAAAjB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKM,aAAa;cAChBlB,IAAI,EACFlB,SAAS,CAACmC,MAAM,CAACjB,IAAI,EAAEhB,gBAAgB;YACxC;;;IAIT;MACE,OAAgCiC,MAAM;IAAE;;AAE9C;;AAjNAF,OAAA,CAAAC,WAAA,GAAAA,WAAA;AAmNA;AACA,SAAgBuB,qBAAqBA,CACnCC,QAA0B,EAC1BxD,gBAAwC;EAExC,IAAIwD,QAAQ,CAACC,YAAY,KAAK,KAAK,EAAE;IACnC,OAAOD,QAAQ;;EAEjB,QAAQA,QAAQ,CAACrD,IAAI;IACnB,KAAK,UAAU;IACf,KAAK,aAAa;MAChB,OAAAwB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK4B,QAAQ;QACXC,YAAY,EAAE,KAAK;QACnBC,SAAS,EAAEF,QAAQ,CAACE,SAAS,CAAC7C,GAAG,CAAC8C,QAAQ,IAAIhC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACzC+B,QAAQ;UACXxB,KAAK,EAAEH,WAAW,CAAC2B,QAAQ,CAACxB,KAAK,EAAEnC,gBAAgB;QAAC,EACpD;MAAC;IAEP;MACE,OAAA2B,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK4B,QAAQ;QACXC,YAAY,EAAE;MAAK;;AAG3B;AAxBA1B,OAAA,CAAAwB,qBAAA,GAAAA,qBAAA;AA0BA;AACA,SAAgBK,gBAAgBA,CAC9BJ,QAAqB,EACrBxD,gBAAwC;EAExC,IAAIwD,QAAQ,CAACC,YAAY,KAAK,KAAK,EAAE;IACnC,OAAOD,QAAQ;;EAEjB,OAAA7B,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK4B,QAAQ;IACXC,YAAY,EAAE,KAAK;IACnBC,SAAS,EAAEF,QAAQ,CAACE,SAAS,CAAC7C,GAAG,CAAC8C,QAAQ,IAAIhC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACzC+B,QAAQ;MACXxB,KAAK,EAAEH,WAAW,CAAC2B,QAAQ,CAACxB,KAAK,EAAEnC,gBAAgB;IAAC,EACpD;EAAC;AAEP;AAfA+B,OAAA,CAAA6B,gBAAA,GAAAA,gBAAA;AAiBA;AACA,SAAgBC,uBAAuBA,CACrCL,QAA4B,EAC5BxD,gBAAwC;EAExC,IAAIwD,QAAQ,CAACC,YAAY,KAAK,KAAK,EAAE;IACnC,OAAOD,QAAQ;;EAEjB,QAAQA,QAAQ,CAACrD,IAAI;IACnB,KAAK,QAAQ;IACb,KAAK,QAAQ;MACX,OAAAwB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK4B,QAAQ;QACXC,YAAY,EAAE,KAAK;QACnBC,SAAS,EAAEF,QAAQ,CAACE,SAAS,CAAC7C,GAAG,CAAC8C,QAAQ,IAAIhC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACzC+B,QAAQ;UACXxB,KAAK,EAAEH,WAAW,CAAC2B,QAAQ,CAACxB,KAAK,EAAEnC,gBAAgB;QAAC,EACpD;MAAC;IAEP,KAAK,UAAU;MACb,OAAA2B,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK4B,QAAQ;QACXC,YAAY,EAAE,KAAK;QACnBK,UAAU,EAAE5D;MAAS;IAEzB;MACE,OAAAyB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK4B,QAAQ;QACXC,YAAY,EAAE;MAAK;;AAG3B;AA9BA1B,OAAA,CAAA8B,uBAAA,GAAAA,uBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}