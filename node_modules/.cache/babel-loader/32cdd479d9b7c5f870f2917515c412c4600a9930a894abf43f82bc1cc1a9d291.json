{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:decode\");\nconst AstConstant = __importStar(require(\"./ast-constant\"));\nconst AbiData = __importStar(require(\"./abi-data\"));\nconst Compiler = __importStar(require(\"./compiler\"));\nconst Format = __importStar(require(\"./format\"));\nconst Basic = __importStar(require(\"./basic\"));\nconst Memory = __importStar(require(\"./memory\"));\nconst Special = __importStar(require(\"./special\"));\nconst Stack = __importStar(require(\"./stack\"));\nconst Storage = __importStar(require(\"./storage\"));\nconst Topic = __importStar(require(\"./topic\"));\nfunction decode(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    return Format.Utils.Circularity.tie(yield* decodeDispatch(dataType, pointer, info, options));\n  }();\n}\nexports.default = decode;\nfunction decodeDispatch(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    debug(\"type %O\", dataType);\n    debug(\"pointer %O\", pointer);\n    switch (pointer.location) {\n      case \"storage\":\n        return yield* Storage.Decode.decodeStorage(dataType, pointer, info);\n      case \"stack\":\n        return yield* Stack.Decode.decodeStack(dataType, pointer, info);\n      case \"stackliteral\":\n        return yield* Stack.Decode.decodeLiteral(dataType, pointer, info);\n      case \"definition\":\n        return yield* AstConstant.Decode.decodeConstant(dataType, pointer, info);\n      case \"special\":\n        return yield* Special.Decode.decodeSpecial(dataType, pointer, info);\n      case \"calldata\":\n      case \"eventdata\":\n      case \"returndata\":\n        return yield* AbiData.Decode.decodeAbi(dataType, pointer, info, options);\n      case \"eventtopic\":\n        return yield* Topic.Decode.decodeTopic(dataType, pointer, info, options);\n      case \"code\":\n      case \"nowhere\":\n        //currently only basic types can go in code, so we'll dispatch directly to decodeBasic\n        //(if it's a nowhere pointer, this will return an error result, of course)\n        //(also, Solidity <0.8.9 would always zero-pad immutables regardless of type,\n        //so we have to set the padding mode appropriately to allow for this)\n        return yield* Basic.Decode.decodeBasic(dataType, pointer, info, Object.assign(Object.assign({}, options), {\n          paddingMode: \"defaultOrZero\"\n        }));\n      case \"memory\":\n        //this case -- decoding something that resides *directly* in memory,\n        //rather than located via a pointer -- only comes up when decoding immutables\n        //in a constructor.  thus, we turn on the forceRightPadding option on Solidity\n        //versions prior to 0.8.9, because before then all immutables would be right-padded\n        //while in memory\n        switch (Compiler.Utils.solidityFamily(info.currentContext.compiler)) {\n          case \"0.5.x\":\n          case \"0.8.x\":\n          case \"0.8.7+\":\n            return yield* Memory.Decode.decodeMemory(dataType, pointer, info, Object.assign(Object.assign({}, options), {\n              paddingMode: \"right\"\n            }));\n          default:\n            return yield* Memory.Decode.decodeMemory(dataType, pointer, info, options);\n        }\n    }\n  }();\n}","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","AstConstant","__importStar","AbiData","Compiler","Format","Basic","Memory","Special","Stack","Storage","Topic","decode","dataType","pointer","info","options","arguments","length","undefined","Utils","Circularity","tie","decodeDispatch","exports","location","Decode","decodeStorage","decodeStack","decodeLiteral","decodeConstant","decodeSpecial","decodeAbi","decodeTopic","decodeBasic","Object","assign","paddingMode","solidityFamily","currentContext","compiler","decodeMemory"],"sources":["../../lib/decode.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAAA,OAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,MAAMC,KAAK,GAAG,IAAAH,OAAA,CAAAI,OAAW,EAAC,cAAc,CAAC;AAEzC,MAAAC,WAAA,GAAAC,YAAA,CAAAJ,OAAA;AACA,MAAAK,OAAA,GAAAD,YAAA,CAAAJ,OAAA;AACA,MAAAM,QAAA,GAAAF,YAAA,CAAAJ,OAAA;AACA,MAAAO,MAAA,GAAAH,YAAA,CAAAJ,OAAA;AAEA,MAAAQ,KAAA,GAAAJ,YAAA,CAAAJ,OAAA;AAGA,MAAAS,MAAA,GAAAL,YAAA,CAAAJ,OAAA;AACA,MAAAU,OAAA,GAAAN,YAAA,CAAAJ,OAAA;AACA,MAAAW,KAAA,GAAAP,YAAA,CAAAJ,OAAA;AACA,MAAAY,OAAA,GAAAR,YAAA,CAAAJ,OAAA;AACA,MAAAa,KAAA,GAAAT,YAAA,CAAAJ,OAAA;AAEA,SAAyBc,MAAMA,CAC7BC,QAA2B,EAC3BC,OAA4B,EAC5BC,IAAiB;EAAA,IACjBC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA0B,EAAE;EAAA;IAE5B,OAAOZ,MAAM,CAACe,KAAK,CAACC,WAAW,CAACC,GAAG,CACjC,OAAOC,cAAc,CAACV,QAAQ,EAAEC,OAAO,EAAEC,IAAI,EAAEC,OAAO,CAAC,CACxD;EACH,CAAC;AAAA;AATDQ,OAAA,CAAAxB,OAAA,GAAAY,MAAA;AAWA,SAAUW,cAAcA,CACtBV,QAA2B,EAC3BC,OAA4B,EAC5BC,IAAiB;EAAA,IACjBC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA0B,EAAE;EAAA;IAE5BlB,KAAK,CAAC,SAAS,EAAEc,QAAQ,CAAC;IAC1Bd,KAAK,CAAC,YAAY,EAAEe,OAAO,CAAC;IAE5B,QAAQA,OAAO,CAACW,QAAQ;MACtB,KAAK,SAAS;QACZ,OAAO,OAAOf,OAAO,CAACgB,MAAM,CAACC,aAAa,CAACd,QAAQ,EAAEC,OAAO,EAAEC,IAAI,CAAC;MAErE,KAAK,OAAO;QACV,OAAO,OAAON,KAAK,CAACiB,MAAM,CAACE,WAAW,CAACf,QAAQ,EAAEC,OAAO,EAAEC,IAAI,CAAC;MAEjE,KAAK,cAAc;QACjB,OAAO,OAAON,KAAK,CAACiB,MAAM,CAACG,aAAa,CAAChB,QAAQ,EAAEC,OAAO,EAAEC,IAAI,CAAC;MAEnE,KAAK,YAAY;QACf,OAAO,OAAOd,WAAW,CAACyB,MAAM,CAACI,cAAc,CAACjB,QAAQ,EAAEC,OAAO,EAAEC,IAAI,CAAC;MAE1E,KAAK,SAAS;QACZ,OAAO,OAAOP,OAAO,CAACkB,MAAM,CAACK,aAAa,CAAClB,QAAQ,EAAEC,OAAO,EAAEC,IAAI,CAAC;MAErE,KAAK,UAAU;MACf,KAAK,WAAW;MAChB,KAAK,YAAY;QACf,OAAO,OAAOZ,OAAO,CAACuB,MAAM,CAACM,SAAS,CAACnB,QAAQ,EAAEC,OAAO,EAAEC,IAAI,EAAEC,OAAO,CAAC;MAE1E,KAAK,YAAY;QACf,OAAO,OAAOL,KAAK,CAACe,MAAM,CAACO,WAAW,CAACpB,QAAQ,EAAEC,OAAO,EAAEC,IAAI,EAAEC,OAAO,CAAC;MAE1E,KAAK,MAAM;MACX,KAAK,SAAS;QACZ;QACA;QACA;QACA;QACA,OAAO,OAAOV,KAAK,CAACoB,MAAM,CAACQ,WAAW,CAACrB,QAAQ,EAAEC,OAAO,EAAEC,IAAI,EAAAoB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACzDpB,OAAO;UACVqB,WAAW,EAAE;QAAe,GAC5B;MAEJ,KAAK,QAAQ;QACX;QACA;QACA;QACA;QACA;QACA,QAAQjC,QAAQ,CAACgB,KAAK,CAACkB,cAAc,CAACvB,IAAI,CAACwB,cAAc,CAACC,QAAQ,CAAC;UACjE,KAAK,OAAO;UACZ,KAAK,OAAO;UACZ,KAAK,QAAQ;YACX,OAAO,OAAOjC,MAAM,CAACmB,MAAM,CAACe,YAAY,CAAC5B,QAAQ,EAAEC,OAAO,EAAEC,IAAI,EAAAoB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAC3DpB,OAAO;cACVqB,WAAW,EAAE;YAAO,GACpB;UACJ;YACE,OAAO,OAAO9B,MAAM,CAACmB,MAAM,CAACe,YAAY,CACtC5B,QAAQ,EACRC,OAAO,EACPC,IAAI,EACJC,OAAO,CACR;;;EAGX,CAAC;AAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}