{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildValuesAndSeparateKeysToObjectUnmapper = exports.buildValuesAndSeparateKeysToObjectMapper = void 0;\nfunction buildValuesAndSeparateKeysToObjectMapper(keys, noKeyValue) {\n  return function valuesAndSeparateKeysToObjectMapper(gs) {\n    const obj = {};\n    for (let idx = 0; idx !== keys.length; ++idx) {\n      const valueWrapper = gs[idx];\n      if (valueWrapper !== noKeyValue) {\n        Object.defineProperty(obj, keys[idx], {\n          value: valueWrapper,\n          configurable: true,\n          enumerable: true,\n          writable: true\n        });\n      }\n    }\n    return obj;\n  };\n}\nexports.buildValuesAndSeparateKeysToObjectMapper = buildValuesAndSeparateKeysToObjectMapper;\nfunction buildValuesAndSeparateKeysToObjectUnmapper(keys, noKeyValue) {\n  return function valuesAndSeparateKeysToObjectUnmapper(value) {\n    if (typeof value !== 'object' || value === null) {\n      throw new Error('Incompatible instance received: should be a non-null object');\n    }\n    if (!('constructor' in value) || value.constructor !== Object) {\n      throw new Error('Incompatible instance received: should be of exact type Object');\n    }\n    let extractedPropertiesCount = 0;\n    const extractedValues = [];\n    for (let idx = 0; idx !== keys.length; ++idx) {\n      const descriptor = Object.getOwnPropertyDescriptor(value, keys[idx]);\n      if (descriptor !== undefined) {\n        if (!descriptor.configurable || !descriptor.enumerable || !descriptor.writable) {\n          throw new Error('Incompatible instance received: should contain only c/e/w properties');\n        }\n        if (descriptor.get !== undefined || descriptor.set !== undefined) {\n          throw new Error('Incompatible instance received: should contain only no get/set properties');\n        }\n        ++extractedPropertiesCount;\n        extractedValues.push(descriptor.value);\n      } else {\n        extractedValues.push(noKeyValue);\n      }\n    }\n    const namePropertiesCount = Object.getOwnPropertyNames(value).length;\n    const symbolPropertiesCount = Object.getOwnPropertySymbols(value).length;\n    if (extractedPropertiesCount !== namePropertiesCount + symbolPropertiesCount) {\n      throw new Error('Incompatible instance received: should not contain extra properties');\n    }\n    return extractedValues;\n  };\n}\nexports.buildValuesAndSeparateKeysToObjectUnmapper = buildValuesAndSeparateKeysToObjectUnmapper;","map":{"version":3,"names":["Object","defineProperty","exports","value","buildValuesAndSeparateKeysToObjectUnmapper","buildValuesAndSeparateKeysToObjectMapper","keys","noKeyValue","valuesAndSeparateKeysToObjectMapper","gs","obj","idx","length","valueWrapper","configurable","enumerable","writable","valuesAndSeparateKeysToObjectUnmapper","Error","constructor","extractedPropertiesCount","extractedValues","descriptor","getOwnPropertyDescriptor","undefined","get","set","push","namePropertiesCount","getOwnPropertyNames","symbolPropertiesCount","getOwnPropertySymbols"],"sources":["/Users/karimelbarbary/Desktop/test4/devote/node_modules/fast-check/lib/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildValuesAndSeparateKeysToObjectUnmapper = exports.buildValuesAndSeparateKeysToObjectMapper = void 0;\nfunction buildValuesAndSeparateKeysToObjectMapper(keys, noKeyValue) {\n    return function valuesAndSeparateKeysToObjectMapper(gs) {\n        const obj = {};\n        for (let idx = 0; idx !== keys.length; ++idx) {\n            const valueWrapper = gs[idx];\n            if (valueWrapper !== noKeyValue) {\n                Object.defineProperty(obj, keys[idx], {\n                    value: valueWrapper,\n                    configurable: true,\n                    enumerable: true,\n                    writable: true,\n                });\n            }\n        }\n        return obj;\n    };\n}\nexports.buildValuesAndSeparateKeysToObjectMapper = buildValuesAndSeparateKeysToObjectMapper;\nfunction buildValuesAndSeparateKeysToObjectUnmapper(keys, noKeyValue) {\n    return function valuesAndSeparateKeysToObjectUnmapper(value) {\n        if (typeof value !== 'object' || value === null) {\n            throw new Error('Incompatible instance received: should be a non-null object');\n        }\n        if (!('constructor' in value) || value.constructor !== Object) {\n            throw new Error('Incompatible instance received: should be of exact type Object');\n        }\n        let extractedPropertiesCount = 0;\n        const extractedValues = [];\n        for (let idx = 0; idx !== keys.length; ++idx) {\n            const descriptor = Object.getOwnPropertyDescriptor(value, keys[idx]);\n            if (descriptor !== undefined) {\n                if (!descriptor.configurable || !descriptor.enumerable || !descriptor.writable) {\n                    throw new Error('Incompatible instance received: should contain only c/e/w properties');\n                }\n                if (descriptor.get !== undefined || descriptor.set !== undefined) {\n                    throw new Error('Incompatible instance received: should contain only no get/set properties');\n                }\n                ++extractedPropertiesCount;\n                extractedValues.push(descriptor.value);\n            }\n            else {\n                extractedValues.push(noKeyValue);\n            }\n        }\n        const namePropertiesCount = Object.getOwnPropertyNames(value).length;\n        const symbolPropertiesCount = Object.getOwnPropertySymbols(value).length;\n        if (extractedPropertiesCount !== namePropertiesCount + symbolPropertiesCount) {\n            throw new Error('Incompatible instance received: should not contain extra properties');\n        }\n        return extractedValues;\n    };\n}\nexports.buildValuesAndSeparateKeysToObjectUnmapper = buildValuesAndSeparateKeysToObjectUnmapper;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,0CAA0C,GAAGF,OAAO,CAACG,wCAAwC,GAAG,KAAK,CAAC;AAC9G,SAASA,wCAAwCA,CAACC,IAAI,EAAEC,UAAU,EAAE;EAChE,OAAO,SAASC,mCAAmCA,CAACC,EAAE,EAAE;IACpD,MAAMC,GAAG,GAAG,CAAC,CAAC;IACd,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,KAAKL,IAAI,CAACM,MAAM,EAAE,EAAED,GAAG,EAAE;MAC1C,MAAME,YAAY,GAAGJ,EAAE,CAACE,GAAG,CAAC;MAC5B,IAAIE,YAAY,KAAKN,UAAU,EAAE;QAC7BP,MAAM,CAACC,cAAc,CAACS,GAAG,EAAEJ,IAAI,CAACK,GAAG,CAAC,EAAE;UAClCR,KAAK,EAAEU,YAAY;UACnBC,YAAY,EAAE,IAAI;UAClBC,UAAU,EAAE,IAAI;UAChBC,QAAQ,EAAE;QACd,CAAC,CAAC;MACN;IACJ;IACA,OAAON,GAAG;EACd,CAAC;AACL;AACAR,OAAO,CAACG,wCAAwC,GAAGA,wCAAwC;AAC3F,SAASD,0CAA0CA,CAACE,IAAI,EAAEC,UAAU,EAAE;EAClE,OAAO,SAASU,qCAAqCA,CAACd,KAAK,EAAE;IACzD,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,EAAE;MAC7C,MAAM,IAAIe,KAAK,CAAC,6DAA6D,CAAC;IAClF;IACA,IAAI,EAAE,aAAa,IAAIf,KAAK,CAAC,IAAIA,KAAK,CAACgB,WAAW,KAAKnB,MAAM,EAAE;MAC3D,MAAM,IAAIkB,KAAK,CAAC,gEAAgE,CAAC;IACrF;IACA,IAAIE,wBAAwB,GAAG,CAAC;IAChC,MAAMC,eAAe,GAAG,EAAE;IAC1B,KAAK,IAAIV,GAAG,GAAG,CAAC,EAAEA,GAAG,KAAKL,IAAI,CAACM,MAAM,EAAE,EAAED,GAAG,EAAE;MAC1C,MAAMW,UAAU,GAAGtB,MAAM,CAACuB,wBAAwB,CAACpB,KAAK,EAAEG,IAAI,CAACK,GAAG,CAAC,CAAC;MACpE,IAAIW,UAAU,KAAKE,SAAS,EAAE;QAC1B,IAAI,CAACF,UAAU,CAACR,YAAY,IAAI,CAACQ,UAAU,CAACP,UAAU,IAAI,CAACO,UAAU,CAACN,QAAQ,EAAE;UAC5E,MAAM,IAAIE,KAAK,CAAC,sEAAsE,CAAC;QAC3F;QACA,IAAII,UAAU,CAACG,GAAG,KAAKD,SAAS,IAAIF,UAAU,CAACI,GAAG,KAAKF,SAAS,EAAE;UAC9D,MAAM,IAAIN,KAAK,CAAC,2EAA2E,CAAC;QAChG;QACA,EAAEE,wBAAwB;QAC1BC,eAAe,CAACM,IAAI,CAACL,UAAU,CAACnB,KAAK,CAAC;MAC1C,CAAC,MACI;QACDkB,eAAe,CAACM,IAAI,CAACpB,UAAU,CAAC;MACpC;IACJ;IACA,MAAMqB,mBAAmB,GAAG5B,MAAM,CAAC6B,mBAAmB,CAAC1B,KAAK,CAAC,CAACS,MAAM;IACpE,MAAMkB,qBAAqB,GAAG9B,MAAM,CAAC+B,qBAAqB,CAAC5B,KAAK,CAAC,CAACS,MAAM;IACxE,IAAIQ,wBAAwB,KAAKQ,mBAAmB,GAAGE,qBAAqB,EAAE;MAC1E,MAAM,IAAIZ,KAAK,CAAC,qEAAqE,CAAC;IAC1F;IACA,OAAOG,eAAe;EAC1B,CAAC;AACL;AACAnB,OAAO,CAACE,0CAA0C,GAAGA,0CAA0C"},"metadata":{},"sourceType":"script","externalDependencies":[]}