{"ast":null,"code":"const {\n  Web3Shim,\n  createInterfaceAdapter\n} = require(\"@truffle/interface-adapter\");\nconst utils = require(\"../utils\");\nconst execute = require(\"../execute\");\nconst bootstrap = require(\"./bootstrap\");\nconst debug = require(\"debug\")(\"contract:contract:constructorMethods\");\nconst OS = require(\"os\");\nmodule.exports = Contract => ({\n  configureNetwork() {\n    let {\n      networkType,\n      provider\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // otherwise use existing value as default (at most one of these)\n    networkType = networkType || this.networkType;\n    provider = provider || this.currentProvider;\n\n    // recreate interfaceadapter\n    this.interfaceAdapter = createInterfaceAdapter({\n      networkType,\n      provider\n    });\n    if (this.web3) {\n      // update existing\n      this.web3.setNetworkType(networkType);\n      this.web3.setProvider(provider);\n    } else {\n      // create new\n      this.web3 = new Web3Shim({\n        networkType,\n        provider\n      });\n    }\n\n    // save properties\n    this.currentProvider = provider;\n    this.networkType = networkType;\n  },\n  setProvider(provider) {\n    if (!provider) {\n      throw new Error(`Invalid provider passed to setProvider(); provider is ${provider}`);\n    }\n    this.configureNetwork({\n      provider\n    });\n  },\n  new() {\n    utils.checkProvider(this);\n    if (!this.bytecode || this.bytecode === \"0x\") {\n      throw new Error(`${this.contractName} error: contract binary not set. Can't deploy new instance.\\n` + `This contract may be abstract, not implement an abstract parent's methods completely\\n` + `or not invoke an inherited contract's constructor correctly\\n`);\n    }\n    var constructorABI = this.abi.filter(i => i.type === \"constructor\")[0];\n    return execute.deploy.call(this, constructorABI)(...arguments);\n  },\n  async at(address) {\n    if (address == null || typeof address !== \"string\" || address.length !== 42) {\n      throw new Error(`Invalid address passed to ${this.contractName}.at(): ${address}`);\n    }\n    await this.detectNetwork();\n    const onChainCode = await this.interfaceAdapter.getCode(address);\n    await utils.checkCode(onChainCode, this.contractName, address);\n    return new this(address);\n  },\n  async deployed() {\n    if (this.reloadJson) {\n      this.reloadJson(); //truffle test monkey-patches in this method\n    }\n\n    utils.checkProvider(this);\n    await this.detectNetwork();\n    utils.checkNetworkArtifactMatch(this);\n    utils.checkDeployment(this);\n    return new this(this.address);\n  },\n  defaults(class_defaults) {\n    if (this.class_defaults == null) {\n      this.class_defaults = {};\n    }\n    if (class_defaults == null) {\n      class_defaults = {};\n    }\n    Object.keys(class_defaults).forEach(key => {\n      const value = class_defaults[key];\n      this.class_defaults[key] = value;\n    });\n    return this.class_defaults;\n  },\n  hasNetwork(network_id) {\n    return this._json.networks[`${network_id}`] != null;\n  },\n  isDeployed() {\n    if (this.network_id == null) {\n      return false;\n    }\n    if (this._json.networks[this.network_id] == null) {\n      return false;\n    }\n    return !!this.network.address;\n  },\n  async detectNetwork() {\n    // guard interfaceAdapter!\n    if (this.interfaceAdapter == null) {\n      throw new Error(\"Provider not set or invalid\");\n    }\n    // if artifacts already have a network_id and network configuration synced,\n    // use that network and use latest block gasLimit\n    if (this.network_id && this.networks[this.network_id] != null) {\n      const {\n        gasLimit\n      } = await this.interfaceAdapter.getBlock(\"latest\");\n      return {\n        id: this.network_id,\n        blockLimit: gasLimit\n      };\n    }\n    // since artifacts don't have a network_id synced with a network configuration,\n    // poll chain for network_id and sync artifacts\n    const chainNetworkID = await this.interfaceAdapter.getNetworkId();\n    const {\n      gasLimit\n    } = await this.interfaceAdapter.getBlock(\"latest\");\n    return await utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);\n  },\n  setNetwork(network_id) {\n    if (!network_id) return;\n    this.network_id = `${network_id}`;\n  },\n  setNetworkType() {\n    let networkType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"ethereum\";\n    this.configureNetwork({\n      networkType\n    });\n  },\n  setWallet(wallet) {\n    this.configureNetwork();\n    this.web3.eth.accounts.wallet = wallet;\n  },\n  // Overrides the deployed address to null.\n  // You must call this explicitly so you don't inadvertently do this otherwise.\n  resetAddress() {\n    delete this.network.address;\n  },\n  // accepts 4 input formats\n  //  - (<name>, <address>)\n  //  - (<contractType>) - must have a deployed instance with an address\n  //  - (<contractInstance>)\n  //  - ({ <libName>: <address>, <libName2>: <address2>, ... })\n  link(name, address) {\n    switch (typeof name) {\n      case \"string\":\n        // Case: Contract.link(<libraryName>, <address>)\n        if (this._json.networks[this.network_id] == null) {\n          this._json.networks[this.network_id] = {\n            events: {},\n            links: {}\n          };\n        }\n        this.network.links[name] = address;\n        return;\n      case \"function\":\n        // Case: Contract.link(<contractType>)\n        const contract = name;\n        if (contract.isDeployed() === false) {\n          throw new Error(\"Cannot link contract without an address.\");\n        }\n        this.link(contract.contractName, contract.address);\n\n        // Merge events so this contract knows about library's events\n        Object.keys(contract.events).forEach(topic => {\n          this.network.events[topic] = contract.events[topic];\n        });\n        return;\n      case \"object\":\n        // 2 Cases:\n        //   - Contract.link({<libraryName>: <address>, ... })\n        //   - Contract.link(<instance>)\n        const obj = name;\n        if (obj.constructor && typeof obj.constructor.contractName === \"string\" && obj.address) {\n          // obj is a Truffle contract instance\n          this.link(obj.constructor.contractName, obj.address);\n        } else {\n          // obj is of the form { <libraryName>: <address>, ... }\n          Object.keys(obj).forEach(name => this.link(name, obj[name]));\n        }\n        return;\n      default:\n        const invalidInput = `Input to the link method is in the incorrect` + ` format. Input must be one of the following:${OS.EOL}` + `    - a library name and address                 > (\"MyLibrary\", ` + `\"0x123456789...\")${OS.EOL}` + `    - a contract type                            > ` + `(MyContract)${OS.EOL}` + `    - a contract instance                        > ` + `(myContract)${OS.EOL}` + `    - an object with library names and addresses > ({ <libName>: ` + `<address>, <libName2>: <address2>, ... })${OS.EOL}`;\n        throw new Error(invalidInput);\n    }\n  },\n  // Note, this function can be called with two input types:\n  // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n  // 2. network id; this will clone the contract and set a specific network id upon cloning.\n  clone(json) {\n    json = json || {};\n    const temp = function TruffleContract() {\n      this.constructor = temp;\n      return Contract.apply(this, arguments);\n    };\n    temp.prototype = Object.create(this.prototype);\n    let network_id;\n\n    // If we have a network id passed\n    if (typeof json !== \"object\") {\n      network_id = json;\n      json = this._json;\n    }\n    json = utils.merge({}, this._json || {}, json);\n    temp._constructorMethods = this._constructorMethods;\n    temp._properties = this._properties;\n    temp._property_values = {};\n    temp._json = json;\n    bootstrap(temp);\n    temp.class_defaults = temp.prototype.defaults || {};\n    if (network_id) {\n      temp.setNetwork(network_id);\n    }\n    if (this.currentProvider) {\n      temp.configureNetwork({\n        provider: this.currentProvider,\n        networkType: this.networkType\n      });\n    }\n\n    // Copy over custom key/values to the contract class\n    Object.keys(json).forEach(key => {\n      if (key.indexOf(\"x-\") !== 0) return;\n      temp[key] = json[key];\n    });\n    return temp;\n  },\n  addProp(key, fn) {\n    const getter = () => {\n      if (fn.get != null) {\n        return fn.get.call(this);\n      }\n      return this._property_values[key] || fn.call(this);\n    };\n    const setter = val => {\n      if (fn.set != null) {\n        fn.set.call(this, val);\n        return;\n      }\n\n      // If there's not a setter, then the property is immutable.\n      throw new Error(`${key} property is immutable`);\n    };\n    const definition = {};\n    definition.enumerable = false;\n    definition.configurable = false;\n    definition.get = getter;\n    definition.set = setter;\n    Object.defineProperty(this, key, definition);\n  },\n  toJSON() {\n    return this._json;\n  },\n  decodeLogs: utils.decodeLogs\n});","map":{"version":3,"names":["Web3Shim","createInterfaceAdapter","require","utils","execute","bootstrap","debug","OS","module","exports","Contract","configureNetwork","networkType","provider","arguments","length","undefined","currentProvider","interfaceAdapter","web3","setNetworkType","setProvider","Error","new","checkProvider","bytecode","contractName","constructorABI","abi","filter","i","type","deploy","call","at","address","detectNetwork","onChainCode","getCode","checkCode","deployed","reloadJson","checkNetworkArtifactMatch","checkDeployment","defaults","class_defaults","Object","keys","forEach","key","value","hasNetwork","network_id","_json","networks","isDeployed","network","gasLimit","getBlock","id","blockLimit","chainNetworkID","getNetworkId","setInstanceNetworkID","setNetwork","setWallet","wallet","eth","accounts","resetAddress","link","name","events","links","contract","topic","obj","constructor","invalidInput","EOL","clone","json","temp","TruffleContract","apply","prototype","create","merge","_constructorMethods","_properties","_property_values","indexOf","addProp","fn","getter","get","setter","val","set","definition","enumerable","configurable","defineProperty","toJSON","decodeLogs"],"sources":["/Users/karimelbarbary/Desktop/test4/devote/node_modules/@truffle/contract/lib/contract/constructorMethods.js"],"sourcesContent":["const {\n  Web3Shim,\n  createInterfaceAdapter\n} = require(\"@truffle/interface-adapter\");\nconst utils = require(\"../utils\");\nconst execute = require(\"../execute\");\nconst bootstrap = require(\"./bootstrap\");\nconst debug = require(\"debug\")(\"contract:contract:constructorMethods\");\nconst OS = require(\"os\");\n\nmodule.exports = Contract => ({\n  configureNetwork({ networkType, provider } = {}) {\n    // otherwise use existing value as default (at most one of these)\n    networkType = networkType || this.networkType;\n    provider = provider || this.currentProvider;\n\n    // recreate interfaceadapter\n    this.interfaceAdapter = createInterfaceAdapter({ networkType, provider });\n\n    if (this.web3) {\n      // update existing\n      this.web3.setNetworkType(networkType);\n      this.web3.setProvider(provider);\n    } else {\n      // create new\n      this.web3 = new Web3Shim({ networkType, provider });\n    }\n\n    // save properties\n    this.currentProvider = provider;\n    this.networkType = networkType;\n  },\n\n  setProvider(provider) {\n    if (!provider) {\n      throw new Error(\n        `Invalid provider passed to setProvider(); provider is ${provider}`\n      );\n    }\n\n    this.configureNetwork({ provider });\n  },\n\n  new() {\n    utils.checkProvider(this);\n\n    if (!this.bytecode || this.bytecode === \"0x\") {\n      throw new Error(\n        `${this.contractName} error: contract binary not set. Can't deploy new instance.\\n` +\n          `This contract may be abstract, not implement an abstract parent's methods completely\\n` +\n          `or not invoke an inherited contract's constructor correctly\\n`\n      );\n    }\n\n    var constructorABI = this.abi.filter(i => i.type === \"constructor\")[0];\n\n    return execute.deploy.call(this, constructorABI)(...arguments);\n  },\n\n  async at(address) {\n    if (\n      address == null ||\n      typeof address !== \"string\" ||\n      address.length !== 42\n    ) {\n      throw new Error(\n        `Invalid address passed to ${this.contractName}.at(): ${address}`\n      );\n    }\n\n    await this.detectNetwork();\n    const onChainCode = await this.interfaceAdapter.getCode(address);\n    await utils.checkCode(onChainCode, this.contractName, address);\n    return new this(address);\n  },\n\n  async deployed() {\n    if (this.reloadJson) {\n      this.reloadJson(); //truffle test monkey-patches in this method\n    }\n    utils.checkProvider(this);\n    await this.detectNetwork();\n    utils.checkNetworkArtifactMatch(this);\n    utils.checkDeployment(this);\n    return new this(this.address);\n  },\n\n  defaults(class_defaults) {\n    if (this.class_defaults == null) {\n      this.class_defaults = {};\n    }\n\n    if (class_defaults == null) {\n      class_defaults = {};\n    }\n\n    Object.keys(class_defaults).forEach(key => {\n      const value = class_defaults[key];\n      this.class_defaults[key] = value;\n    });\n\n    return this.class_defaults;\n  },\n\n  hasNetwork(network_id) {\n    return this._json.networks[`${network_id}`] != null;\n  },\n\n  isDeployed() {\n    if (this.network_id == null) {\n      return false;\n    }\n\n    if (this._json.networks[this.network_id] == null) {\n      return false;\n    }\n\n    return !!this.network.address;\n  },\n\n  async detectNetwork() {\n    // guard interfaceAdapter!\n    if (this.interfaceAdapter == null) {\n      throw new Error(\"Provider not set or invalid\");\n    }\n    // if artifacts already have a network_id and network configuration synced,\n    // use that network and use latest block gasLimit\n    if (this.network_id && this.networks[this.network_id] != null) {\n      const { gasLimit } = await this.interfaceAdapter.getBlock(\"latest\");\n      return { id: this.network_id, blockLimit: gasLimit };\n    }\n    // since artifacts don't have a network_id synced with a network configuration,\n    // poll chain for network_id and sync artifacts\n    const chainNetworkID = await this.interfaceAdapter.getNetworkId();\n    const { gasLimit } = await this.interfaceAdapter.getBlock(\"latest\");\n    return await utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);\n  },\n\n  setNetwork(network_id) {\n    if (!network_id) return;\n    this.network_id = `${network_id}`;\n  },\n\n  setNetworkType(networkType = \"ethereum\") {\n    this.configureNetwork({ networkType });\n  },\n\n  setWallet(wallet) {\n    this.configureNetwork();\n\n    this.web3.eth.accounts.wallet = wallet;\n  },\n\n  // Overrides the deployed address to null.\n  // You must call this explicitly so you don't inadvertently do this otherwise.\n  resetAddress() {\n    delete this.network.address;\n  },\n\n  // accepts 4 input formats\n  //  - (<name>, <address>)\n  //  - (<contractType>) - must have a deployed instance with an address\n  //  - (<contractInstance>)\n  //  - ({ <libName>: <address>, <libName2>: <address2>, ... })\n  link(name, address) {\n    switch (typeof name) {\n      case \"string\":\n        // Case: Contract.link(<libraryName>, <address>)\n        if (this._json.networks[this.network_id] == null) {\n          this._json.networks[this.network_id] = {\n            events: {},\n            links: {}\n          };\n        }\n\n        this.network.links[name] = address;\n        return;\n      case \"function\":\n        // Case: Contract.link(<contractType>)\n        const contract = name;\n\n        if (contract.isDeployed() === false) {\n          throw new Error(\"Cannot link contract without an address.\");\n        }\n\n        this.link(contract.contractName, contract.address);\n\n        // Merge events so this contract knows about library's events\n        Object.keys(contract.events).forEach(topic => {\n          this.network.events[topic] = contract.events[topic];\n        });\n        return;\n      case \"object\":\n        // 2 Cases:\n        //   - Contract.link({<libraryName>: <address>, ... })\n        //   - Contract.link(<instance>)\n        const obj = name;\n        if (\n          obj.constructor &&\n          typeof obj.constructor.contractName === \"string\" &&\n          obj.address\n        ) {\n          // obj is a Truffle contract instance\n          this.link(obj.constructor.contractName, obj.address);\n        } else {\n          // obj is of the form { <libraryName>: <address>, ... }\n          Object.keys(obj).forEach(name => this.link(name, obj[name]));\n        }\n        return;\n      default:\n        const invalidInput =\n          `Input to the link method is in the incorrect` +\n          ` format. Input must be one of the following:${OS.EOL}` +\n          `    - a library name and address                 > (\"MyLibrary\", ` +\n          `\"0x123456789...\")${OS.EOL}` +\n          `    - a contract type                            > ` +\n          `(MyContract)${OS.EOL}` +\n          `    - a contract instance                        > ` +\n          `(myContract)${OS.EOL}` +\n          `    - an object with library names and addresses > ({ <libName>: ` +\n          `<address>, <libName2>: <address2>, ... })${OS.EOL}`;\n        throw new Error(invalidInput);\n    }\n  },\n\n  // Note, this function can be called with two input types:\n  // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n  // 2. network id; this will clone the contract and set a specific network id upon cloning.\n  clone(json) {\n    json = json || {};\n\n    const temp = function TruffleContract() {\n      this.constructor = temp;\n      return Contract.apply(this, arguments);\n    };\n\n    temp.prototype = Object.create(this.prototype);\n\n    let network_id;\n\n    // If we have a network id passed\n    if (typeof json !== \"object\") {\n      network_id = json;\n      json = this._json;\n    }\n\n    json = utils.merge({}, this._json || {}, json);\n\n    temp._constructorMethods = this._constructorMethods;\n    temp._properties = this._properties;\n\n    temp._property_values = {};\n    temp._json = json;\n\n    bootstrap(temp);\n\n    temp.class_defaults = temp.prototype.defaults || {};\n\n    if (network_id) {\n      temp.setNetwork(network_id);\n    }\n\n    if (this.currentProvider) {\n      temp.configureNetwork({\n        provider: this.currentProvider,\n        networkType: this.networkType\n      });\n    }\n\n    // Copy over custom key/values to the contract class\n    Object.keys(json).forEach(key => {\n      if (key.indexOf(\"x-\") !== 0) return;\n      temp[key] = json[key];\n    });\n\n    return temp;\n  },\n\n  addProp(key, fn) {\n    const getter = () => {\n      if (fn.get != null) {\n        return fn.get.call(this);\n      }\n\n      return this._property_values[key] || fn.call(this);\n    };\n\n    const setter = val => {\n      if (fn.set != null) {\n        fn.set.call(this, val);\n        return;\n      }\n\n      // If there's not a setter, then the property is immutable.\n      throw new Error(`${key} property is immutable`);\n    };\n\n    const definition = {};\n    definition.enumerable = false;\n    definition.configurable = false;\n    definition.get = getter;\n    definition.set = setter;\n\n    Object.defineProperty(this, key, definition);\n  },\n\n  toJSON() {\n    return this._json;\n  },\n\n  decodeLogs: utils.decodeLogs\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}