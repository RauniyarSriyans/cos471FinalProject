{"ast":null,"code":"\"use strict\";\n\n/**\n * Contains the types for type objects, and some\n * functions for working with them.\n *\n * @category Main Format\n *\n * @packageDocumentation\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isContractDefinedType = exports.typeStringWithoutLocation = exports.typeString = exports.specifyLocation = exports.fullType = exports.isReferenceType = exports.forgetCompilations = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:format:types\");\nfunction forgetCompilations(typesByCompilation) {\n  return Object.assign({}, ...Object.values(typesByCompilation).map(_ref => {\n    let {\n      types\n    } = _ref;\n    return types;\n  }));\n}\nexports.forgetCompilations = forgetCompilations;\nfunction isUserDefinedType(anyType) {\n  const userDefinedTypes = [\"contract\", \"enum\", \"struct\", \"userDefinedValueType\"];\n  return userDefinedTypes.includes(anyType.typeClass);\n}\nfunction isReferenceType(anyType) {\n  const alwaysReferenceTypes = [\"array\", \"mapping\", \"struct\", \"string\"];\n  if (alwaysReferenceTypes.includes(anyType.typeClass)) {\n    return true;\n  } else if (anyType.typeClass === \"bytes\") {\n    return anyType.kind === \"dynamic\";\n  } else {\n    return false;\n  }\n}\nexports.isReferenceType = isReferenceType;\n//one could define a counterpart function that stripped all unnecessary information\n//from the type object, but at the moment I see no need for that\nfunction fullType(basicType, userDefinedTypes) {\n  if (!isUserDefinedType(basicType)) {\n    return basicType;\n  }\n  let id = basicType.id;\n  let storedType = userDefinedTypes[id];\n  if (!storedType) {\n    return basicType;\n  }\n  let returnType = Object.assign(Object.assign({}, basicType), storedType);\n  if (isReferenceType(basicType) && basicType.location !== undefined) {\n    returnType = specifyLocation(returnType, basicType.location);\n  }\n  return returnType;\n}\nexports.fullType = fullType;\n//the location argument here always forces, so passing undefined *will* force undefined\nfunction specifyLocation(dataType, location) {\n  if (isReferenceType(dataType)) {\n    switch (dataType.typeClass) {\n      case \"string\":\n      case \"bytes\":\n        return Object.assign(Object.assign({}, dataType), {\n          location\n        });\n      case \"array\":\n        return Object.assign(Object.assign({}, dataType), {\n          location,\n          baseType: specifyLocation(dataType.baseType, location)\n        });\n      case \"mapping\":\n        let newLocation = location === \"storage\" ? \"storage\" : undefined;\n        return Object.assign(Object.assign({}, dataType), {\n          location: newLocation,\n          valueType: specifyLocation(dataType.valueType, newLocation)\n        });\n      case \"struct\":\n        let returnType = Object.assign(Object.assign({}, dataType), {\n          location\n        });\n        if (returnType.memberTypes) {\n          returnType.memberTypes = returnType.memberTypes.map(_ref2 => {\n            let {\n              name: memberName,\n              type: memberType\n            } = _ref2;\n            return {\n              name: memberName,\n              type: specifyLocation(memberType, location)\n            };\n          });\n        }\n        return returnType;\n    }\n  } else {\n    return dataType;\n  }\n}\nexports.specifyLocation = specifyLocation;\n//NOTE: the following two functions might not be exactly right for weird internal stuff,\n//or for ABI-only stuff.  (E.g. for internal stuff sometimes it records whether things\n//are pointers or not??  we don't track that so we can't recreate that)\n//But what can you do.\nfunction typeString(dataType) {\n  let baseString = typeStringWithoutLocation(dataType);\n  if (isReferenceType(dataType) && dataType.location) {\n    return baseString + \" \" + dataType.location;\n  } else {\n    return baseString;\n  }\n}\nexports.typeString = typeString;\nfunction typeStringWithoutLocation(dataType) {\n  switch (dataType.typeClass) {\n    case \"uint\":\n      return dataType.typeHint || `uint${dataType.bits}`;\n    case \"int\":\n      return dataType.typeHint || `int${dataType.bits}`;\n    case \"bool\":\n      return dataType.typeHint || \"bool\";\n    case \"bytes\":\n      if (dataType.typeHint) {\n        return dataType.typeHint;\n      }\n      switch (dataType.kind) {\n        case \"dynamic\":\n          return \"bytes\";\n        case \"static\":\n          return `bytes${dataType.length}`;\n      }\n    case \"address\":\n      switch (dataType.kind) {\n        case \"general\":\n          return dataType.typeHint || \"address\";\n        //I guess?\n        case \"specific\":\n          return dataType.payable ? \"address payable\" : \"address\";\n      }\n    case \"string\":\n      return dataType.typeHint || \"string\";\n    case \"fixed\":\n      return dataType.typeHint || `fixed${dataType.bits}x${dataType.places}`;\n    case \"ufixed\":\n      return dataType.typeHint || `ufixed${dataType.bits}x${dataType.places}`;\n    case \"array\":\n      if (dataType.typeHint) {\n        return dataType.typeHint;\n      }\n      switch (dataType.kind) {\n        case \"dynamic\":\n          return `${typeStringWithoutLocation(dataType.baseType)}[]`;\n        case \"static\":\n          return `${typeStringWithoutLocation(dataType.baseType)}[${dataType.length}]`;\n      }\n    case \"mapping\":\n      return `mapping(${typeStringWithoutLocation(dataType.keyType)} => ${typeStringWithoutLocation(dataType.valueType)})`;\n    case \"struct\":\n    case \"enum\":\n      //combining these cases for simplicity\n      switch (dataType.kind) {\n        case \"local\":\n          return `${dataType.typeClass} ${dataType.definingContractName}.${dataType.typeName}`;\n        case \"global\":\n          return `${dataType.typeClass} ${dataType.typeName}`;\n      }\n      break;\n    //to satisfy TS :P\n    case \"userDefinedValueType\":\n      //differs from struct & enum in that typeClass is omitted\n      switch (dataType.kind) {\n        case \"local\":\n          return `${dataType.definingContractName}.${dataType.typeName}`;\n        case \"global\":\n          return `${dataType.typeName}`;\n      }\n      break;\n    //to satisfy TS :P\n    case \"tuple\":\n      return dataType.typeHint || \"tuple(\" + dataType.memberTypes.map(memberType => typeString(memberType.type)).join(\",\") + \")\";\n    //note that we do include location and do not put spaces\n    case \"contract\":\n      return dataType.contractKind + \" \" + dataType.typeName;\n    case \"magic\":\n      //no, this is not transposed!\n      const variableNames = {\n        message: \"msg\",\n        transaction: \"tx\",\n        block: \"block\"\n      };\n      return variableNames[dataType.variable];\n    case \"type\":\n      return `type(${typeString(dataType.type)})`;\n    case \"function\":\n      let visibilityString;\n      switch (dataType.visibility) {\n        case \"external\":\n          if (dataType.kind === \"general\") {\n            if (dataType.typeHint) {\n              return dataType.typeHint;\n            } else {\n              return \"function external\"; //I guess???\n            }\n          }\n\n          visibilityString = \" external\"; //note the deliberate space!\n          break;\n        case \"internal\":\n          visibilityString = \"\";\n          break;\n      }\n      let mutabilityString = dataType.mutability === \"nonpayable\" ? \"\" : \" \" + dataType.mutability; //again, note the deliberate space\n      let inputList = dataType.inputParameterTypes.map(typeString).join(\",\"); //note that we do include location, and do not put spaces\n      let outputList = dataType.outputParameterTypes.map(typeString).join(\",\");\n      let inputString = `function(${inputList})`;\n      let outputString = outputList === \"\" ? \"\" : ` returns (${outputList})`; //again, note the deliberate space\n      return inputString + mutabilityString + visibilityString + outputString;\n    case \"options\":\n      //note: not a real Solidity type! just for error messaging!\n      return \"options\";\n  }\n}\nexports.typeStringWithoutLocation = typeStringWithoutLocation;\nfunction isContractDefinedType(anyType) {\n  const contractDefinedTypes = [\"enum\", \"struct\", \"userDefinedValueType\"];\n  return contractDefinedTypes.includes(anyType.typeClass) && anyType.kind === \"local\";\n}\nexports.isContractDefinedType = isContractDefinedType;","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","forgetCompilations","typesByCompilation","Object","assign","values","map","_ref","types","exports","isUserDefinedType","anyType","userDefinedTypes","includes","typeClass","isReferenceType","alwaysReferenceTypes","kind","fullType","basicType","id","storedType","returnType","location","undefined","specifyLocation","dataType","baseType","newLocation","valueType","memberTypes","_ref2","name","memberName","type","memberType","typeString","baseString","typeStringWithoutLocation","typeHint","bits","length","payable","places","keyType","definingContractName","typeName","join","contractKind","variableNames","message","transaction","block","variable","visibilityString","visibility","mutabilityString","mutability","inputList","inputParameterTypes","outputList","outputParameterTypes","inputString","outputString","isContractDefinedType","contractDefinedTypes"],"sources":["../../../lib/format/types.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}