{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TupleArbitrary = void 0;\nconst Stream_1 = require(\"../../stream/Stream\");\nconst symbols_1 = require(\"../../check/symbols\");\nconst Arbitrary_1 = require(\"../../check/arbitrary/definition/Arbitrary\");\nconst Value_1 = require(\"../../check/arbitrary/definition/Value\");\nclass TupleArbitrary extends Arbitrary_1.Arbitrary {\n  constructor(arbs) {\n    super();\n    this.arbs = arbs;\n    for (let idx = 0; idx !== arbs.length; ++idx) {\n      const arb = arbs[idx];\n      if (arb == null || arb.generate == null) throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);\n    }\n  }\n  static makeItCloneable(vs, values) {\n    return Object.defineProperty(vs, symbols_1.cloneMethod, {\n      value: () => {\n        const cloned = [];\n        for (let idx = 0; idx !== values.length; ++idx) {\n          cloned.push(values[idx].value);\n        }\n        TupleArbitrary.makeItCloneable(cloned, values);\n        return cloned;\n      }\n    });\n  }\n  static wrapper(values) {\n    let cloneable = false;\n    const vs = [];\n    const ctxs = [];\n    for (let idx = 0; idx !== values.length; ++idx) {\n      const v = values[idx];\n      cloneable = cloneable || v.hasToBeCloned;\n      vs.push(v.value);\n      ctxs.push(v.context);\n    }\n    if (cloneable) {\n      TupleArbitrary.makeItCloneable(vs, values);\n    }\n    return new Value_1.Value(vs, ctxs);\n  }\n  generate(mrng, biasFactor) {\n    return TupleArbitrary.wrapper(this.arbs.map(a => a.generate(mrng, biasFactor)));\n  }\n  canShrinkWithoutContext(value) {\n    if (!Array.isArray(value) || value.length !== this.arbs.length) {\n      return false;\n    }\n    for (let index = 0; index !== this.arbs.length; ++index) {\n      if (!this.arbs[index].canShrinkWithoutContext(value[index])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  shrink(value, context) {\n    let s = Stream_1.Stream.nil();\n    const safeContext = Array.isArray(context) ? context : [];\n    for (let idx = 0; idx !== this.arbs.length; ++idx) {\n      const shrinksForIndex = this.arbs[idx].shrink(value[idx], safeContext[idx]).map(v => {\n        const nextValues = value.map((v, idx) => new Value_1.Value((0, symbols_1.cloneIfNeeded)(v), safeContext[idx]));\n        return nextValues.slice(0, idx).concat([v]).concat(nextValues.slice(idx + 1));\n      }).map(values => TupleArbitrary.wrapper(values));\n      s = s.join(shrinksForIndex);\n    }\n    return s;\n  }\n}\nexports.TupleArbitrary = TupleArbitrary;","map":{"version":3,"names":["Object","defineProperty","exports","value","TupleArbitrary","Stream_1","require","symbols_1","Arbitrary_1","Value_1","Arbitrary","constructor","arbs","idx","length","arb","generate","Error","makeItCloneable","vs","values","cloneMethod","cloned","push","wrapper","cloneable","ctxs","v","hasToBeCloned","context","Value","mrng","biasFactor","map","a","canShrinkWithoutContext","Array","isArray","index","shrink","s","Stream","nil","safeContext","shrinksForIndex","nextValues","cloneIfNeeded","slice","concat","join"],"sources":["/Users/karimelbarbary/Desktop/test4/devote/node_modules/fast-check/lib/arbitrary/_internals/TupleArbitrary.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TupleArbitrary = void 0;\nconst Stream_1 = require(\"../../stream/Stream\");\nconst symbols_1 = require(\"../../check/symbols\");\nconst Arbitrary_1 = require(\"../../check/arbitrary/definition/Arbitrary\");\nconst Value_1 = require(\"../../check/arbitrary/definition/Value\");\nclass TupleArbitrary extends Arbitrary_1.Arbitrary {\n    constructor(arbs) {\n        super();\n        this.arbs = arbs;\n        for (let idx = 0; idx !== arbs.length; ++idx) {\n            const arb = arbs[idx];\n            if (arb == null || arb.generate == null)\n                throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);\n        }\n    }\n    static makeItCloneable(vs, values) {\n        return Object.defineProperty(vs, symbols_1.cloneMethod, {\n            value: () => {\n                const cloned = [];\n                for (let idx = 0; idx !== values.length; ++idx) {\n                    cloned.push(values[idx].value);\n                }\n                TupleArbitrary.makeItCloneable(cloned, values);\n                return cloned;\n            },\n        });\n    }\n    static wrapper(values) {\n        let cloneable = false;\n        const vs = [];\n        const ctxs = [];\n        for (let idx = 0; idx !== values.length; ++idx) {\n            const v = values[idx];\n            cloneable = cloneable || v.hasToBeCloned;\n            vs.push(v.value);\n            ctxs.push(v.context);\n        }\n        if (cloneable) {\n            TupleArbitrary.makeItCloneable(vs, values);\n        }\n        return new Value_1.Value(vs, ctxs);\n    }\n    generate(mrng, biasFactor) {\n        return TupleArbitrary.wrapper(this.arbs.map((a) => a.generate(mrng, biasFactor)));\n    }\n    canShrinkWithoutContext(value) {\n        if (!Array.isArray(value) || value.length !== this.arbs.length) {\n            return false;\n        }\n        for (let index = 0; index !== this.arbs.length; ++index) {\n            if (!this.arbs[index].canShrinkWithoutContext(value[index])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    shrink(value, context) {\n        let s = Stream_1.Stream.nil();\n        const safeContext = Array.isArray(context) ? context : [];\n        for (let idx = 0; idx !== this.arbs.length; ++idx) {\n            const shrinksForIndex = this.arbs[idx]\n                .shrink(value[idx], safeContext[idx])\n                .map((v) => {\n                const nextValues = value.map((v, idx) => new Value_1.Value((0, symbols_1.cloneIfNeeded)(v), safeContext[idx]));\n                return nextValues\n                    .slice(0, idx)\n                    .concat([v])\n                    .concat(nextValues.slice(idx + 1));\n            })\n                .map((values) => TupleArbitrary.wrapper(values));\n            s = s.join(shrinksForIndex);\n        }\n        return s;\n    }\n}\nexports.TupleArbitrary = TupleArbitrary;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}