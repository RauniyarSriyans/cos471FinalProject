{"ast":null,"code":"\"use strict\";\n\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeMemoryReferenceByAddress = exports.decodeMemory = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:memory:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst errors_1 = require(\"../../errors\");\nfunction decodeMemory(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    if (Format.Types.isReferenceType(dataType)) {\n      if ((0, allocate_1.isSkippedInMemoryStructs)(dataType)) {\n        //special case; these types are always empty in memory\n        return decodeMemorySkippedType(dataType);\n      } else {\n        return yield* decodeMemoryReferenceByAddress(dataType, pointer, info, options);\n      }\n    } else {\n      return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n    }\n  }();\n}\nexports.decodeMemory = decodeMemory;\nfunction decodeMemorySkippedType(dataType) {\n  switch (dataType.typeClass) {\n    case \"mapping\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: []\n      };\n    case \"array\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: []\n      };\n    //other cases should not arise!\n  }\n}\n\nfunction decodeMemoryReferenceByAddress(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    const {\n      state\n    } = info;\n    const memoryVisited = options.memoryVisited || [];\n    debug(\"pointer %o\", pointer);\n    let rawValue;\n    try {\n      rawValue = yield* (0, read_1.default)(pointer, state);\n    } catch (error) {\n      return (0, errors_1.handleDecodingError)(dataType, error);\n    }\n    let startPositionAsBN = Conversion.toBN(rawValue);\n    let startPosition;\n    try {\n      startPosition = startPositionAsBN.toNumber();\n    } catch (_a) {\n      return {\n        //again with the TS failures...\n        type: dataType,\n        kind: \"error\",\n        error: {\n          kind: \"OverlargePointersNotImplementedError\",\n          pointerAsBN: startPositionAsBN\n        }\n      };\n    }\n    //startPosition may get modified later, so let's save the current\n    //value for circularity detection purposes\n    const objectPosition = startPosition;\n    let rawLength;\n    let lengthAsBN;\n    let length;\n    let seenPreviously;\n    switch (dataType.typeClass) {\n      case \"bytes\":\n      case \"string\":\n        //initial word contains length\n        try {\n          rawLength = yield* (0, read_1.default)({\n            location: \"memory\",\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state);\n        } catch (error) {\n          return (0, errors_1.handleDecodingError)(dataType, error);\n        }\n        lengthAsBN = Conversion.toBN(rawLength);\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_b) {\n          return {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN\n            }\n          };\n        }\n        let childPointer = {\n          location: \"memory\",\n          start: startPosition + Evm.Utils.WORD_SIZE,\n          length\n        };\n        return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info);\n      case \"array\":\n        {\n          //first: circularity check!\n          seenPreviously = memoryVisited.indexOf(objectPosition);\n          if (seenPreviously !== -1) {\n            return {\n              type: dataType,\n              kind: \"value\",\n              reference: seenPreviously + 1,\n              value: [] //will be fixed later by the tie function\n            };\n          }\n          //otherwise, decode as normal\n          if (dataType.kind === \"dynamic\") {\n            //initial word contains array length\n            try {\n              rawLength = yield* (0, read_1.default)({\n                location: \"memory\",\n                start: startPosition,\n                length: Evm.Utils.WORD_SIZE\n              }, state);\n            } catch (error) {\n              return (0, errors_1.handleDecodingError)(dataType, error);\n            }\n            lengthAsBN = Conversion.toBN(rawLength);\n            startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n            //to next word, as first word was used for length\n          } else {\n            lengthAsBN = dataType.length;\n          }\n          try {\n            length = lengthAsBN.toNumber();\n          } catch (_c) {\n            return {\n              type: dataType,\n              kind: \"error\",\n              error: {\n                kind: \"OverlongArraysAndStringsNotImplementedError\",\n                lengthAsBN\n              }\n            };\n          }\n          let memoryNowVisited = [objectPosition, ...memoryVisited];\n          let baseType = dataType.baseType;\n          let decodedChildren = [];\n          for (let index = 0; index < length; index++) {\n            decodedChildren.push(yield* decodeMemory(baseType, {\n              location: \"memory\",\n              start: startPosition + index * Evm.Utils.WORD_SIZE,\n              length: Evm.Utils.WORD_SIZE\n            }, info, {\n              memoryVisited: memoryNowVisited\n            }));\n          }\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: decodedChildren\n          };\n        }\n      case \"struct\":\n        {\n          //first: circularity check!\n          seenPreviously = memoryVisited.indexOf(objectPosition);\n          if (seenPreviously !== -1) {\n            return {\n              type: dataType,\n              kind: \"value\",\n              reference: seenPreviously + 1,\n              value: [] //will be fixed later by the tie function\n            };\n          }\n          //otherwise, decode as normal\n          const {\n            allocations: {\n              memory: allocations\n            }\n          } = info;\n          const typeId = dataType.id;\n          const structAllocation = allocations[typeId];\n          if (!structAllocation) {\n            return {\n              type: dataType,\n              kind: \"error\",\n              error: {\n                kind: \"UserDefinedTypeNotFoundError\",\n                type: dataType\n              }\n            };\n          }\n          debug(\"structAllocation %O\", structAllocation);\n          let memoryNowVisited = [objectPosition, ...memoryVisited];\n          let decodedMembers = [];\n          for (let index = 0; index < structAllocation.members.length; index++) {\n            const memberAllocation = structAllocation.members[index];\n            const memberPointer = memberAllocation.pointer;\n            const childPointer = {\n              location: \"memory\",\n              start: startPosition + memberPointer.start,\n              length: memberPointer.length //always equals WORD_SIZE or 0\n            };\n\n            let memberName = memberAllocation.name;\n            let memberType = Format.Types.specifyLocation(memberAllocation.type, \"memory\");\n            decodedMembers.push({\n              name: memberName,\n              value: yield* decodeMemory(memberType, childPointer, info, {\n                memoryVisited: memoryNowVisited\n              })\n            });\n          }\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: decodedMembers\n          };\n        }\n    }\n  }();\n}\nexports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","read_1","Conversion","__importStar","Format","Basic","Bytes","Evm","allocate_1","errors_1","decodeMemory","dataType","pointer","info","options","arguments","length","undefined","Types","isReferenceType","isSkippedInMemoryStructs","decodeMemorySkippedType","decodeMemoryReferenceByAddress","Decode","decodeBasic","exports","typeClass","type","kind","value","state","memoryVisited","rawValue","error","handleDecodingError","startPositionAsBN","toBN","startPosition","toNumber","_a","pointerAsBN","objectPosition","rawLength","lengthAsBN","seenPreviously","location","start","Utils","WORD_SIZE","_b","childPointer","decodeBytes","indexOf","reference","_c","memoryNowVisited","baseType","decodedChildren","index","push","allocations","memory","typeId","id","structAllocation","decodedMembers","members","memberAllocation","memberPointer","memberName","name","memberType","specifyLocation"],"sources":["../../../../lib/memory/decode/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}