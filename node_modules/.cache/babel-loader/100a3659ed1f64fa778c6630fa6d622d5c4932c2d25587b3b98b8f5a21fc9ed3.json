{"ast":null,"code":"\"use strict\";\n\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeLiteral = exports.decodeStack = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:stack:decode\");\nconst AbiData = __importStar(require(\"../../abi-data\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Memory = __importStar(require(\"../../memory\"));\nconst Storage = __importStar(require(\"../../storage\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nfunction* decodeStack(dataType, pointer, info) {\n  let rawValue;\n  try {\n    rawValue = yield* (0, read_1.default)(pointer, info.state);\n  } catch (error) {\n    return (0, errors_1.handleDecodingError)(dataType, error);\n  }\n  const literalPointer = {\n    location: \"stackliteral\",\n    literal: rawValue\n  };\n  return yield* decodeLiteral(dataType, literalPointer, info);\n}\nexports.decodeStack = decodeStack;\nfunction* decodeLiteral(dataType, pointer, info) {\n  debug(\"type %O\", dataType);\n  debug(\"pointer %o\", pointer);\n  if (Format.Types.isReferenceType(dataType)) {\n    switch (dataType.location) {\n      case \"memory\":\n        //first: do we have a memory pointer? if so we can just dispatch to\n        //decodeMemoryReference\n        return yield* Memory.Decode.decodeMemoryReferenceByAddress(dataType, pointer, info);\n      case \"storage\":\n        //next: do we have a storage pointer (which may be a mapping)? if so, we can\n        //we dispatch to decodeStorageByAddress\n        return yield* Storage.Decode.decodeStorageReferenceByAddress(dataType, pointer, info);\n      case \"calldata\":\n        //next: do we have a calldata pointer?\n        //if it's a lookup type, it'll need special handling\n        if (dataType.typeClass === \"bytes\" || dataType.typeClass === \"string\" || dataType.typeClass === \"array\" && dataType.kind === \"dynamic\") {\n          const lengthAsBN = Conversion.toBN(pointer.literal.slice(Evm.Utils.WORD_SIZE));\n          const locationOnly = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);\n          return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, {\n            location: \"stackliteral\",\n            literal: locationOnly\n          }, info, {\n            abiPointerBase: 0,\n            lengthOverride: lengthAsBN\n          });\n        } else {\n          //multivalue case -- this case is straightforward\n          return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, pointer, info, {\n            abiPointerBase: 0 //let's be explicit\n          });\n        }\n    }\n  }\n  //next: do we have an external function?  these work differently on the stack\n  //than elsewhere, so we can't just pass it on to decodeBasic.\n  if (dataType.typeClass === \"function\" && dataType.visibility === \"external\") {\n    let address = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);\n    let selectorWord = pointer.literal.slice(-Evm.Utils.WORD_SIZE);\n    if (!Basic.Decode.checkPaddingLeft(address, Evm.Utils.ADDRESS_SIZE) || !Basic.Decode.checkPaddingLeft(selectorWord, Evm.Utils.SELECTOR_SIZE)) {\n      return {\n        type: dataType,\n        kind: \"error\",\n        error: {\n          kind: \"FunctionExternalStackPaddingError\",\n          rawAddress: Conversion.toHexString(address),\n          rawSelector: Conversion.toHexString(selectorWord)\n        }\n      };\n    }\n    let selector = selectorWord.slice(-Evm.Utils.SELECTOR_SIZE);\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: yield* Basic.Decode.decodeExternalFunction(address, selector, info)\n    };\n  }\n  //finally, if none of the above hold, we can just dispatch to decodeBasic.\n  //however, note that because we're on the stack, we use the permissive padding\n  //option so that errors won't result due to values with bad padding\n  //(of numeric or bytesN type, anyway)\n  return yield* Basic.Decode.decodeBasic(dataType, pointer, info, {\n    paddingMode: \"permissive\"\n  });\n}\nexports.decodeLiteral = decodeLiteral;","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","AbiData","__importStar","Conversion","Format","read_1","Basic","Memory","Storage","Evm","errors_1","decodeStack","dataType","pointer","info","rawValue","state","error","handleDecodingError","literalPointer","location","literal","decodeLiteral","exports","Types","isReferenceType","Decode","decodeMemoryReferenceByAddress","decodeStorageReferenceByAddress","typeClass","kind","lengthAsBN","toBN","slice","Utils","WORD_SIZE","locationOnly","decodeAbiReferenceByAddress","abiPointerBase","lengthOverride","visibility","address","selectorWord","checkPaddingLeft","ADDRESS_SIZE","SELECTOR_SIZE","type","rawAddress","toHexString","rawSelector","selector","value","decodeExternalFunction","decodeBasic","paddingMode"],"sources":["../../../../lib/stack/decode/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}