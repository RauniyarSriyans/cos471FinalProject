{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPaddingLeft = exports.decodeExternalFunction = exports.decodeContract = exports.decodeBasic = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:basic:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Contexts = __importStar(require(\"../../contexts\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nconst allocate_1 = require(\"../allocate\");\nfunction decodeBasic(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    const {\n      state\n    } = info;\n    const {\n      strictAbiMode: strict\n    } = options; //if this is undefined it'll still be falsy so it's OK\n    const paddingMode = options.paddingMode || \"default\";\n    let bytes;\n    let rawBytes;\n    try {\n      bytes = yield* (0, read_1.default)(pointer, state);\n    } catch (error) {\n      debug(\"segfault, pointer %o, state: %O\", pointer, state);\n      return (0, errors_1.handleDecodingError)(dataType, error, strict);\n    }\n    rawBytes = bytes;\n    debug(\"type %O\", dataType);\n    debug(\"pointer %o\", pointer);\n    switch (dataType.typeClass) {\n      case \"userDefinedValueType\":\n        {\n          const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n          if (!fullType.underlyingType) {\n            const error = {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: fullType\n            };\n            if (strict || options.allowRetry) {\n              throw new errors_1.StopDecodingError(error, true);\n              //note that we allow a retry if we couldn't locate the underlying type!\n            }\n\n            return {\n              type: fullType,\n              kind: \"error\",\n              error\n            };\n          }\n          const underlyingResult = yield* decodeBasic(fullType.underlyingType, pointer, info, options);\n          switch (underlyingResult.kind //yes this switch is a little unnecessary :P\n          ) {\n            case \"value\":\n              //wrap the value and return\n              return {\n                //no idea why need coercion here\n                type: fullType,\n                kind: \"value\",\n                value: underlyingResult\n              };\n            case \"error\":\n              //wrap the error and return an error result!\n              //this is inconsistent with how we handle other container types\n              //(structs, arrays, mappings), where having an error in one element\n              //does not cause an error in the whole thing, but to do that here\n              //would cause problems for the type system :-/\n              //so we'll just be inconsistent\n              return {\n                //TS is being bad again :-/\n                type: fullType,\n                kind: \"error\",\n                error: {\n                  kind: \"WrappedError\",\n                  error: underlyingResult\n                }\n              };\n          }\n          break; //to satisfy TS :P\n        }\n\n      case \"bool\":\n        {\n          if (!checkPadding(bytes, dataType, paddingMode)) {\n            let error = {\n              kind: \"BoolPaddingError\",\n              paddingType: getPaddingType(dataType, paddingMode),\n              raw: Conversion.toHexString(bytes)\n            };\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n          bytes = removePadding(bytes, dataType, paddingMode);\n          //note: the use of the BN is a little silly here,\n          //but, kind of stuck with it for now\n          const numeric = Conversion.toBN(bytes);\n          if (numeric.eqn(0)) {\n            return {\n              type: dataType,\n              kind: \"value\",\n              value: {\n                asBoolean: false\n              }\n            };\n          } else if (numeric.eqn(1)) {\n            return {\n              type: dataType,\n              kind: \"value\",\n              value: {\n                asBoolean: true\n              }\n            };\n          } else {\n            let error = {\n              kind: \"BoolOutOfRangeError\",\n              rawAsBN: numeric\n            };\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n        }\n      case \"uint\":\n        //first, check padding (if needed)\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"UintPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n        //now, truncate to appropriate length\n        bytes = removePadding(bytes, dataType, paddingMode);\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: {\n            asBN: Conversion.toBN(bytes),\n            rawAsBN: Conversion.toBN(rawBytes)\n          }\n        };\n      case \"int\":\n        //first, check padding (if needed)\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"IntPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n        //now, truncate to appropriate length (keeping the bytes on the right)\n        bytes = removePadding(bytes, dataType, paddingMode);\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: {\n            asBN: Conversion.toSignedBN(bytes),\n            rawAsBN: Conversion.toSignedBN(rawBytes)\n          }\n        };\n      case \"address\":\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"AddressPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n        bytes = removePadding(bytes, dataType, paddingMode);\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: {\n            asAddress: Evm.Utils.toAddress(bytes),\n            rawAsHex: Conversion.toHexString(rawBytes)\n          }\n        };\n      case \"contract\":\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"ContractPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n        bytes = removePadding(bytes, dataType, paddingMode);\n        const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n        const contractValueInfo = yield* decodeContract(bytes, info);\n        return {\n          type: fullType,\n          kind: \"value\",\n          value: contractValueInfo\n        };\n      case \"bytes\":\n        //NOTE: we assume this is a *static* bytestring,\n        //because this is decodeBasic! dynamic ones should\n        //go to decodeBytes!\n        let coercedDataType = dataType;\n        //first, check padding (if needed)\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"BytesPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n          return {\n            type: coercedDataType,\n            kind: \"error\",\n            error\n          };\n        }\n        //now, truncate to appropriate length\n        bytes = removePadding(bytes, dataType, paddingMode);\n        return {\n          type: coercedDataType,\n          kind: \"value\",\n          value: {\n            asHex: Conversion.toHexString(bytes),\n            rawAsHex: Conversion.toHexString(rawBytes)\n          }\n        };\n      case \"function\":\n        switch (dataType.visibility) {\n          case \"external\":\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n              const error = {\n                kind: \"FunctionExternalNonStackPaddingError\",\n                paddingType: getPaddingType(dataType, paddingMode),\n                raw: Conversion.toHexString(bytes)\n              };\n              if (strict) {\n                throw new errors_1.StopDecodingError(error);\n              }\n              return {\n                type: dataType,\n                kind: \"error\",\n                error\n              };\n            }\n            bytes = removePadding(bytes, dataType, paddingMode);\n            const address = bytes.slice(0, Evm.Utils.ADDRESS_SIZE);\n            const selector = bytes.slice(Evm.Utils.ADDRESS_SIZE, Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE);\n            return {\n              type: dataType,\n              kind: \"value\",\n              value: yield* decodeExternalFunction(address, selector, info)\n            };\n          case \"internal\":\n            //note: we used to error if we hit this point with strict === true,\n            //since internal function pointers don't go in the ABI, and strict\n            //mode is intended for ABI decoding.  however, there are times when\n            //we want to use strict mode to decode immutables, and immutables can\n            //include internal function pointers.  so now we allow this.  yes,\n            //this is a bit of an abuse of strict mode, which was after all meant\n            //for ABI decoding, but oh well.\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n              const error = {\n                kind: \"FunctionInternalPaddingError\",\n                paddingType: getPaddingType(dataType, paddingMode),\n                raw: Conversion.toHexString(bytes)\n              };\n              if (strict) {\n                throw new errors_1.StopDecodingError(error);\n              }\n              return {\n                type: dataType,\n                kind: \"error\",\n                error\n              };\n            }\n            bytes = removePadding(bytes, dataType, paddingMode);\n            const deployedPc = bytes.slice(-Evm.Utils.PC_SIZE);\n            const constructorPc = bytes.slice(-Evm.Utils.PC_SIZE * 2, -Evm.Utils.PC_SIZE);\n            return decodeInternalFunction(dataType, deployedPc, constructorPc, info, strict);\n        }\n        break;\n      //to satisfy TypeScript\n      case \"enum\":\n        {\n          let numeric = Conversion.toBN(bytes);\n          const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n          if (!fullType.options) {\n            let error = {\n              kind: \"EnumNotFoundDecodingError\",\n              type: fullType,\n              rawAsBN: numeric\n            };\n            if (strict || options.allowRetry) {\n              throw new errors_1.StopDecodingError(error, true);\n              //note that we allow a retry if we couldn't locate the enum type!\n            }\n\n            return {\n              type: fullType,\n              kind: \"error\",\n              error\n            };\n          }\n          //note: I'm doing the padding checks a little more manually on this one\n          //so that we can have the right type of error\n          const numOptions = fullType.options.length;\n          const numBytes = Math.ceil(Math.log2(numOptions) / 8);\n          const paddingType = getPaddingType(dataType, paddingMode);\n          if (!checkPaddingDirect(bytes, numBytes, paddingType)) {\n            let error = {\n              kind: \"EnumPaddingError\",\n              type: fullType,\n              paddingType,\n              raw: Conversion.toHexString(bytes)\n            };\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n          bytes = removePaddingDirect(bytes, numBytes, paddingType);\n          numeric = Conversion.toBN(bytes); //alter numeric!\n          if (numeric.ltn(numOptions)) {\n            const name = fullType.options[numeric.toNumber()];\n            //NOTE: despite the use of toNumber(), I'm NOT catching exceptions here and returning an\n            //error value like elsewhere; I'm just letting this one fail.  Why?  Because if we have\n            //an enum with that many options in the first place, we have bigger problems!\n            return {\n              type: fullType,\n              kind: \"value\",\n              value: {\n                name,\n                numericAsBN: numeric\n              }\n            };\n          } else {\n            let error = {\n              kind: \"EnumOutOfRangeError\",\n              type: fullType,\n              rawAsBN: numeric\n            };\n            if (strict) {\n              //note:\n              //if the enum is merely out of range rather than out of the ABI range,\n              //we do NOT throw an error here!  instead we simply return an error value,\n              //which we normally avoid doing in strict mode.  (the error will be caught\n              //later at the re-encoding step instead.)  why?  because we might be running\n              //in ABI mode, so we may need to abify this \"value\" rather than just throwing\n              //it out.\n              throw new errors_1.StopDecodingError(error);\n              //note that we do NOT allow a retry here!\n              //if we *can* find the enum type but the value is out of range,\n              //we *know* that it is invalid!\n            }\n\n            return {\n              type: fullType,\n              kind: \"error\",\n              error\n            };\n          }\n        }\n      case \"fixed\":\n        {\n          //first, check padding (if needed)\n          if (!checkPadding(bytes, dataType, paddingMode)) {\n            let error = {\n              kind: \"FixedPaddingError\",\n              paddingType: getPaddingType(dataType, paddingMode),\n              raw: Conversion.toHexString(bytes)\n            };\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n          //now, truncate to appropriate length (keeping the bytes on the right)\n          bytes = removePadding(bytes, dataType, paddingMode);\n          let asBN = Conversion.toSignedBN(bytes);\n          let rawAsBN = Conversion.toSignedBN(rawBytes);\n          let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n          let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBig,\n              rawAsBig\n            }\n          };\n        }\n      case \"ufixed\":\n        {\n          //first, check padding (if needed)\n          if (!checkPadding(bytes, dataType, paddingMode)) {\n            let error = {\n              kind: \"UfixedPaddingError\",\n              paddingType: getPaddingType(dataType, paddingMode),\n              raw: Conversion.toHexString(bytes)\n            };\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n          //now, truncate to appropriate length (keeping the bytes on the right)\n          bytes = removePadding(bytes, dataType, paddingMode);\n          let asBN = Conversion.toBN(bytes);\n          let rawAsBN = Conversion.toBN(rawBytes);\n          let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n          let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBig,\n              rawAsBig\n            }\n          };\n        }\n    }\n  }();\n}\nexports.decodeBasic = decodeBasic;\n//NOTE that this function returns a ContractValueInfo, not a ContractResult\nfunction* decodeContract(addressBytes, info) {\n  return (yield* decodeContractAndContext(addressBytes, info)).contractInfo;\n}\nexports.decodeContract = decodeContract;\nfunction* decodeContractAndContext(addressBytes, info) {\n  let address = Evm.Utils.toAddress(addressBytes);\n  let rawAddress = Conversion.toHexString(addressBytes);\n  let codeBytes = yield {\n    type: \"code\",\n    address\n  };\n  let code = Conversion.toHexString(codeBytes);\n  let context = Contexts.Utils.findContext(info.contexts, code);\n  if (context !== null) {\n    return {\n      context,\n      contractInfo: {\n        kind: \"known\",\n        address,\n        rawAddress,\n        class: Contexts.Import.contextToType(context)\n      }\n    };\n  } else {\n    return {\n      context,\n      contractInfo: {\n        kind: \"unknown\",\n        address,\n        rawAddress\n      }\n    };\n  }\n}\n//note: address can have extra zeroes on the left like elsewhere, but selector should be exactly 4 bytes\n//NOTE this again returns a FunctionExternalValueInfo, not a FunctionExternalResult\nfunction* decodeExternalFunction(addressBytes, selectorBytes, info) {\n  let {\n    contractInfo: contract,\n    context\n  } = yield* decodeContractAndContext(addressBytes, info);\n  let selector = Conversion.toHexString(selectorBytes);\n  if (contract.kind === \"unknown\") {\n    return {\n      kind: \"unknown\",\n      contract,\n      selector\n    };\n  }\n  let abiEntry = context.abi !== undefined ? context.abi[selector] : undefined;\n  if (abiEntry === undefined) {\n    return {\n      kind: \"invalid\",\n      contract,\n      selector\n    };\n  }\n  return {\n    kind: \"known\",\n    contract,\n    selector,\n    abi: abiEntry\n  };\n}\nexports.decodeExternalFunction = decodeExternalFunction;\n//this one works a bit differently -- in order to handle errors, it *does* return a FunctionInternalResult\nfunction decodeInternalFunction(dataType, deployedPcBytes, constructorPcBytes, info, strict) {\n  const deployedPc = Conversion.toBN(deployedPcBytes).toNumber();\n  const constructorPc = Conversion.toBN(constructorPcBytes).toNumber();\n  const context = Contexts.Import.contextToType(info.currentContext);\n  //before anything else: do we even have an internal functions table?\n  //if not, we'll just return the info we have without really attemting to decode\n  if (!info.internalFunctionsTable) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"unknown\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  }\n  //also before we continue: is the PC zero? if so let's just return that\n  if (deployedPc === 0 && constructorPc === 0) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  }\n  //another check: is only the deployed PC zero?\n  if (deployedPc === 0 && constructorPc !== 0) {\n    const error = {\n      kind: \"MalformedInternalFunctionError\",\n      context,\n      deployedProgramCounter: 0,\n      constructorProgramCounter: constructorPc\n    };\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n  //one last pre-check: is this a deployed-format pointer in a constructor?\n  if (info.currentContext.isConstructor && constructorPc === 0) {\n    const error = {\n      kind: \"DeployedFunctionInConstructorError\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: 0\n    };\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n  //otherwise, we get our function\n  const pc = info.currentContext.isConstructor ? constructorPc : deployedPc;\n  const functionEntry = info.internalFunctionsTable[pc];\n  if (!functionEntry) {\n    //if it's not zero and there's no entry... error!\n    const error = {\n      kind: \"NoSuchInternalFunctionError\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: constructorPc\n    };\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n  if (functionEntry.isDesignatedInvalid) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  }\n  const name = functionEntry.name;\n  const mutability = functionEntry.mutability;\n  const definedIn = Evm.Import.functionTableEntryToType(functionEntry); //may be null\n  const id = Evm.Import.makeInternalFunctionId(functionEntry);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      kind: \"function\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: constructorPc,\n      name,\n      id,\n      definedIn,\n      mutability\n    }\n  };\n}\nfunction checkPadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  const length = (0, allocate_1.byteLength)(dataType, userDefinedTypes);\n  const paddingType = getPaddingType(dataType, paddingMode);\n  if (paddingMode === \"permissive\") {\n    switch (dataType.typeClass) {\n      case \"bool\":\n      case \"enum\":\n      case \"function\":\n        //these three types are checked even in permissive mode\n        return checkPaddingDirect(bytes, length, paddingType);\n      default:\n        return true;\n    }\n  } else {\n    return checkPaddingDirect(bytes, length, paddingType);\n  }\n}\nfunction removePadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  const length = (0, allocate_1.byteLength)(dataType, userDefinedTypes);\n  const paddingType = getPaddingType(dataType, paddingMode);\n  return removePaddingDirect(bytes, length, paddingType);\n}\nfunction removePaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"right\":\n      return bytes.slice(0, length);\n    default:\n      return bytes.slice(-length);\n  }\n}\nfunction checkPaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"left\":\n      return checkPaddingLeft(bytes, length);\n    case \"right\":\n      return checkPaddingRight(bytes, length);\n    case \"signed\":\n      return checkPaddingSigned(bytes, length);\n    case \"signedOrLeft\":\n      return checkPaddingSigned(bytes, length) || checkPaddingLeft(bytes, length);\n  }\n}\nfunction getPaddingType(dataType, paddingMode) {\n  switch (paddingMode) {\n    case \"right\":\n      return \"right\";\n    case \"default\":\n    case \"permissive\":\n      return defaultPaddingType(dataType);\n    case \"zero\":\n      {\n        const defaultType = defaultPaddingType(dataType);\n        return defaultType === \"signed\" ? \"left\" : defaultType;\n      }\n    case \"defaultOrZero\":\n      {\n        const defaultType = defaultPaddingType(dataType);\n        return defaultType === \"signed\" ? \"signedOrLeft\" : defaultType;\n      }\n  }\n}\nfunction defaultPaddingType(dataType) {\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      return \"right\";\n    case \"int\":\n    case \"fixed\":\n      return \"signed\";\n    case \"function\":\n      if (dataType.visibility === \"external\") {\n        return \"right\";\n      }\n    //otherwise, fall through to default\n    default:\n      return \"left\";\n  }\n}\nfunction checkPaddingRight(bytes, length) {\n  let padding = bytes.slice(length); //cut off the first length bytes\n  return padding.every(paddingByte => paddingByte === 0);\n}\n//exporting this one for use in stack.ts\nfunction checkPaddingLeft(bytes, length) {\n  let padding = bytes.slice(0, -length); //cut off the last length bytes\n  return padding.every(paddingByte => paddingByte === 0);\n}\nexports.checkPaddingLeft = checkPaddingLeft;\nfunction checkPaddingSigned(bytes, length) {\n  let padding = bytes.slice(0, -length); //padding is all but the last length bytes\n  let value = bytes.slice(-length); //meanwhile the actual value is those last length bytes\n  let signByte = value[0] & 0x80 ? 0xff : 0x00;\n  return padding.every(paddingByte => paddingByte === signByte);\n}","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","read_1","Conversion","__importStar","Format","Contexts","Evm","errors_1","allocate_1","decodeBasic","dataType","pointer","info","options","arguments","length","undefined","state","strictAbiMode","strict","paddingMode","bytes","rawBytes","error","handleDecodingError","typeClass","fullType","Types","userDefinedTypes","underlyingType","kind","type","allowRetry","StopDecodingError","underlyingResult","value","checkPadding","paddingType","getPaddingType","raw","toHexString","removePadding","numeric","toBN","eqn","asBoolean","rawAsBN","asBN","toSignedBN","asAddress","Utils","toAddress","rawAsHex","contractValueInfo","decodeContract","coercedDataType","asHex","visibility","address","slice","ADDRESS_SIZE","selector","SELECTOR_SIZE","decodeExternalFunction","deployedPc","PC_SIZE","constructorPc","decodeInternalFunction","numOptions","numBytes","Math","ceil","log2","checkPaddingDirect","removePaddingDirect","ltn","name","toNumber","numericAsBN","asBig","shiftBigDown","toBig","places","rawAsBig","exports","addressBytes","decodeContractAndContext","contractInfo","rawAddress","codeBytes","code","context","findContext","contexts","class","Import","contextToType","selectorBytes","contract","abiEntry","abi","deployedPcBytes","constructorPcBytes","currentContext","internalFunctionsTable","deployedProgramCounter","constructorProgramCounter","isConstructor","pc","functionEntry","isDesignatedInvalid","mutability","definedIn","functionTableEntryToType","id","makeInternalFunctionId","byteLength","checkPaddingLeft","checkPaddingRight","checkPaddingSigned","defaultPaddingType","defaultType","padding","every","paddingByte","signByte"],"sources":["../../../../lib/basic/decode/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}