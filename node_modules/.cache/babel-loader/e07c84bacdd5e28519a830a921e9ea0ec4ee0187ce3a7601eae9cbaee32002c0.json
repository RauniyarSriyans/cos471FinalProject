{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.indexToFloat = exports.floatToIndex = exports.decomposeFloat = exports.EPSILON_32 = exports.MAX_VALUE_32 = exports.MIN_VALUE_32 = void 0;\nexports.MIN_VALUE_32 = 2 ** -126 * 2 ** -23;\nexports.MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);\nexports.EPSILON_32 = 2 ** -23;\nconst INDEX_POSITIVE_INFINITY = 2139095040;\nconst INDEX_NEGATIVE_INFINITY = -2139095041;\nfunction decomposeFloat(f) {\n  const maxSignificand = 1 + (2 ** 23 - 1) / 2 ** 23;\n  for (let exponent = -126; exponent !== 128; ++exponent) {\n    const powExponent = 2 ** exponent;\n    const maxForExponent = maxSignificand * powExponent;\n    if (Math.abs(f) <= maxForExponent) {\n      return {\n        exponent,\n        significand: f / powExponent\n      };\n    }\n  }\n  return {\n    exponent: Number.NaN,\n    significand: Number.NaN\n  };\n}\nexports.decomposeFloat = decomposeFloat;\nfunction indexInFloatFromDecomp(exponent, significand) {\n  if (exponent === -126) {\n    return significand * 0x800000;\n  }\n  return (exponent + 127) * 0x800000 + (significand - 1) * 0x800000;\n}\nfunction floatToIndex(f) {\n  if (f === Number.POSITIVE_INFINITY) {\n    return INDEX_POSITIVE_INFINITY;\n  }\n  if (f === Number.NEGATIVE_INFINITY) {\n    return INDEX_NEGATIVE_INFINITY;\n  }\n  const decomp = decomposeFloat(f);\n  const exponent = decomp.exponent;\n  const significand = decomp.significand;\n  if (Number.isNaN(exponent) || Number.isNaN(significand) || !Number.isInteger(significand * 0x800000)) {\n    return Number.NaN;\n  }\n  if (f > 0 || f === 0 && 1 / f === Number.POSITIVE_INFINITY) {\n    return indexInFloatFromDecomp(exponent, significand);\n  } else {\n    return -indexInFloatFromDecomp(exponent, -significand) - 1;\n  }\n}\nexports.floatToIndex = floatToIndex;\nfunction indexToFloat(index) {\n  if (index < 0) {\n    return -indexToFloat(-index - 1);\n  }\n  if (index === INDEX_POSITIVE_INFINITY) {\n    return Number.POSITIVE_INFINITY;\n  }\n  if (index < 0x1000000) {\n    return index * 2 ** -149;\n  }\n  const postIndex = index - 0x1000000;\n  const exponent = -125 + (postIndex >> 23);\n  const significand = 1 + (postIndex & 0x7fffff) / 0x800000;\n  return significand * 2 ** exponent;\n}\nexports.indexToFloat = indexToFloat;","map":{"version":3,"names":["Object","defineProperty","exports","value","indexToFloat","floatToIndex","decomposeFloat","EPSILON_32","MAX_VALUE_32","MIN_VALUE_32","INDEX_POSITIVE_INFINITY","INDEX_NEGATIVE_INFINITY","f","maxSignificand","exponent","powExponent","maxForExponent","Math","abs","significand","Number","NaN","indexInFloatFromDecomp","POSITIVE_INFINITY","NEGATIVE_INFINITY","decomp","isNaN","isInteger","index","postIndex"],"sources":["/Users/karimelbarbary/Desktop/test4/devote/node_modules/fast-check/lib/arbitrary/_internals/helpers/FloatHelpers.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.indexToFloat = exports.floatToIndex = exports.decomposeFloat = exports.EPSILON_32 = exports.MAX_VALUE_32 = exports.MIN_VALUE_32 = void 0;\nexports.MIN_VALUE_32 = 2 ** -126 * 2 ** -23;\nexports.MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);\nexports.EPSILON_32 = 2 ** -23;\nconst INDEX_POSITIVE_INFINITY = 2139095040;\nconst INDEX_NEGATIVE_INFINITY = -2139095041;\nfunction decomposeFloat(f) {\n    const maxSignificand = 1 + (2 ** 23 - 1) / 2 ** 23;\n    for (let exponent = -126; exponent !== 128; ++exponent) {\n        const powExponent = 2 ** exponent;\n        const maxForExponent = maxSignificand * powExponent;\n        if (Math.abs(f) <= maxForExponent) {\n            return { exponent, significand: f / powExponent };\n        }\n    }\n    return { exponent: Number.NaN, significand: Number.NaN };\n}\nexports.decomposeFloat = decomposeFloat;\nfunction indexInFloatFromDecomp(exponent, significand) {\n    if (exponent === -126) {\n        return significand * 0x800000;\n    }\n    return (exponent + 127) * 0x800000 + (significand - 1) * 0x800000;\n}\nfunction floatToIndex(f) {\n    if (f === Number.POSITIVE_INFINITY) {\n        return INDEX_POSITIVE_INFINITY;\n    }\n    if (f === Number.NEGATIVE_INFINITY) {\n        return INDEX_NEGATIVE_INFINITY;\n    }\n    const decomp = decomposeFloat(f);\n    const exponent = decomp.exponent;\n    const significand = decomp.significand;\n    if (Number.isNaN(exponent) || Number.isNaN(significand) || !Number.isInteger(significand * 0x800000)) {\n        return Number.NaN;\n    }\n    if (f > 0 || (f === 0 && 1 / f === Number.POSITIVE_INFINITY)) {\n        return indexInFloatFromDecomp(exponent, significand);\n    }\n    else {\n        return -indexInFloatFromDecomp(exponent, -significand) - 1;\n    }\n}\nexports.floatToIndex = floatToIndex;\nfunction indexToFloat(index) {\n    if (index < 0) {\n        return -indexToFloat(-index - 1);\n    }\n    if (index === INDEX_POSITIVE_INFINITY) {\n        return Number.POSITIVE_INFINITY;\n    }\n    if (index < 0x1000000) {\n        return index * 2 ** -149;\n    }\n    const postIndex = index - 0x1000000;\n    const exponent = -125 + (postIndex >> 23);\n    const significand = 1 + (postIndex & 0x7fffff) / 0x800000;\n    return significand * 2 ** exponent;\n}\nexports.indexToFloat = indexToFloat;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}