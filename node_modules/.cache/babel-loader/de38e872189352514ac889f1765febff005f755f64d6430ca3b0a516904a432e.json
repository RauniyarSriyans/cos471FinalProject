{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nativizeAccessList = exports.unsafeNativize = exports.unsafeNativizeVariables = exports.ResultInspector = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:format:utils:inspect\");\nconst util_1 = __importDefault(require(\"util\"));\nconst Format = __importStar(require(\"../common\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst EvmUtils = __importStar(require(\"../../evm/utils\"));\nconst Exception = __importStar(require(\"./exception\"));\n//HACK?\nfunction cleanStylize(options) {\n  const clonedOptions = Object.assign({}, options);\n  delete clonedOptions.stylize;\n  return clonedOptions;\n}\n/**\n * This class is meant to be used with Node's\n * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)\n * function.  Given a [[Format.Values.Result]] `value`, one can use\n * `new ResultInspector(value)` to create a ResultInspector for that value,\n * which can be used with util.inspect() to create a human-readable string\n * representing the value.\n *\n * @example\n * Suppose `value` is a Result.  In Node, the following would print to the\n * console a human-readable representation of `value`, with colors enabled,\n * no maximum depth, and no maximum array length, and lines (usually) no\n * longer than 80 characters:\n * ```javascript\n * console.log(\n *   util.inspect(\n *     new ResultInspector(value),\n *     {\n *       colors: true,\n *       depth: null,\n *       maxArrayLength: null,\n *       breakLength: 80\n *     }\n *   )\n * );\n * ```\n * Of course, there are many other ways to use util.inspect; see Node's\n * documentation, linked above, for more.\n */\nclass ResultInspector {\n  constructor(result) {\n    this.result = result;\n  }\n  /**\n   * @dev non-standard alternative interface name used by browser-util-inspect\n   *      package\n   */\n  inspect(depth, options) {\n    return this[util_1.default.inspect.custom].bind(this)(depth, options);\n  }\n  [util_1.default.inspect.custom](depth, options) {\n    switch (this.result.kind) {\n      case \"value\":\n        switch (this.result.type.typeClass) {\n          case \"uint\":\n          case \"int\":\n            return options.stylize(this.result.value.asBN.toString(), \"number\");\n          case \"fixed\":\n          case \"ufixed\":\n            //note: because this is just for display, we don't bother adjusting the magic values Big.NE or Big.PE;\n            //we'll trust those to their defaults\n            return options.stylize(this.result.value.asBig.toString(), \"number\");\n          case \"bool\":\n            return util_1.default.inspect(this.result.value.asBoolean, options);\n          case \"bytes\":\n            let hex = this.result.value.asHex;\n            switch (this.result.type.kind) {\n              case \"static\":\n                return options.stylize(hex, \"number\");\n              case \"dynamic\":\n                return options.stylize(`hex'${hex.slice(2)}'`, \"string\");\n            }\n          case \"address\":\n            return options.stylize(this.result.value.asAddress, \"number\");\n          case \"string\":\n            {\n              let coercedResult = this.result;\n              switch (coercedResult.value.kind) {\n                case \"valid\":\n                  return util_1.default.inspect(coercedResult.value.asString, options);\n                case \"malformed\":\n                  //note: this will turn malformed utf-8 into replacement characters (U+FFFD)\n                  //note we need to cut off the 0x prefix\n                  return util_1.default.inspect(Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString());\n              }\n            }\n          case \"array\":\n            {\n              let coercedResult = this.result;\n              if (coercedResult.reference !== undefined) {\n                return formatCircular(coercedResult.reference, options);\n              }\n              return util_1.default.inspect(coercedResult.value.map(element => new ResultInspector(element)), options);\n            }\n          case \"mapping\":\n            return util_1.default.inspect(new Map(this.result.value.map(_ref => {\n              let {\n                key,\n                value\n              } = _ref;\n              return [new ResultInspector(key), new ResultInspector(value)];\n            })), options);\n          case \"struct\":\n            {\n              let coercedResult = this.result;\n              if (coercedResult.reference !== undefined) {\n                return formatCircular(coercedResult.reference, options);\n              }\n              return util_1.default.inspect(Object.assign({}, ...coercedResult.value.map(_ref2 => {\n                let {\n                  name,\n                  value\n                } = _ref2;\n                return {\n                  [name]: new ResultInspector(value)\n                };\n              })), options);\n            }\n          case \"userDefinedValueType\":\n            {\n              const typeName = Format.Types.typeStringWithoutLocation(this.result.type);\n              const coercedResult = this.result;\n              const inspectOfUnderlying = util_1.default.inspect(new ResultInspector(coercedResult.value), options);\n              return `${typeName}.wrap(${inspectOfUnderlying})`; //note only the underlying part is stylized\n            }\n\n          case \"tuple\":\n            {\n              let coercedResult = this.result;\n              //if everything is named, do same as with struct.\n              //if not, just do an array.\n              //(good behavior in the mixed case is hard, unfortunately)\n              if (coercedResult.value.every(_ref3 => {\n                let {\n                  name\n                } = _ref3;\n                return name;\n              })) {\n                return util_1.default.inspect(Object.assign({}, ...coercedResult.value.map(_ref4 => {\n                  let {\n                    name,\n                    value\n                  } = _ref4;\n                  return {\n                    [name]: new ResultInspector(value)\n                  };\n                })), options);\n              } else {\n                return util_1.default.inspect(coercedResult.value.map(_ref5 => {\n                  let {\n                    value\n                  } = _ref5;\n                  return new ResultInspector(value);\n                }), options);\n              }\n            }\n          case \"type\":\n            {\n              switch (this.result.type.type.typeClass) {\n                case \"contract\":\n                  //same as struct case but w/o circularity check\n                  return util_1.default.inspect(Object.assign({}, ...this.result.value.map(_ref6 => {\n                    let {\n                      name,\n                      value\n                    } = _ref6;\n                    return {\n                      [name]: new ResultInspector(value)\n                    };\n                  })), options);\n                case \"enum\":\n                  {\n                    return enumTypeName(this.result.type.type);\n                  }\n              }\n            }\n          case \"magic\":\n            return util_1.default.inspect(Object.assign({}, ...Object.entries(this.result.value).map(_ref7 => {\n              let [key, value] = _ref7;\n              return {\n                [key]: new ResultInspector(value)\n              };\n            })), options);\n          case \"enum\":\n            {\n              return enumFullName(this.result); //not stylized\n            }\n\n          case \"contract\":\n            {\n              return util_1.default.inspect(new ContractInfoInspector(this.result.value), options);\n            }\n          case \"function\":\n            switch (this.result.type.visibility) {\n              case \"external\":\n                {\n                  let coercedResult = this.result;\n                  let contractString = util_1.default.inspect(new ContractInfoInspector(coercedResult.value.contract), Object.assign(Object.assign({}, cleanStylize(options)), {\n                    colors: false\n                  }));\n                  let firstLine;\n                  switch (coercedResult.value.kind) {\n                    case \"known\":\n                      firstLine = `[Function: ${coercedResult.value.abi.name} of`;\n                      break;\n                    case \"invalid\":\n                    case \"unknown\":\n                      firstLine = `[Function: Unknown selector ${coercedResult.value.selector} of`;\n                      break;\n                  }\n                  let secondLine = `${contractString}]`;\n                  let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength ? \"\\n\" : \" \";\n                  //now, put it together\n                  return options.stylize(firstLine + breakingSpace + secondLine, \"special\");\n                }\n              case \"internal\":\n                {\n                  let coercedResult = this.result;\n                  switch (coercedResult.value.kind) {\n                    case \"function\":\n                      if (coercedResult.value.definedIn) {\n                        return options.stylize(`[Function: ${coercedResult.value.definedIn.typeName}.${coercedResult.value.name}]`, \"special\");\n                      } else {\n                        return options.stylize(`[Function: ${coercedResult.value.name}]`, \"special\");\n                      }\n                    case \"exception\":\n                      return coercedResult.value.deployedProgramCounter === 0 ? options.stylize(`[Function: <zero>]`, \"special\") : options.stylize(`[Function: <uninitialized>]`, \"special\");\n                    case \"unknown\":\n                      let firstLine = `[Function: decoding not supported (raw info:`;\n                      let secondLine = `deployed PC=${coercedResult.value.deployedProgramCounter}, constructor PC=${coercedResult.value.constructorProgramCounter})]`;\n                      let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength ? \"\\n\" : \" \";\n                      //now, put it together\n                      return options.stylize(firstLine + breakingSpace + secondLine, \"special\");\n                  }\n                }\n            }\n        }\n      case \"error\":\n        {\n          debug(\"this.result: %O\", this.result);\n          let errorResult = this.result; //the hell?? why couldn't it make this inference??\n          switch (errorResult.error.kind) {\n            case \"WrappedError\":\n              return util_1.default.inspect(new ResultInspector(errorResult.error.error), options);\n            case \"UintPaddingError\":\n              return `Uint has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n            case \"IntPaddingError\":\n              return `Int has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n            case \"UintPaddingError\":\n              return `Ufixed has (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n            case \"FixedPaddingError\":\n              return `Fixed has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n            case \"BoolOutOfRangeError\":\n              return `Invalid boolean (numeric value ${errorResult.error.rawAsBN.toString()})`;\n            case \"BoolPaddingError\":\n              return `Boolean has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n            case \"BytesPaddingError\":\n              return `Bytestring has extra trailing bytes (padding error) (raw value ${errorResult.error.raw})`;\n            case \"AddressPaddingError\":\n              return `Address has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n            case \"EnumOutOfRangeError\":\n              return `Invalid ${enumTypeName(errorResult.error.type)} (numeric value ${errorResult.error.rawAsBN.toString()})`;\n            case \"EnumPaddingError\":\n              return `Enum ${enumTypeName(errorResult.error.type)} has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n            case \"EnumNotFoundDecodingError\":\n              return `Unknown enum type ${enumTypeName(errorResult.error.type)} of id ${errorResult.error.type.id} (numeric value ${errorResult.error.rawAsBN.toString()})`;\n            case \"ContractPaddingError\":\n              return `Contract address has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n            case \"FunctionExternalNonStackPaddingError\":\n              return `External function has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n            case \"FunctionExternalStackPaddingError\":\n              return `External function address or selector has extra leading bytes (padding error) (raw address ${errorResult.error.rawAddress}, raw selector ${errorResult.error.rawSelector})`;\n            case \"FunctionInternalPaddingError\":\n              return `Internal function has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n            case \"NoSuchInternalFunctionError\":\n              return `Invalid function (Deployed PC=${errorResult.error.deployedProgramCounter}, constructor PC=${errorResult.error.constructorProgramCounter}) of contract ${errorResult.error.context.typeName}`;\n            case \"DeployedFunctionInConstructorError\":\n              return `Deployed-style function (PC=${errorResult.error.deployedProgramCounter}) in constructor`;\n            case \"MalformedInternalFunctionError\":\n              return `Malformed internal function w/constructor PC only (value: ${errorResult.error.constructorProgramCounter})`;\n            case \"IndexedReferenceTypeError\":\n              //for this one we'll bother with some line-wrapping\n              let firstLine = `Cannot decode indexed parameter of reference type ${errorResult.error.type.typeClass}`;\n              let secondLine = `(raw value ${errorResult.error.raw})`;\n              let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength ? \"\\n\" : \" \";\n              return firstLine + breakingSpace + secondLine;\n            case \"OverlongArraysAndStringsNotImplementedError\":\n              return `Array or string is too long (length ${errorResult.error.lengthAsBN.toString()}); decoding is not supported`;\n            case \"OverlargePointersNotImplementedError\":\n              return `Pointer is too large (value ${errorResult.error.pointerAsBN.toString()}); decoding is not supported`;\n            case \"UserDefinedTypeNotFoundError\":\n            case \"UnsupportedConstantError\":\n            case \"UnusedImmutableError\":\n            case \"ReadErrorStack\":\n            case \"ReadErrorStorage\":\n            case \"ReadErrorBytes\":\n              return Exception.message(errorResult.error);\n            //yay, these five are already defined!\n            case \"StorageNotSuppliedError\":\n            case \"CodeNotSuppliedError\":\n              //this latter one is not used at present\n              //these ones have a message, but we're going to special-case it\n              return options.stylize(\"?\", \"undefined\");\n          }\n        }\n    }\n  }\n}\nexports.ResultInspector = ResultInspector;\n//these get their own class to deal with a minor complication\nclass ContractInfoInspector {\n  constructor(value) {\n    this.value = value;\n  }\n  /**\n   * @dev non-standard alternative interface name used by browser-util-inspect\n   *      package\n   */\n  inspect(depth, options) {\n    return this[util_1.default.inspect.custom].bind(this)(depth, options);\n  }\n  [util_1.default.inspect.custom](depth, options) {\n    switch (this.value.kind) {\n      case \"known\":\n        return options.stylize(this.value.address, \"number\") + ` (${this.value.class.typeName})`;\n      case \"unknown\":\n        return options.stylize(this.value.address, \"number\") + \" of unknown class\";\n    }\n  }\n}\nfunction enumTypeName(enumType) {\n  return (enumType.kind === \"local\" ? enumType.definingContractName + \".\" : \"\") + enumType.typeName;\n}\n//this function will be used in the future for displaying circular\n//structures\nfunction formatCircular(loopLength, options) {\n  return options.stylize(`[Circular (=up ${loopLength})]`, \"special\");\n}\nfunction enumFullName(value) {\n  switch (value.type.kind) {\n    case \"local\":\n      return `${value.type.definingContractName}.${value.type.typeName}.${value.value.name}`;\n    case \"global\":\n      return `${value.type.typeName}.${value.value.name}`;\n  }\n}\n/**\n * WARNING! Do NOT use this function in real code unless you\n * absolutely have to!  Using it in controlled tests is fine,\n * but do NOT use it in real code if you have any better option!\n * See [[unsafeNativize]] for why!\n */\nfunction unsafeNativizeVariables(variables) {\n  return Object.assign({}, ...Object.entries(variables).map(_ref8 => {\n    let [name, value] = _ref8;\n    try {\n      return {\n        [name]: unsafeNativize(value)\n      };\n    } catch (_) {\n      return undefined; //I guess??\n    }\n  }));\n}\n\nexports.unsafeNativizeVariables = unsafeNativizeVariables;\n//HACK! Avoid using!\n/**\n * WARNING! Do NOT use this function in real code unless you absolutely have\n * to!  Using it in controlled tests is fine, but do NOT use it in real code if\n * you have any better option!\n *\n * This function is a giant hack.  It will throw exceptions on numbers that\n * don't fit in a Javascript number.  It loses various information.  It was\n * only ever written to support our hacked-together watch expression system,\n * and later repurposed to make testing easier.\n *\n * If you are not doing something as horrible as evaluating user-inputted\n * Javascript expressions meant to operate upon Solidity variables, then you\n * probably have a better option than using this in real code!\n *\n * (For instance, if you just want to nicely print individual values, without\n * attempting to first operate on them via Javascript expressions, we have the\n * [[ResultInspector]] class, which can be used with Node's\n * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)\n * to do exactly that.)\n *\n * Remember, the decoder output format was made to be machine-readable.  It\n * shouldn't be too hard for you to process.  If it comes to it, copy-paste\n * this code and dehackify it for your use case, which hopefully is more\n * manageable than the one that caused us to write this.\n */\nfunction unsafeNativize(result) {\n  return unsafeNativizeWithTable(result, []);\n}\nexports.unsafeNativize = unsafeNativize;\nfunction unsafeNativizeWithTable(result, seenSoFar) {\n  if (result.kind === \"error\") {\n    debug(\"ErrorResult: %O\", result);\n    switch (result.error.kind) {\n      case \"BoolOutOfRangeError\":\n        return true;\n      default:\n        return undefined;\n    }\n  }\n  //NOTE: for simplicity, only arrays & structs will call unsafeNativizeWithTable;\n  //other containers will just call unsafeNativize because they can get away with it\n  //(only things that can *be* circular need unsafeNativizeWithTable, not things that\n  //can merely *contain* circularities)\n  switch (result.type.typeClass) {\n    case \"uint\":\n    case \"int\":\n      return result.value.asBN.toNumber();\n    //WARNING\n    case \"bool\":\n      return result.value.asBoolean;\n    case \"bytes\":\n      return result.value.asHex;\n    case \"address\":\n      return result.value.asAddress;\n    case \"string\":\n      {\n        let coercedResult = result;\n        switch (coercedResult.value.kind) {\n          case \"valid\":\n            return coercedResult.value.asString;\n          case \"malformed\":\n            // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)\n            // note we need to cut off the 0x prefix\n            return Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString();\n        }\n      }\n    case \"fixed\":\n    case \"ufixed\":\n      //HACK: Big doesn't have a toNumber() method, so we convert to string and then parse with Number\n      //NOTE: we don't bother setting the magic variables Big.NE or Big.PE first, as the choice of\n      //notation shouldn't affect the result (can you believe I have to write this? @_@)\n      return Number(result.value.asBig.toString());\n    //WARNING\n    case \"array\":\n      {\n        let coercedResult = result;\n        if (coercedResult.reference === undefined) {\n          //we need to do some pointer stuff here, so let's first create our new\n          //object we'll be pointing to\n          //[we don't want to alter the original accidentally so let's clone a bit]\n          let output = [...coercedResult.value];\n          //now, we can't use a map here, or we'll screw things up!\n          //we want to *mutate* output, not replace it with a new object\n          for (let index = 0; index < output.length; index++) {\n            output[index] = unsafeNativizeWithTable(output[index], [output, ...seenSoFar]);\n          }\n          return output;\n        } else {\n          return seenSoFar[coercedResult.reference - 1];\n        }\n      }\n    case \"userDefinedValueType\":\n      {\n        return unsafeNativize(result.value);\n      }\n    case \"mapping\":\n      return Object.assign({}, ...result.value.map(_ref9 => {\n        let {\n          key,\n          value\n        } = _ref9;\n        return {\n          [unsafeNativize(key).toString()]: unsafeNativize(value)\n        };\n      }));\n    case \"struct\":\n      {\n        let coercedResult = result;\n        if (coercedResult.reference === undefined) {\n          //we need to do some pointer stuff here, so let's first create our new\n          //object we'll be pointing to\n          let output = Object.assign({}, ...result.value.map(_ref10 => {\n            let {\n              name,\n              value\n            } = _ref10;\n            return {\n              [name]: value //we *don't* nativize yet!\n            };\n          }));\n          //now, we can't use a map here, or we'll screw things up!\n          //we want to *mutate* output, not replace it with a new object\n          for (let name in output) {\n            output[name] = unsafeNativizeWithTable(output[name], [output, ...seenSoFar]);\n          }\n          return output;\n        } else {\n          return seenSoFar[coercedResult.reference - 1];\n        }\n      }\n    case \"type\":\n      switch (result.type.type.typeClass) {\n        case \"contract\":\n          return Object.assign({}, ...result.value.map(_ref11 => {\n            let {\n              name,\n              value\n            } = _ref11;\n            return {\n              [name]: unsafeNativize(value)\n            };\n          }));\n        case \"enum\":\n          return Object.assign({}, ...result.value.map(enumValue => ({\n            [enumValue.value.name]: unsafeNativize(enumValue)\n          })));\n      }\n    case \"tuple\":\n      return result.value.map(_ref12 => {\n        let {\n          value\n        } = _ref12;\n        return unsafeNativize(value);\n      });\n    case \"magic\":\n      return Object.assign({}, ...Object.entries(result.value).map(_ref13 => {\n        let [key, value] = _ref13;\n        return {\n          [key]: unsafeNativize(value)\n        };\n      }));\n    case \"enum\":\n      return enumFullName(result);\n    case \"contract\":\n      return result.value.address;\n    //we no longer include additional info\n    case \"function\":\n      switch (result.type.visibility) {\n        case \"external\":\n          {\n            let coercedResult = result;\n            switch (coercedResult.value.kind) {\n              case \"known\":\n                return `${coercedResult.value.contract.class.typeName}(${coercedResult.value.contract.address}).${coercedResult.value.abi.name}`;\n              case \"invalid\":\n                return `${coercedResult.value.contract.class.typeName}(${coercedResult.value.contract.address}).call(${coercedResult.value.selector}...)`;\n              case \"unknown\":\n                return `${coercedResult.value.contract.address}.call(${coercedResult.value.selector}...)`;\n            }\n          }\n        case \"internal\":\n          {\n            let coercedResult = result;\n            switch (coercedResult.value.kind) {\n              case \"function\":\n                if (coercedResult.value.definedIn) {\n                  return `${coercedResult.value.definedIn.typeName}.${coercedResult.value.name}`;\n                } else {\n                  return coercedResult.value.name;\n                }\n              case \"exception\":\n                return coercedResult.value.deployedProgramCounter === 0 ? `<zero>` : `<uninitialized>`;\n              case \"unknown\":\n                return `<decoding not supported>`;\n            }\n          }\n      }\n  }\n}\n/**\n * Turns a wrapped access list into a usable form.\n * Will fail if the input is not a wrapped access list!\n * Note that the storage keys must be given as uint256, not bytes32.\n * Primarily meant for internal use.\n */\nfunction nativizeAccessList(wrappedAccessList //this should really be a more specific type\n) {\n  return wrappedAccessList.value.map(wrappedAccessListForAddress => {\n    //HACK: we're just going to coerce all over the place here\n    const addressStorageKeysPair = wrappedAccessListForAddress.value;\n    const wrappedAddress = addressStorageKeysPair[0].value;\n    const wrappedStorageKeys = addressStorageKeysPair[1].value;\n    const wrappedStorageKeysArray = wrappedStorageKeys.value;\n    return {\n      address: wrappedAddress.value.asAddress,\n      storageKeys: wrappedStorageKeysArray.map(wrappedStorageKey => Conversion.toHexString(wrappedStorageKey.value.asBN, EvmUtils.WORD_SIZE))\n    };\n  });\n}\nexports.nativizeAccessList = nativizeAccessList;","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","util_1","Format","__importStar","Conversion","EvmUtils","Exception","cleanStylize","options","clonedOptions","Object","assign","stylize","ResultInspector","constructor","result","inspect","depth","custom","bind","kind","type","typeClass","value","asBN","toString","asBig","asBoolean","hex","asHex","slice","asAddress","coercedResult","asString","Buffer","from","reference","undefined","formatCircular","map","element","Map","_ref","key","_ref2","name","typeName","Types","typeStringWithoutLocation","inspectOfUnderlying","every","_ref3","_ref4","_ref5","_ref6","enumTypeName","entries","_ref7","enumFullName","ContractInfoInspector","visibility","contractString","contract","colors","firstLine","abi","selector","secondLine","breakingSpace","length","breakLength","definedIn","deployedProgramCounter","constructorProgramCounter","errorResult","error","paddingType","raw","rawAsBN","id","rawAddress","rawSelector","context","lengthAsBN","pointerAsBN","message","exports","address","class","enumType","definingContractName","loopLength","unsafeNativizeVariables","variables","_ref8","unsafeNativize","_","unsafeNativizeWithTable","seenSoFar","toNumber","Number","output","index","_ref9","_ref10","_ref11","enumValue","_ref12","_ref13","nativizeAccessList","wrappedAccessList","wrappedAccessListForAddress","addressStorageKeysPair","wrappedAddress","wrappedStorageKeys","wrappedStorageKeysArray","storageKeys","wrappedStorageKey","toHexString","WORD_SIZE"],"sources":["../../../../lib/format/utils/inspect.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}