{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeRevert = exports.decodeReturndata = exports.decodeEvent = exports.decodeCalldata = exports.decodeVariable = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:core\");\nconst Ast = __importStar(require(\"./ast\"));\nconst AbiData = __importStar(require(\"./abi-data\"));\nconst Topic = __importStar(require(\"./topic\"));\nconst Evm = __importStar(require(\"./evm\"));\nconst Contexts = __importStar(require(\"./contexts\"));\nconst abify_1 = require(\"./abify\");\nconst Conversion = __importStar(require(\"./conversion\"));\nconst errors_1 = require(\"./errors\");\nconst read_1 = __importDefault(require(\"./read\"));\nconst decode_1 = __importDefault(require(\"./decode\"));\nconst web3_utils_1 = __importDefault(require(\"web3-utils\"));\n/**\n * @Category Decoding\n */\nfunction* decodeVariable(definition, pointer, info, compilationId) {\n  let compiler = info.currentContext.compiler;\n  let dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n  return yield* (0, decode_1.default)(dataType, pointer, info); //no need to pass an offset\n}\n\nexports.decodeVariable = decodeVariable;\n/**\n * @Category Decoding\n */\nfunction* decodeCalldata(info, isConstructor //ignored if context! trust context instead if have\n) {\n  const context = info.currentContext;\n  if (context === null) {\n    //if we don't know the contract ID, we can't decode\n    if (isConstructor) {\n      return {\n        kind: \"create\",\n        decodingMode: \"full\",\n        bytecode: Conversion.toHexString(info.state.calldata),\n        interpretations: {}\n      };\n    } else {\n      return {\n        kind: \"unknown\",\n        decodingMode: \"full\",\n        data: Conversion.toHexString(info.state.calldata),\n        interpretations: {}\n      };\n    }\n  }\n  const contextHash = context.context;\n  const contractType = Contexts.Import.contextToType(context);\n  isConstructor = context.isConstructor;\n  const allocations = info.allocations.calldata;\n  let allocation;\n  let selector;\n  //first: is this a creation call?\n  if (isConstructor) {\n    allocation = (allocations.constructorAllocations[contextHash] || {\n      input: undefined\n    }).input;\n  } else {\n    //skipping any error-handling on this read, as a calldata read can't throw anyway\n    let rawSelector = yield* (0, read_1.default)({\n      location: \"calldata\",\n      start: 0,\n      length: Evm.Utils.SELECTOR_SIZE\n    }, info.state);\n    selector = Conversion.toHexString(rawSelector);\n    allocation = ((allocations.functionAllocations[contextHash] || {})[selector] || {\n      input: undefined\n    }).input;\n  }\n  if (allocation === undefined) {\n    let abiEntry = null;\n    if (info.state.calldata.length === 0) {\n      //to hell with reads, let's just be direct\n      abiEntry = context.fallbackAbi.receive || context.fallbackAbi.fallback;\n    } else {\n      abiEntry = context.fallbackAbi.fallback;\n    }\n    return {\n      kind: \"message\",\n      class: contractType,\n      abi: abiEntry,\n      data: Conversion.toHexString(info.state.calldata),\n      decodingMode: \"full\",\n      interpretations: {}\n    };\n  }\n  let decodingMode = allocation.allocationMode; //starts out this way, degrades to ABI if necessary\n  debug(\"calldata decoding mode: %s\", decodingMode);\n  //you can't map with a generator, so we have to do this map manually\n  let decodedArguments = [];\n  for (const argumentAllocation of allocation.arguments) {\n    let value;\n    let dataType = decodingMode === \"full\" ? argumentAllocation.type : (0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes);\n    try {\n      value = yield* (0, decode_1.default)(dataType, argumentAllocation.pointer, info, {\n        abiPointerBase: allocation.offset,\n        allowRetry: decodingMode === \"full\"\n      });\n    } catch (error) {\n      if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n        debug(\"problem! retrying as ABI\");\n        debug(\"error: %O\", error);\n        //if a retry happens, we've got to do several things in order to switch to ABI mode:\n        //1. mark that we're switching to ABI mode;\n        decodingMode = \"abi\";\n        //2. abify all previously decoded values;\n        decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n          value: (0, abify_1.abifyResult)(argumentDecoding.value, info.userDefinedTypes)\n        }));\n        //3. retry this particular decode in ABI mode.\n        //(no try/catch on this one because we can't actually handle errors here!\n        //not that they should be occurring)\n        value = yield* (0, decode_1.default)((0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes),\n        //type is now abified!\n        argumentAllocation.pointer, info, {\n          abiPointerBase: allocation.offset\n        });\n        //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n        //so we don't need to do anything special there.\n      } else {\n        //we shouldn't be getting other exceptions, but if we do, we don't know\n        //how to handle them, so uhhhh just rethrow I guess??\n        throw error;\n      }\n    }\n    const name = argumentAllocation.name;\n    decodedArguments.push(name //deliberate general falsiness test\n    ? {\n      name,\n      value\n    } : {\n      value\n    });\n  }\n  if (isConstructor) {\n    return {\n      kind: \"constructor\",\n      class: contractType,\n      arguments: decodedArguments,\n      abi: allocation.abi,\n      bytecode: Conversion.toHexString(info.state.calldata.slice(0, allocation.offset)),\n      decodingMode,\n      interpretations: {}\n    };\n  } else {\n    return {\n      kind: \"function\",\n      class: contractType,\n      abi: allocation.abi,\n      arguments: decodedArguments,\n      selector,\n      decodingMode,\n      interpretations: {}\n    };\n  }\n}\nexports.decodeCalldata = decodeCalldata;\n/**\n * @Category Decoding\n */\nfunction decodeEvent(info, address) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return function* () {\n    const allocations = info.allocations.event;\n    const extras = options.extras || \"off\";\n    let rawSelector;\n    let selector;\n    let contractAllocations; //for non-anonymous events\n    let libraryAllocations; //similar\n    let contractAnonymousAllocations;\n    let libraryAnonymousAllocations;\n    const topicsCount = info.state.eventtopics.length;\n    //yeah, it's not great to read directly from the state like this (bypassing read), but what are you gonna do?\n    if (allocations[topicsCount]) {\n      if (topicsCount > 0) {\n        rawSelector = yield* (0, read_1.default)({\n          location: \"eventtopic\",\n          topic: 0\n        }, info.state);\n        selector = Conversion.toHexString(rawSelector);\n        if (allocations[topicsCount].bySelector[selector]) {\n          ({\n            contract: contractAllocations,\n            library: libraryAllocations\n          } = allocations[topicsCount].bySelector[selector]);\n        } else {\n          debug(\"no allocations for that selector!\");\n          contractAllocations = {};\n          libraryAllocations = {};\n        }\n      } else {\n        //if we don't have a selector, it means we don't have any non-anonymous events\n        contractAllocations = {};\n        libraryAllocations = {};\n      }\n      //now: let's get our allocations for anonymous events\n      ({\n        contract: contractAnonymousAllocations,\n        library: libraryAnonymousAllocations\n      } = allocations[topicsCount].anonymous);\n    } else {\n      //if there's not even an allocation for the topics count, we can't\n      //decode; we could do this the honest way of setting all four allocation\n      //objects to {}, but let's just short circuit\n      debug(\"no allocations for that topic count!\");\n      return [];\n    }\n    let contractContext;\n    if (address !== null) {\n      //now: what contract are we (probably) dealing with? let's get its code to find out\n      const codeBytes = yield {\n        type: \"code\",\n        address\n      };\n      const codeAsHex = Conversion.toHexString(codeBytes);\n      contractContext = Contexts.Utils.findContext(info.contexts, codeAsHex);\n    } else {\n      contractContext = info.currentContext;\n    }\n    let possibleContractAllocations; //excludes anonymous events\n    let possibleContractAnonymousAllocations;\n    let possibleExtraAllocations; //excludes anonymous events\n    let possibleExtraAnonymousAllocations;\n    const emittingContextHash = (contractContext || {\n      context: undefined\n    }).context;\n    if (emittingContextHash) {\n      //if we found the contract, maybe it's from that contract\n      const contractAllocation = contractAllocations[emittingContextHash];\n      const contractAnonymousAllocation = contractAnonymousAllocations[emittingContextHash];\n      possibleContractAllocations = contractAllocation || [];\n      possibleContractAnonymousAllocations = contractAnonymousAllocation || [];\n      //also, we need to set up the extras (everything that's from a\n      //non-library contract but *not* this one)\n      possibleExtraAllocations = [].concat(...Object.entries(contractAllocations).filter(_ref => {\n        let [key, _] = _ref;\n        return key !== emittingContextHash;\n      }).map(_ref2 => {\n        let [_, value] = _ref2;\n        return value;\n      }));\n      possibleExtraAnonymousAllocations = [].concat(...Object.entries(contractAnonymousAllocations).filter(_ref3 => {\n        let [key, _] = _ref3;\n        return key !== emittingContextHash;\n      }).map(_ref4 => {\n        let [_, value] = _ref4;\n        return value;\n      }));\n    } else {\n      //if we couldn't determine the contract, well, we have to assume it's from a library\n      debug(\"couldn't find context\");\n      possibleContractAllocations = [];\n      possibleContractAnonymousAllocations = [];\n      //or it's an extra, which could be any of the contracts\n      possibleExtraAllocations = [].concat(...Object.values(contractAllocations));\n      possibleExtraAnonymousAllocations = [].concat(...Object.values(contractAnonymousAllocations));\n    }\n    //now we get all the library allocations!\n    const possibleLibraryAllocations = [].concat(...Object.values(libraryAllocations));\n    const possibleLibraryAnonymousAllocations = [].concat(...Object.values(libraryAnonymousAllocations));\n    //now we put it all together!\n    const possibleAllocations = possibleContractAllocations.concat(possibleLibraryAllocations);\n    const possibleAnonymousAllocations = possibleContractAnonymousAllocations.concat(possibleLibraryAnonymousAllocations);\n    const possibleAllocationsTotalMinusExtras = possibleAllocations.concat(possibleAnonymousAllocations);\n    //...and also there's the extras\n    const possibleExtraAllocationsTotal = possibleExtraAllocations.concat(possibleExtraAnonymousAllocations);\n    const possibleAllocationsTotal = possibleAllocationsTotalMinusExtras.concat([null],\n    //HACK: add sentinel value before the extras\n    possibleExtraAllocationsTotal);\n    //whew!\n    let decodings = [];\n    allocationAttempts: for (const allocation of possibleAllocationsTotal) {\n      debug(\"trying allocation: %O\", allocation);\n      //first: check for our sentinel value for extras (yeah, kind of HACKy)\n      if (allocation === null) {\n        switch (extras) {\n          case \"on\":\n            continue allocationAttempts;\n          //ignore the sentinel and continue\n          case \"off\":\n            break allocationAttempts;\n          //don't include extras; stop here\n          case \"necessary\":\n            //stop on the sentinel and exclude extras *unless* there are no decodings yet\n            if (decodings.length > 0) {\n              break allocationAttempts;\n            } else {\n              continue allocationAttempts;\n            }\n        }\n      }\n      //second: do a name check so we can skip decoding if name is wrong\n      //(this will likely be a more detailed check in the future)\n      if (options.name !== undefined && allocation.abi.name !== options.name) {\n        continue;\n      }\n      //now: the main part!\n      let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n      const contextHash = allocation.contextHash;\n      const attemptContext = info.contexts[contextHash];\n      const emittingContractType = Contexts.Import.contextToType(attemptContext);\n      const contractType = allocation.definedIn;\n      //you can't map with a generator, so we have to do this map manually\n      let decodedArguments = [];\n      for (const argumentAllocation of allocation.arguments) {\n        let value;\n        //if in full mode, use the allocation's listed data type.\n        //if in ABI mode, abify it before use.\n        let dataType = decodingMode === \"full\" ? argumentAllocation.type : (0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes);\n        try {\n          value = yield* (0, decode_1.default)(dataType, argumentAllocation.pointer, info, {\n            strictAbiMode: true,\n            allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n          });\n        } catch (error) {\n          if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n            //if a retry happens, we've got to do several things in order to switch to ABI mode:\n            //1. mark that we're switching to ABI mode;\n            decodingMode = \"abi\";\n            //2. abify all previously decoded values;\n            decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n              value: (0, abify_1.abifyResult)(argumentDecoding.value, info.userDefinedTypes)\n            }));\n            //3. retry this particular decode in ABI mode.\n            try {\n              value = yield* (0, decode_1.default)((0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes),\n              //type is now abified!\n              argumentAllocation.pointer, info, {\n                strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n                //retries no longer allowed, not that this has an effect\n              });\n            } catch (_) {\n              //if an error occurred on the retry, this isn't a valid decoding!\n              debug(\"rejected due to exception on retry\");\n              continue allocationAttempts;\n            }\n            //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n            //so we don't need to do anything special there.\n          } else {\n            //if any other sort of error occurred, this isn't a valid decoding!\n            debug(\"rejected due to exception on first try: %O\", error);\n            continue allocationAttempts;\n          }\n        }\n        const name = argumentAllocation.name;\n        const indexed = argumentAllocation.pointer.location === \"eventtopic\";\n        decodedArguments.push(name //deliberate general falsiness test\n        ? {\n          name,\n          indexed,\n          value\n        } : {\n          indexed,\n          value\n        });\n      }\n      if (!options.disableChecks) {\n        //OK, so, having decoded the result, the question is: does it reencode to the original?\n        //NOTE: we skip this check if disableChecks is passed! (it shouldn't be passed :P )\n        //first, we have to filter out the indexed arguments, and also get rid of the name information\n        const nonIndexedValues = decodedArguments.filter(argument => !argument.indexed).map(argument => argument.value);\n        //now, we can encode!\n        const reEncodedData = AbiData.Encode.encodeTupleAbi(nonIndexedValues, info.allocations.abi);\n        const encodedData = info.state.eventdata; //again, not great to read this directly, but oh well\n        //are they equal?\n        if (!Evm.Utils.equalData(reEncodedData, encodedData)) {\n          //if not, this allocation doesn't work\n          debug(\"rejected due to [non-indexed] mismatch\");\n          continue;\n        }\n      }\n      //one last check -- let's check that the indexed arguments match up, too\n      //(we won't skip this even if disableChecks was passed)\n      const indexedValues = decodedArguments.filter(argument => argument.indexed).map(argument => argument.value);\n      const reEncodedTopics = indexedValues.map(Topic.Encode.encodeTopic);\n      const encodedTopics = info.state.eventtopics;\n      //now: do *these* match?\n      const selectorAdjustment = allocation.anonymous ? 0 : 1;\n      for (let i = 0; i < reEncodedTopics.length; i++) {\n        if (!Evm.Utils.equalData(reEncodedTopics[i], encodedTopics[i + selectorAdjustment])) {\n          debug(\"rejected due to indexed mismatch\");\n          continue allocationAttempts;\n        }\n      }\n      //if we've made it here, the allocation works!  hooray!\n      debug(\"allocation accepted!\");\n      let decoding;\n      if (allocation.abi.anonymous) {\n        decoding = {\n          kind: \"anonymous\",\n          definedIn: contractType,\n          class: emittingContractType,\n          abi: allocation.abi,\n          arguments: decodedArguments,\n          decodingMode,\n          interpretations: {}\n        };\n      } else {\n        decoding = {\n          kind: \"event\",\n          definedIn: contractType,\n          class: emittingContractType,\n          abi: allocation.abi,\n          arguments: decodedArguments,\n          selector,\n          decodingMode,\n          interpretations: {}\n        };\n      }\n      decodings.push(decoding);\n      //if we've made this far (so this allocation works), and we were passed an\n      //ID, and it matches this ID, bail out & return this as the *only* decoding\n      if (options.id && allocation.id === options.id) {\n        return [decoding];\n      }\n    }\n    return decodings;\n  }();\n}\nexports.decodeEvent = decodeEvent;\nconst errorSelector = Conversion.toBytes(web3_utils_1.default.soliditySha3({\n  type: \"string\",\n  value: \"Error(string)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nconst panicSelector = Conversion.toBytes(web3_utils_1.default.soliditySha3({\n  type: \"string\",\n  value: \"Panic(uint256)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nconst defaultRevertAllocations = [{\n  kind: \"revert\",\n  allocationMode: \"full\",\n  selector: errorSelector,\n  abi: {\n    name: \"Error\",\n    type: \"error\",\n    inputs: [{\n      name: \"\",\n      type: \"string\",\n      internalType: \"string\"\n    }]\n  },\n  definedIn: null,\n  arguments: [{\n    name: \"\",\n    pointer: {\n      location: \"returndata\",\n      start: errorSelector.length,\n      length: Evm.Utils.WORD_SIZE\n    },\n    type: {\n      typeClass: \"string\",\n      typeHint: \"string\"\n    }\n  }]\n}, {\n  kind: \"revert\",\n  allocationMode: \"full\",\n  selector: panicSelector,\n  abi: {\n    name: \"Panic\",\n    type: \"error\",\n    inputs: [{\n      name: \"\",\n      type: \"uint256\",\n      internalType: \"uint256\"\n    }]\n  },\n  definedIn: null,\n  arguments: [{\n    name: \"\",\n    pointer: {\n      location: \"returndata\",\n      start: panicSelector.length,\n      length: Evm.Utils.WORD_SIZE\n    },\n    type: {\n      typeClass: \"uint\",\n      bits: Evm.Utils.WORD_SIZE * 8,\n      typeHint: \"uint256\"\n    }\n  }]\n}];\nconst defaultEmptyAllocations = [{\n  kind: \"failure\",\n  allocationMode: \"full\",\n  selector: new Uint8Array(),\n  arguments: []\n}, {\n  kind: \"selfdestruct\",\n  allocationMode: \"full\",\n  selector: new Uint8Array(),\n  arguments: []\n}];\n/**\n * If there are multiple possibilities, they're always returned in\n * the order: return, revert, returnmessage, failure, empty, bytecode, unknownbytecode\n * Moreover, within \"revert\", builtin ones are put above custom ones\n * @Category Decoding\n */\nfunction* decodeReturndata(info, successAllocation,\n//null here must be explicit\nstatus,\n//you can pass this to indicate that you know the status,\nid //useful when status = false\n) {\n  let possibleAllocations;\n  const selector = Conversion.toHexString(info.state.returndata.slice(0, 4));\n  const contextHash = (info.currentContext || {\n    context: \"\"\n  }).context; //HACK: \"\" is used to represent no context\n  const customRevertAllocations = ((info.allocations.returndata || {\n    [contextHash]: {}\n  })[contextHash] || {\n    [selector]: []\n  })[selector] || [];\n  if (successAllocation === null) {\n    possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations];\n  } else {\n    switch (successAllocation.kind) {\n      case \"return\":\n        possibleAllocations = [successAllocation, ...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations];\n        break;\n      case \"bytecode\":\n        possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations, successAllocation];\n        break;\n      case \"returnmessage\":\n        possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, successAllocation, ...defaultEmptyAllocations];\n        break;\n      //Other cases shouldn't happen so I'm leaving them to cause errors!\n    }\n  }\n\n  let decodings = [];\n  allocationAttempts: for (const allocation of possibleAllocations) {\n    debug(\"trying allocation: %O\", allocation);\n    //before we attempt to use this allocation, we check: does the selector match?\n    let encodedData = info.state.returndata; //again, not great to read this directly, but oh well\n    const encodedPrefix = encodedData.subarray(0, allocation.selector.length);\n    if (!Evm.Utils.equalData(encodedPrefix, allocation.selector)) {\n      continue;\n    }\n    encodedData = encodedData.subarray(allocation.selector.length); //slice off the selector for later\n    //also we check, does the status match?\n    if (status !== undefined) {\n      const successKinds = [\"return\", \"selfdestruct\", \"bytecode\", \"returnmessage\"];\n      const failKinds = [\"failure\", \"revert\"];\n      if (status) {\n        if (!successKinds.includes(allocation.kind)) {\n          continue;\n        }\n      } else {\n        if (!failKinds.includes(allocation.kind)) {\n          continue;\n        }\n      }\n    }\n    if (allocation.kind === \"bytecode\") {\n      //bytecode is special and can't really be integrated with the other cases.\n      //so it gets its own function.\n      const decoding = yield* decodeBytecode(info);\n      if (decoding) {\n        decodings.push(decoding);\n      }\n      continue;\n    }\n    if (allocation.kind === \"returnmessage\") {\n      //this kind is also special, though thankfully it's easier\n      const decoding = {\n        kind: \"returnmessage\",\n        status: true,\n        data: Conversion.toHexString(info.state.returndata),\n        decodingMode: allocation.allocationMode,\n        interpretations: {}\n      };\n      decodings.push(decoding);\n      continue;\n    }\n    let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n    //you can't map with a generator, so we have to do this map manually\n    let decodedArguments = [];\n    for (const argumentAllocation of allocation.arguments) {\n      let value;\n      //if in full mode, use the allocation's listed data type.\n      //if in ABI mode, abify it before use.\n      let dataType = decodingMode === \"full\" ? argumentAllocation.type : (0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes);\n      //now, let's decode!\n      try {\n        value = yield* (0, decode_1.default)(dataType, argumentAllocation.pointer, info, {\n          abiPointerBase: allocation.selector.length,\n          strictAbiMode: true,\n          allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n        });\n\n        debug(\"value on first try: %O\", value);\n      } catch (error) {\n        if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n          debug(\"retry!\");\n          //if a retry happens, we've got to do several things in order to switch to ABI mode:\n          //1. mark that we're switching to ABI mode;\n          decodingMode = \"abi\";\n          //2. abify all previously decoded values;\n          decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n            value: (0, abify_1.abifyResult)(argumentDecoding.value, info.userDefinedTypes)\n          }));\n          //3. retry this particular decode in ABI mode.\n          try {\n            value = yield* (0, decode_1.default)((0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes),\n            //type is now abified!\n            argumentAllocation.pointer, info, {\n              abiPointerBase: allocation.selector.length,\n              strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n              //retries no longer allowed, not that this has an effect\n            });\n\n            debug(\"value on retry: %O\", value);\n          } catch (_) {\n            //if an error occurred on the retry, this isn't a valid decoding!\n            debug(\"rejected due to exception on retry\");\n            continue allocationAttempts;\n          }\n          //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n          //so we don't need to do anything special there.\n        } else {\n          //if any other sort of error occurred, this isn't a valid decoding!\n          debug(\"rejected due to exception on first try: %O\", error);\n          continue allocationAttempts;\n        }\n      }\n      const name = argumentAllocation.name;\n      decodedArguments.push(name //deliberate general falsiness test\n      ? {\n        name,\n        value\n      } : {\n        value\n      });\n    }\n    //OK, so, having decoded the result, the question is: does it reencode to the original?\n    //first, we have to filter out the indexed arguments, and also get rid of the name information\n    debug(\"decodedArguments: %O\", decodedArguments);\n    const decodedArgumentValues = decodedArguments.map(argument => argument.value);\n    const reEncodedData = AbiData.Encode.encodeTupleAbi(decodedArgumentValues, info.allocations.abi);\n    //are they equal? note the selector has been stripped off encodedData!\n    if (!Evm.Utils.equalData(reEncodedData, encodedData)) {\n      //if not, this allocation doesn't work\n      debug(\"rejected due to mismatch\");\n      continue;\n    }\n    //if we've made it here, the allocation works!  hooray!\n    debug(\"allocation accepted!\");\n    let decoding;\n    switch (allocation.kind) {\n      case \"return\":\n        decoding = {\n          kind: \"return\",\n          status: true,\n          arguments: decodedArguments,\n          decodingMode,\n          interpretations: {}\n        };\n        break;\n      case \"revert\":\n        decoding = {\n          kind: \"revert\",\n          abi: allocation.abi,\n          definedIn: allocation.definedIn,\n          status: false,\n          arguments: decodedArguments,\n          decodingMode,\n          interpretations: {}\n        };\n        break;\n      case \"selfdestruct\":\n        decoding = {\n          kind: \"selfdestruct\",\n          status: true,\n          decodingMode,\n          interpretations: {}\n        };\n        break;\n      case \"failure\":\n        decoding = {\n          kind: \"failure\",\n          status: false,\n          decodingMode,\n          interpretations: {}\n        };\n        break;\n    }\n    decodings.push(decoding);\n    //if we've made this far (so this allocation works), and we were passed an\n    //ID, and it matches this ID, bail out & return this as the *only* decoding\n    if (id && allocation.kind === \"revert\" && allocation.id === id) {\n      return [decoding];\n    }\n  }\n  return decodings;\n}\nexports.decodeReturndata = decodeReturndata;\n//note: requires the bytecode to be in returndata, not code\nfunction* decodeBytecode(info) {\n  let decodingMode = \"full\"; //as always, degrade as necessary\n  const bytecode = Conversion.toHexString(info.state.returndata);\n  const context = Contexts.Utils.findContext(info.contexts, bytecode);\n  if (!context) {\n    return {\n      kind: \"unknownbytecode\",\n      status: true,\n      decodingMode: \"full\",\n      bytecode,\n      interpretations: {}\n    };\n  }\n  const contractType = Contexts.Import.contextToType(context);\n  //now: ignore original allocation (which we didn't even pass :) )\n  //and lookup allocation by context\n  const allocation = info.allocations.calldata.constructorAllocations[context.context].output;\n  debug(\"bytecode allocation: %O\", allocation);\n  //now: add immutables if applicable\n  let immutables;\n  if (allocation.immutables) {\n    immutables = [];\n    //NOTE: if we're in here, we can assume decodingMode === \"full\"\n    for (const variable of allocation.immutables) {\n      const dataType = variable.type; //we don't conditioning on decodingMode here because we know it\n      let value;\n      try {\n        value = yield* (0, decode_1.default)(dataType, variable.pointer, info, {\n          allowRetry: true,\n          strictAbiMode: true,\n          paddingMode: \"defaultOrZero\"\n        });\n      } catch (error) {\n        if (error instanceof errors_1.StopDecodingError && error.allowRetry) {\n          //we \"retry\" by... not bothering with immutables :P\n          //(but we do set the mode to ABI)\n          decodingMode = \"abi\";\n          immutables = undefined;\n          break;\n        } else {\n          //otherwise, this isn't a valid decoding I guess\n          return null;\n        }\n      }\n      immutables.push({\n        name: variable.name,\n        class: variable.definedIn,\n        value\n      });\n    }\n  }\n  let decoding = {\n    kind: \"bytecode\",\n    status: true,\n    decodingMode,\n    bytecode,\n    immutables,\n    class: contractType,\n    interpretations: {}\n  };\n  //finally: add address if applicable\n  if (allocation.delegatecallGuard) {\n    decoding.address = web3_utils_1.default.toChecksumAddress(bytecode.slice(4, 4 + 2 * Evm.Utils.ADDRESS_SIZE) //4 = \"0x73\".length\n    );\n  }\n\n  return decoding;\n}\n/**\n * Decodes the return data from a failed call.\n *\n * @param returndata The returned data, as a Uint8Array.\n * @return An array of possible decodings.  At the moment it's\n *   impossible for there to be more than one.  (If the call didn't actually\n *   fail, or failed in a nonstandard way, you may get no decodings at all, though!)\n *\n *   Decodings can either be decodings of revert messages, or decodings\n *   indicating that there was no revert message.  If somehow both were to be\n *   possible, they'd go in that order, although as mentioned, there (at least\n *   currently) isn't any way for that to occur.\n * @Category Decoding convenience\n */\nfunction decodeRevert(returndata) {\n  //coercing because TS doesn't know it'll finish in one go\n  return decodeReturndata({\n    allocations: {},\n    state: {\n      storage: {},\n      returndata\n    }\n  }, null, false).next().value;\n}\nexports.decodeRevert = decodeRevert;","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","Ast","__importStar","AbiData","Topic","Evm","Contexts","abify_1","Conversion","errors_1","read_1","decode_1","web3_utils_1","decodeVariable","definition","pointer","info","compilationId","compiler","currentContext","dataType","Import","definitionToType","exports","decodeCalldata","isConstructor","context","kind","decodingMode","bytecode","toHexString","state","calldata","interpretations","data","contextHash","contractType","contextToType","allocations","allocation","selector","constructorAllocations","input","undefined","rawSelector","location","start","length","Utils","SELECTOR_SIZE","functionAllocations","abiEntry","fallbackAbi","receive","fallback","class","abi","allocationMode","decodedArguments","argumentAllocation","arguments","value","type","abifyType","userDefinedTypes","abiPointerBase","offset","allowRetry","error","StopDecodingError","map","argumentDecoding","Object","assign","abifyResult","name","push","slice","decodeEvent","address","options","event","extras","contractAllocations","libraryAllocations","contractAnonymousAllocations","libraryAnonymousAllocations","topicsCount","eventtopics","topic","bySelector","contract","library","anonymous","contractContext","codeBytes","codeAsHex","findContext","contexts","possibleContractAllocations","possibleContractAnonymousAllocations","possibleExtraAllocations","possibleExtraAnonymousAllocations","emittingContextHash","contractAllocation","contractAnonymousAllocation","concat","entries","filter","_ref","key","_","_ref2","_ref3","_ref4","values","possibleLibraryAllocations","possibleLibraryAnonymousAllocations","possibleAllocations","possibleAnonymousAllocations","possibleAllocationsTotalMinusExtras","possibleExtraAllocationsTotal","possibleAllocationsTotal","decodings","allocationAttempts","attemptContext","emittingContractType","definedIn","strictAbiMode","indexed","disableChecks","nonIndexedValues","argument","reEncodedData","Encode","encodeTupleAbi","encodedData","eventdata","equalData","indexedValues","reEncodedTopics","encodeTopic","encodedTopics","selectorAdjustment","i","decoding","id","errorSelector","toBytes","soliditySha3","subarray","panicSelector","defaultRevertAllocations","inputs","internalType","WORD_SIZE","typeClass","typeHint","bits","defaultEmptyAllocations","Uint8Array","decodeReturndata","successAllocation","status","returndata","customRevertAllocations","encodedPrefix","successKinds","failKinds","includes","decodeBytecode","decodedArgumentValues","output","immutables","variable","paddingMode","delegatecallGuard","toChecksumAddress","ADDRESS_SIZE","decodeRevert","storage","next"],"sources":["../../lib/core.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}