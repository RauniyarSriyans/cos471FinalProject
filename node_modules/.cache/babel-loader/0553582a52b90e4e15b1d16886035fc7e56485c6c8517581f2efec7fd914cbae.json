{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isMoreSpecific = exports.isMoreSpecificMultiple = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:priority\");\nconst Format = __importStar(require(\"../format\"));\nconst utils_1 = require(\"./utils\");\n//is input 1 more specific than input 2? (nonstrict)\nfunction isMoreSpecificMultiple(types1, types2, userDefinedTypes) {\n  //just wrap the types in tuples and defer to isMoreSpecific()\n  const combinedType1 = {\n    typeClass: \"tuple\",\n    memberTypes: types1\n  };\n  const combinedType2 = {\n    typeClass: \"tuple\",\n    memberTypes: types2\n  };\n  return isMoreSpecific(combinedType1, combinedType2, userDefinedTypes, true);\n  //that last flag is so we ignore variable names at top level\n}\n\nexports.isMoreSpecificMultiple = isMoreSpecificMultiple;\n//is input 1 more specific than input 2?\n//(this is nonstrict)\nfunction isMoreSpecific(type1, type2, userDefinedTypes) {\n  let ignoreComponentNames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  //udvts get priority of underlying type!\n  if (type1.typeClass === \"userDefinedValueType\") {\n    type1 = getUnderlyingType(type1, userDefinedTypes);\n  }\n  if (type2.typeClass === \"userDefinedValueType\") {\n    type2 = getUnderlyingType(type2, userDefinedTypes);\n  }\n  const typeClasses = [[\"options\"], [\"array\"], [\"struct\", \"tuple\"], [\"address\", \"contract\"], [\"bytes\"], [\"function\"], [\"uint\", \"int\", \"fixed\", \"ufixed\"], [\"enum\"], [\"string\"], [\"bool\"]];\n  //for each type, what's the first one it counts as?\n  const index1 = typeClasses.findIndex(classes => classes.includes(type1.typeClass));\n  const index2 = typeClasses.findIndex(classes => classes.includes(type2.typeClass));\n  //NOTE: I am assuming neither will be -1!\n  //If either is, something has gone very wrong!\n  if (index1 < index2) {\n    return true;\n  } else if (index2 < index1) {\n    return false;\n  }\n  //otherwise, indices are equal, defer to tiebreaker\n  switch (type1.typeClass) {\n    case \"options\":\n      return isMoreSpecificOptions(type1, type2);\n    case \"address\":\n    case \"contract\":\n      return isMoreSpecificAddress(type1, type2);\n    case \"function\":\n      return isMoreSpecificFunction(\n      //we haven't actually checked visibility, so we'll have to coerce\n      type1, type2, userDefinedTypes);\n    case \"array\":\n      return isMoreSpecificArray(type1, type2, userDefinedTypes);\n    case \"bytes\":\n      return isMoreSpecificBytes(type1, type2);\n    case \"uint\":\n    case \"int\":\n    case \"fixed\":\n    case \"ufixed\":\n      return isMoreSpecificNumeric(type1, type2);\n    case \"enum\":\n      return isMoreSpecificEnum(type1, type2);\n    case \"string\":\n      return isMoreSpecificString(type1, type2);\n    case \"struct\":\n    case \"tuple\":\n      return isMoreSpecificTuple(type1, type2, userDefinedTypes, ignoreComponentNames);\n    case \"bool\":\n      return isMoreSpecificBool(type1, type2);\n  }\n}\nexports.isMoreSpecific = isMoreSpecific;\nfunction isMoreSpecificAddress(type1, type2) {\n  //address payable more specific than address\n  //contract types more specific than address\n  //*payable* contract types more specific than address payable\n  if (type1.typeClass === \"address\" && type2.typeClass === \"address\") {\n    if (type1.kind === \"specific\" && type2.kind === \"specific\") {\n      return type1.payable || !type2.payable;\n    } else if (type2.kind === \"general\") {\n      //specific is more specific than general :P\n      return true;\n    }\n  }\n  if (type1.typeClass === \"contract\" && type2.typeClass === \"contract\") {\n    if (type1.kind === \"native\" && type2.kind === \"native\") {\n      return type1.id === type2.id;\n    } //foreign contract types will always be incomparable, I guess?\n    //(they shouldn't come up here anyway)\n  }\n\n  if (type1.typeClass === \"contract\" && type2.typeClass === \"address\") {\n    return type2.kind === \"general\" || type2.kind === \"specific\" && !type2.payable || type2.kind === \"specific\" && type1.payable;\n  }\n  return false; //otherwise\n}\n\nfunction isMoreSpecificBytes(type1, type2) {\n  //static more specific than dynamic, with shorter\n  //lengths more specific than longer ones\n  return type1.kind === \"dynamic\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"static\" && type1.length <= type2.length;\n}\nfunction isMoreSpecificNumeric(type1, type2) {\n  return (0, utils_1.maxValue)(type1).lte((0, utils_1.maxValue)(type2)) && (0, utils_1.minValue)(type1).gte((0, utils_1.minValue)(type2)) && (0, utils_1.places)(type1) <= (0, utils_1.places)(type2) &&\n  //note: I don't know whether this final bit is actually necessary\n  //since we don't actually know yet whether fixedNx0 will be legal\n  !((type1.typeClass === \"fixed\" || type1.typeClass === \"ufixed\") && (type2.typeClass === \"int\" || type2.typeClass === \"uint\"));\n}\nfunction isMoreSpecificEnum(type1, type2) {\n  //different enum types are incomparable\n  return type1.id === type2.id;\n}\nfunction isMoreSpecificString(_type1, _type2) {\n  //only one string type\n  return true;\n}\nfunction isMoreSpecificArray(type1, type2, userDefinedTypes) {\n  //static is more specific than dynamic, but\n  //different static lengths are incomparable\n  const moreSpecificLength = type1.kind === \"dynamic\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"static\" && type1.length.eq(type2.length);\n  //length and types must both be more specific\n  return moreSpecificLength && isMoreSpecific(type1.baseType, type2.baseType, userDefinedTypes);\n}\nfunction isMoreSpecificFunction(type1, type2, userDefinedTypes) {\n  switch (type2.kind) {\n    case \"general\":\n      return true;\n    case \"specific\":\n      switch (type1.kind) {\n        case \"general\":\n          return false;\n        case \"specific\":\n          //now: if they're both specific...\n          //(this case doesn't really matter, but let's do it anyway)\n          if (!isMutabilityMoreSpecific(type1.mutability, type2.mutability)) {\n            return false;\n          }\n          if (type1.outputParameterTypes.length !== type2.outputParameterTypes.length) {\n            return false;\n          }\n          for (let i = 0; i < type1.outputParameterTypes.length; i++) {\n            if (!isMoreSpecific(type1.outputParameterTypes[i], type2.outputParameterTypes[i], userDefinedTypes)) {\n              return false;\n            }\n          }\n          if (type1.inputParameterTypes.length !== type2.inputParameterTypes.length) {\n            return false;\n          }\n          for (let i = 0; i < type1.inputParameterTypes.length; i++) {\n            if (!isMoreSpecific(\n            //swapped for contravariance, I guess...?\n            type2.inputParameterTypes[i], type1.inputParameterTypes[i], userDefinedTypes)) {\n              return false;\n            }\n          }\n          return true;\n      }\n  }\n}\nfunction isMutabilityMoreSpecific(mutability1, mutability2) {\n  //pure <= view <= nonpayable, payable <= nonpayable\n  return mutability1 === mutability2 || mutability1 === \"pure\" && mutability2 !== \"payable\" || mutability2 === \"nonpayable\";\n}\nfunction isMoreSpecificTuple(type1, type2, userDefinedTypes) {\n  let ignoreComponentNames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  debug(\"type1: %O\", type1);\n  debug(\"type2: %O\", type2);\n  const fullType1 = Format.Types.fullType(type1, userDefinedTypes);\n  const fullType2 = Format.Types.fullType(type2, userDefinedTypes);\n  const types1 = fullType1.memberTypes.map(member => member.type);\n  const types2 = fullType2.memberTypes.map(member => member.type);\n  //lengths must match\n  if (types1.length !== types2.length) {\n    return false;\n  }\n  //individual types must satisfy isMoreSpecific\n  for (let i = 0; i < types1.length; i++) {\n    //note we do *not* pass along the ignoreComponentNames flag\n    if (!isMoreSpecific(types1[i], types2[i], userDefinedTypes)) {\n      return false;\n    }\n  }\n  if (!ignoreComponentNames) {\n    debug(\"checking by name\");\n    //if this flag is not set, *and* the component names match,\n    //(and all exist)\n    //then compare by component names in addition to by position\n    let names1 = fullType1.memberTypes.map(member => member.name);\n    let names2 = fullType2.memberTypes.map(member => member.name);\n    //we just created these via a map so it's OK to sort in-place\n    names1.sort();\n    names2.sort();\n    let namesEqual = true;\n    for (let i = 0; i < names1.length; i++) {\n      if (!names1[i] || !names2[i] || names1[i] !== names2[i]) {\n        namesEqual = false;\n        break;\n      }\n    }\n    if (namesEqual) {\n      debug(\"names equal\");\n      for (let i = 0; i < types1.length; i++) {\n        const type1 = types1[i];\n        const name = fullType1.memberTypes[i].name;\n        const type2 = fullType2.memberTypes.find(_ref => {\n          let {\n            name: name2\n          } = _ref;\n          return name2 === name;\n        }).type;\n        debug(\"name: %s\", name);\n        debug(\"type1: %O\", type1);\n        debug(\"type2: %O\", type2);\n        if (!isMoreSpecific(type1, type2, userDefinedTypes)) {\n          debug(\"returning false\");\n          return false;\n        }\n      }\n      debug(\"name check ok\");\n    }\n  }\n  return true;\n  //I was going to make structs more specific than their underlying\n  //tuples, and different equivalent structs incomparable, but I\n  //couldn't find a good way to do that, so whatever, they're all\n  //just equivalent, it won't come up\n}\n\nfunction isMoreSpecificOptions(_type1, _type2) {\n  //only one options type\n  return true;\n}\nfunction isMoreSpecificBool(_type1, _type2) {\n  //only one boolean type\n  return true;\n}\nfunction getUnderlyingType(udvtType, userDefinedTypes) {\n  return Format.Types.fullType(udvtType, userDefinedTypes).underlyingType;\n}","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","Format","__importStar","utils_1","isMoreSpecificMultiple","types1","types2","userDefinedTypes","combinedType1","typeClass","memberTypes","combinedType2","isMoreSpecific","exports","type1","type2","ignoreComponentNames","arguments","length","undefined","getUnderlyingType","typeClasses","index1","findIndex","classes","includes","index2","isMoreSpecificOptions","isMoreSpecificAddress","isMoreSpecificFunction","isMoreSpecificArray","isMoreSpecificBytes","isMoreSpecificNumeric","isMoreSpecificEnum","isMoreSpecificString","isMoreSpecificTuple","isMoreSpecificBool","kind","payable","id","maxValue","lte","minValue","gte","places","_type1","_type2","moreSpecificLength","eq","baseType","isMutabilityMoreSpecific","mutability","outputParameterTypes","i","inputParameterTypes","mutability1","mutability2","fullType1","Types","fullType","fullType2","map","member","type","names1","name","names2","sort","namesEqual","find","_ref","name2","udvtType","underlyingType"],"sources":["../../../lib/wrap/priority.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}