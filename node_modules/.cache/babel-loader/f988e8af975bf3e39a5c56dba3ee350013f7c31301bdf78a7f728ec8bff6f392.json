{"ast":null,"code":"\"use strict\";\n\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeStorageReference = exports.decodeStorageReferenceByAddress = exports.decodeStorage = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:storage:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst errors_1 = require(\"../../errors\");\nfunction* decodeStorage(dataType, pointer, info) {\n  if (Format.Types.isReferenceType(dataType)) {\n    return yield* decodeStorageReference(dataType, pointer, info);\n  } else {\n    return yield* Basic.Decode.decodeBasic(dataType, pointer, info);\n  }\n}\nexports.decodeStorage = decodeStorage;\n//decodes storage at the address *read* from the pointer -- hence why this takes DataPointer rather than StoragePointer.\n//NOTE: ONLY for use with pointers to reference types!\n//Of course, pointers to value types don't exist in Solidity, so that warning is redundant, but...\nfunction* decodeStorageReferenceByAddress(dataType, pointer, info) {\n  const allocations = info.allocations.storage;\n  let rawValue;\n  try {\n    rawValue = yield* (0, read_1.default)(pointer, info.state);\n  } catch (error) {\n    return (0, errors_1.handleDecodingError)(dataType, error);\n  }\n  const startOffset = Conversion.toBN(rawValue);\n  let rawSize;\n  try {\n    rawSize = (0, allocate_1.storageSize)(dataType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n  } catch (error) {\n    return (0, errors_1.handleDecodingError)(dataType, error);\n  }\n  //we *know* the type being decoded must be sized in words, because it's a\n  //reference type, but TypeScript doesn't, so we'll have to use a type\n  //coercion\n  const size = rawSize.words;\n  //now, construct the storage pointer\n  const newPointer = {\n    location: \"storage\",\n    range: {\n      from: {\n        slot: {\n          offset: startOffset\n        },\n        index: 0\n      },\n      to: {\n        slot: {\n          offset: startOffset.addn(size - 1)\n        },\n        index: Evm.Utils.WORD_SIZE - 1\n      }\n    }\n  };\n  //dispatch to decodeStorageReference\n  return yield* decodeStorageReference(dataType, newPointer, info);\n}\nexports.decodeStorageReferenceByAddress = decodeStorageReferenceByAddress;\nfunction* decodeStorageReference(dataType, pointer, info) {\n  var data;\n  var length;\n  const {\n    state\n  } = info;\n  const allocations = info.allocations.storage;\n  switch (dataType.typeClass) {\n    case \"array\":\n      {\n        debug(\"storage array! %o\", pointer);\n        let lengthAsBN;\n        switch (dataType.kind) {\n          case \"dynamic\":\n            debug(\"dynamic array\");\n            debug(\"type %O\", dataType);\n            try {\n              data = yield* (0, read_1.default)(pointer, state);\n            } catch (error) {\n              return (0, errors_1.handleDecodingError)(dataType, error);\n            }\n            lengthAsBN = Conversion.toBN(data);\n            break;\n          case \"static\":\n            debug(\"static array\");\n            lengthAsBN = dataType.length;\n            break;\n        }\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_a) {\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN\n            }\n          };\n        }\n        debug(\"length %o\", length);\n        debug(\"about to determine baseSize\");\n        let baseSize;\n        try {\n          baseSize = (0, allocate_1.storageSize)(dataType.baseType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n        } catch (error) {\n          return (0, errors_1.handleDecodingError)(dataType, error);\n        }\n        debug(\"baseSize %o\", baseSize);\n        //we are going to make a list of child ranges, pushing them one by one onto\n        //this list, and then decode them; the first part will vary based on whether\n        //we're in the words case or the bytes case, the second will not\n        let ranges = [];\n        if (Utils.isWordsLength(baseSize)) {\n          //currentSlot will point to the start of the entry being decoded\n          let currentSlot = {\n            path: pointer.range.from.slot,\n            offset: new bn_js_1.default(0),\n            hashPath: dataType.kind === \"dynamic\"\n          };\n          for (let i = 0; i < length; i++) {\n            let childRange = {\n              from: {\n                slot: {\n                  path: currentSlot.path,\n                  offset: currentSlot.offset.clone(),\n                  hashPath: currentSlot.hashPath\n                },\n                index: 0\n              },\n              to: {\n                slot: {\n                  path: currentSlot.path,\n                  offset: currentSlot.offset.addn(baseSize.words - 1),\n                  hashPath: currentSlot.hashPath\n                },\n                index: Evm.Utils.WORD_SIZE - 1\n              }\n            };\n            ranges.push(childRange);\n            currentSlot.offset.iaddn(baseSize.words);\n          }\n        } else {\n          const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n          debug(\"perWord %d\", perWord);\n          //currentPosition will point to the start of the entry being decoded\n          //note we have baseSize.bytes <= Evm.Utils.WORD_SIZE\n          let currentPosition = {\n            slot: {\n              path: pointer.range.from.slot,\n              offset: new bn_js_1.default(0),\n              hashPath: dataType.kind === \"dynamic\"\n            },\n            index: Evm.Utils.WORD_SIZE - baseSize.bytes //note the starting index!\n          };\n\n          for (let i = 0; i < length; i++) {\n            let childRange = {\n              from: {\n                slot: {\n                  path: currentPosition.slot.path,\n                  offset: currentPosition.slot.offset.clone(),\n                  hashPath: currentPosition.slot.hashPath\n                },\n                index: currentPosition.index\n              },\n              length: baseSize.bytes\n            };\n            ranges.push(childRange);\n            currentPosition.index -= baseSize.bytes;\n            if (currentPosition.index < 0) {\n              currentPosition.slot.offset.iaddn(1);\n              currentPosition.index = Evm.Utils.WORD_SIZE - baseSize.bytes;\n            }\n          }\n        }\n        let decodedChildren = [];\n        for (let childRange of ranges) {\n          decodedChildren.push(yield* decodeStorage(dataType.baseType, {\n            location: \"storage\",\n            range: childRange\n          }, info));\n        }\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedChildren\n        };\n      }\n    case \"bytes\":\n    case \"string\":\n      {\n        try {\n          data = yield* (0, read_1.default)(pointer, state);\n        } catch (error) {\n          return (0, errors_1.handleDecodingError)(dataType, error);\n        }\n        let lengthByte = data[Evm.Utils.WORD_SIZE - 1];\n        if (lengthByte % 2 == 0) {\n          // string lives in word, length is last byte / 2\n          length = lengthByte / 2;\n          debug(\"in-word; length %o\", length);\n          return yield* Bytes.Decode.decodeBytes(dataType, {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: pointer.range.from.slot,\n                index: 0\n              },\n              to: {\n                slot: pointer.range.from.slot,\n                index: length - 1\n              }\n            }\n          }, info);\n        } else {\n          let lengthAsBN = Conversion.toBN(data).subn(1).divn(2);\n          try {\n            length = lengthAsBN.toNumber();\n          } catch (_b) {\n            return {\n              //again with the TS failures...\n              type: dataType,\n              kind: \"error\",\n              error: {\n                kind: \"OverlongArraysAndStringsNotImplementedError\",\n                lengthAsBN\n              }\n            };\n          }\n          debug(\"new-word, length %o\", length);\n          return yield* Bytes.Decode.decodeBytes(dataType, {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: {\n                  path: pointer.range.from.slot,\n                  offset: new bn_js_1.default(0),\n                  hashPath: true\n                },\n                index: 0\n              },\n              length\n            }\n          }, info);\n        }\n      }\n    case \"struct\":\n      {\n        const typeId = dataType.id;\n        const structAllocation = allocations[typeId];\n        if (!structAllocation) {\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: dataType\n            }\n          };\n        }\n        let decodedMembers = [];\n        const members = structAllocation.members;\n        for (let index = 0; index < members.length; index++) {\n          const memberAllocation = members[index];\n          const memberPointer = memberAllocation.pointer;\n          //the type system thinks memberPointer might also be a constant\n          //definition pointer.  However, structs can't contain constants,\n          //so *we* know it's not, and can safely coerce it.\n          debug(\"pointer %O\", pointer);\n          const childRange = {\n            from: {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: memberPointer.range.from.slot.offset.clone()\n                //note that memberPointer should have no path\n              },\n\n              index: memberPointer.range.from.index\n            },\n            to: {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: memberPointer.range.to.slot.offset.clone()\n                //note that memberPointer should have no path\n              },\n\n              index: memberPointer.range.to.index\n            }\n          };\n          let storedType = info.userDefinedTypes[typeId];\n          if (!storedType) {\n            return {\n              type: dataType,\n              kind: \"error\",\n              error: {\n                kind: \"UserDefinedTypeNotFoundError\",\n                type: dataType\n              }\n            };\n          }\n          let storedMemberType = storedType.memberTypes[index].type;\n          let memberType = Format.Types.specifyLocation(storedMemberType, \"storage\");\n          decodedMembers.push({\n            name: memberAllocation.name,\n            value: yield* decodeStorage(memberType, {\n              location: \"storage\",\n              range: childRange\n            }, info)\n          });\n        }\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedMembers\n        };\n      }\n    case \"mapping\":\n      {\n        debug(\"decoding mapping\");\n        const valueType = dataType.valueType;\n        let valueSize;\n        try {\n          valueSize = (0, allocate_1.storageSize)(valueType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n        } catch (error) {\n          return (0, errors_1.handleDecodingError)(dataType, error);\n        }\n        let decodedEntries = [];\n        const baseSlot = pointer.range.from.slot;\n        debug(\"baseSlot %o\", baseSlot);\n        debug(\"base slot address %o\", Utils.slotAddress(baseSlot));\n        const keySlots = info.mappingKeys.filter(_ref => {\n          let {\n            path\n          } = _ref;\n          return Utils.slotAddress(baseSlot).eq(Utils.slotAddress(path));\n        });\n        for (const {\n          key\n        } of keySlots) {\n          let valuePointer;\n          if (Utils.isWordsLength(valueSize)) {\n            valuePointer = {\n              location: \"storage\",\n              range: {\n                from: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: 0\n                },\n                to: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(valueSize.words - 1)\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              }\n            };\n          } else {\n            valuePointer = {\n              location: \"storage\",\n              range: {\n                from: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: Evm.Utils.WORD_SIZE - valueSize.bytes\n                },\n                to: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              }\n            };\n          }\n          decodedEntries.push({\n            key,\n            value: yield* decodeStorage(valueType, valuePointer, info)\n          });\n        }\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedEntries\n        };\n      }\n  }\n}\nexports.decodeStorageReference = decodeStorageReference;","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","read_1","Conversion","__importStar","Format","Basic","Bytes","Utils","Evm","allocate_1","bn_js_1","errors_1","decodeStorage","dataType","pointer","info","Types","isReferenceType","decodeStorageReference","Decode","decodeBasic","exports","decodeStorageReferenceByAddress","allocations","storage","rawValue","state","error","handleDecodingError","startOffset","toBN","rawSize","storageSize","userDefinedTypes","currentContext","compiler","size","words","newPointer","location","range","from","slot","offset","index","to","addn","WORD_SIZE","data","length","typeClass","lengthAsBN","kind","toNumber","_a","type","baseSize","baseType","ranges","isWordsLength","currentSlot","path","hashPath","i","childRange","clone","push","iaddn","perWord","Math","floor","bytes","currentPosition","decodedChildren","value","lengthByte","decodeBytes","subn","divn","_b","typeId","id","structAllocation","decodedMembers","members","memberAllocation","memberPointer","storedType","storedMemberType","memberTypes","memberType","specifyLocation","name","valueType","valueSize","decodedEntries","baseSlot","slotAddress","keySlots","mappingKeys","filter","_ref","eq","key","valuePointer"],"sources":["../../../../lib/storage/decode/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}