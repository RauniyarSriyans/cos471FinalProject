{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.double = void 0;\nconst ArrayInt64_1 = require(\"./_internals/helpers/ArrayInt64\");\nconst ArrayInt64Arbitrary_1 = require(\"./_internals/ArrayInt64Arbitrary\");\nconst DoubleHelpers_1 = require(\"./_internals/helpers/DoubleHelpers\");\nfunction safeDoubleToIndex(d, constraintsLabel) {\n  if (Number.isNaN(d)) {\n    throw new Error('fc.double constraints.' + constraintsLabel + ' must be a 32-bit float');\n  }\n  return (0, DoubleHelpers_1.doubleToIndex)(d);\n}\nfunction unmapperDoubleToIndex(value) {\n  if (typeof value !== 'number') throw new Error('Unsupported type');\n  return (0, DoubleHelpers_1.doubleToIndex)(value);\n}\nfunction double() {\n  let constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    noDefaultInfinity = false,\n    noNaN = false,\n    min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY,\n    max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY\n  } = constraints;\n  const minIndex = safeDoubleToIndex(min, 'min');\n  const maxIndex = safeDoubleToIndex(max, 'max');\n  if ((0, ArrayInt64_1.isStrictlySmaller64)(maxIndex, minIndex)) {\n    throw new Error('fc.double constraints.min must be smaller or equal to constraints.max');\n  }\n  if (noNaN) {\n    return (0, ArrayInt64Arbitrary_1.arrayInt64)(minIndex, maxIndex).map(DoubleHelpers_1.indexToDouble, unmapperDoubleToIndex);\n  }\n  const positiveMaxIdx = (0, ArrayInt64_1.isStrictlyPositive64)(maxIndex);\n  const minIndexWithNaN = positiveMaxIdx ? minIndex : (0, ArrayInt64_1.substract64)(minIndex, ArrayInt64_1.Unit64);\n  const maxIndexWithNaN = positiveMaxIdx ? (0, ArrayInt64_1.add64)(maxIndex, ArrayInt64_1.Unit64) : maxIndex;\n  return (0, ArrayInt64Arbitrary_1.arrayInt64)(minIndexWithNaN, maxIndexWithNaN).map(index => {\n    if ((0, ArrayInt64_1.isStrictlySmaller64)(maxIndex, index) || (0, ArrayInt64_1.isStrictlySmaller64)(index, minIndex)) return Number.NaN;else return (0, DoubleHelpers_1.indexToDouble)(index);\n  }, value => {\n    if (typeof value !== 'number') throw new Error('Unsupported type');\n    if (Number.isNaN(value)) return !(0, ArrayInt64_1.isEqual64)(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;\n    return (0, DoubleHelpers_1.doubleToIndex)(value);\n  });\n}\nexports.double = double;","map":{"version":3,"names":["Object","defineProperty","exports","value","double","ArrayInt64_1","require","ArrayInt64Arbitrary_1","DoubleHelpers_1","safeDoubleToIndex","d","constraintsLabel","Number","isNaN","Error","doubleToIndex","unmapperDoubleToIndex","constraints","arguments","length","undefined","noDefaultInfinity","noNaN","min","MAX_VALUE","NEGATIVE_INFINITY","max","POSITIVE_INFINITY","minIndex","maxIndex","isStrictlySmaller64","arrayInt64","map","indexToDouble","positiveMaxIdx","isStrictlyPositive64","minIndexWithNaN","substract64","Unit64","maxIndexWithNaN","add64","index","NaN","isEqual64"],"sources":["/Users/karimelbarbary/Desktop/test4/devote/node_modules/fast-check/lib/arbitrary/double.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.double = void 0;\nconst ArrayInt64_1 = require(\"./_internals/helpers/ArrayInt64\");\nconst ArrayInt64Arbitrary_1 = require(\"./_internals/ArrayInt64Arbitrary\");\nconst DoubleHelpers_1 = require(\"./_internals/helpers/DoubleHelpers\");\nfunction safeDoubleToIndex(d, constraintsLabel) {\n    if (Number.isNaN(d)) {\n        throw new Error('fc.double constraints.' + constraintsLabel + ' must be a 32-bit float');\n    }\n    return (0, DoubleHelpers_1.doubleToIndex)(d);\n}\nfunction unmapperDoubleToIndex(value) {\n    if (typeof value !== 'number')\n        throw new Error('Unsupported type');\n    return (0, DoubleHelpers_1.doubleToIndex)(value);\n}\nfunction double(constraints = {}) {\n    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY, } = constraints;\n    const minIndex = safeDoubleToIndex(min, 'min');\n    const maxIndex = safeDoubleToIndex(max, 'max');\n    if ((0, ArrayInt64_1.isStrictlySmaller64)(maxIndex, minIndex)) {\n        throw new Error('fc.double constraints.min must be smaller or equal to constraints.max');\n    }\n    if (noNaN) {\n        return (0, ArrayInt64Arbitrary_1.arrayInt64)(minIndex, maxIndex).map(DoubleHelpers_1.indexToDouble, unmapperDoubleToIndex);\n    }\n    const positiveMaxIdx = (0, ArrayInt64_1.isStrictlyPositive64)(maxIndex);\n    const minIndexWithNaN = positiveMaxIdx ? minIndex : (0, ArrayInt64_1.substract64)(minIndex, ArrayInt64_1.Unit64);\n    const maxIndexWithNaN = positiveMaxIdx ? (0, ArrayInt64_1.add64)(maxIndex, ArrayInt64_1.Unit64) : maxIndex;\n    return (0, ArrayInt64Arbitrary_1.arrayInt64)(minIndexWithNaN, maxIndexWithNaN).map((index) => {\n        if ((0, ArrayInt64_1.isStrictlySmaller64)(maxIndex, index) || (0, ArrayInt64_1.isStrictlySmaller64)(index, minIndex))\n            return Number.NaN;\n        else\n            return (0, DoubleHelpers_1.indexToDouble)(index);\n    }, (value) => {\n        if (typeof value !== 'number')\n            throw new Error('Unsupported type');\n        if (Number.isNaN(value))\n            return !(0, ArrayInt64_1.isEqual64)(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;\n        return (0, DoubleHelpers_1.doubleToIndex)(value);\n    });\n}\nexports.double = double;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}