{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sparseArray = void 0;\nconst tuple_1 = require(\"./tuple\");\nconst uniqueArray_1 = require(\"./uniqueArray\");\nconst RestrictedIntegerArbitraryBuilder_1 = require(\"./_internals/builders/RestrictedIntegerArbitraryBuilder\");\nconst MaxLengthFromMinLength_1 = require(\"./_internals/helpers/MaxLengthFromMinLength\");\nfunction extractMaxIndex(indexesAndValues) {\n  let maxIndex = -1;\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n  }\n  return maxIndex;\n}\nfunction arrayFromItems(length, indexesAndValues) {\n  const array = Array(length);\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    const it = indexesAndValues[index];\n    if (it[0] < length) array[it[0]] = it[1];\n  }\n  return array;\n}\nfunction sparseArray(arb) {\n  let constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    size,\n    minNumElements = 0,\n    maxLength = MaxLengthFromMinLength_1.MaxLengthUpperBound,\n    maxNumElements = maxLength,\n    noTrailingHole,\n    depthIdentifier\n  } = constraints;\n  const maxGeneratedNumElements = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(size, minNumElements, maxNumElements, constraints.maxNumElements !== undefined);\n  const maxGeneratedLength = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(size, maxGeneratedNumElements, maxLength, constraints.maxLength !== undefined);\n  if (minNumElements > maxLength) {\n    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);\n  }\n  if (minNumElements > maxNumElements) {\n    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);\n  }\n  const resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n  const resultedSizeMaxNumElements = constraints.maxNumElements !== undefined || size !== undefined ? size : '=';\n  const maxGeneratedIndexAuthorized = Math.max(maxGeneratedLength - 1, 0);\n  const maxIndexAuthorized = Math.max(maxLength - 1, 0);\n  const sparseArrayNoTrailingHole = (0, uniqueArray_1.uniqueArray)((0, tuple_1.tuple)((0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {\n    size: resultedSizeMaxNumElements,\n    minLength: minNumElements,\n    maxLength: resultedMaxNumElements,\n    selector: item => item[0],\n    depthIdentifier\n  }).map(items => {\n    const lastIndex = extractMaxIndex(items);\n    return arrayFromItems(lastIndex + 1, items);\n  }, value => {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n    if (noTrailingHole && value.length !== 0 && !(value.length - 1 in value)) {\n      throw new Error('No trailing hole');\n    }\n    return Object.entries(value).map(entry => [Number(entry[0]), entry[1]]);\n  });\n  if (noTrailingHole || maxLength === minNumElements) {\n    return sparseArrayNoTrailingHole;\n  }\n  return (0, tuple_1.tuple)(sparseArrayNoTrailingHole, (0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(minNumElements, maxGeneratedLength, maxLength)).map(data => {\n    const sparse = data[0];\n    const targetLength = data[1];\n    if (sparse.length >= targetLength) {\n      return sparse;\n    }\n    const longerSparse = sparse.slice();\n    longerSparse.length = targetLength;\n    return longerSparse;\n  }, value => {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n    return [value, value.length];\n  });\n}\nexports.sparseArray = sparseArray;","map":{"version":3,"names":["Object","defineProperty","exports","value","sparseArray","tuple_1","require","uniqueArray_1","RestrictedIntegerArbitraryBuilder_1","MaxLengthFromMinLength_1","extractMaxIndex","indexesAndValues","maxIndex","index","length","Math","max","arrayFromItems","array","Array","it","arb","constraints","arguments","undefined","size","minNumElements","maxLength","MaxLengthUpperBound","maxNumElements","noTrailingHole","depthIdentifier","maxGeneratedNumElements","maxGeneratedLengthFromSizeForArbitrary","maxGeneratedLength","Error","resultedMaxNumElements","min","resultedSizeMaxNumElements","maxGeneratedIndexAuthorized","maxIndexAuthorized","sparseArrayNoTrailingHole","uniqueArray","tuple","restrictedIntegerArbitraryBuilder","minLength","selector","item","map","items","lastIndex","isArray","entries","entry","Number","data","sparse","targetLength","longerSparse","slice"],"sources":["/Users/karimelbarbary/Desktop/test4/devote/node_modules/fast-check/lib/arbitrary/sparseArray.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sparseArray = void 0;\nconst tuple_1 = require(\"./tuple\");\nconst uniqueArray_1 = require(\"./uniqueArray\");\nconst RestrictedIntegerArbitraryBuilder_1 = require(\"./_internals/builders/RestrictedIntegerArbitraryBuilder\");\nconst MaxLengthFromMinLength_1 = require(\"./_internals/helpers/MaxLengthFromMinLength\");\nfunction extractMaxIndex(indexesAndValues) {\n    let maxIndex = -1;\n    for (let index = 0; index !== indexesAndValues.length; ++index) {\n        maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n    }\n    return maxIndex;\n}\nfunction arrayFromItems(length, indexesAndValues) {\n    const array = Array(length);\n    for (let index = 0; index !== indexesAndValues.length; ++index) {\n        const it = indexesAndValues[index];\n        if (it[0] < length)\n            array[it[0]] = it[1];\n    }\n    return array;\n}\nfunction sparseArray(arb, constraints = {}) {\n    const { size, minNumElements = 0, maxLength = MaxLengthFromMinLength_1.MaxLengthUpperBound, maxNumElements = maxLength, noTrailingHole, depthIdentifier, } = constraints;\n    const maxGeneratedNumElements = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(size, minNumElements, maxNumElements, constraints.maxNumElements !== undefined);\n    const maxGeneratedLength = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(size, maxGeneratedNumElements, maxLength, constraints.maxLength !== undefined);\n    if (minNumElements > maxLength) {\n        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);\n    }\n    if (minNumElements > maxNumElements) {\n        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);\n    }\n    const resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n    const resultedSizeMaxNumElements = constraints.maxNumElements !== undefined || size !== undefined ? size : '=';\n    const maxGeneratedIndexAuthorized = Math.max(maxGeneratedLength - 1, 0);\n    const maxIndexAuthorized = Math.max(maxLength - 1, 0);\n    const sparseArrayNoTrailingHole = (0, uniqueArray_1.uniqueArray)((0, tuple_1.tuple)((0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {\n        size: resultedSizeMaxNumElements,\n        minLength: minNumElements,\n        maxLength: resultedMaxNumElements,\n        selector: (item) => item[0],\n        depthIdentifier,\n    }).map((items) => {\n        const lastIndex = extractMaxIndex(items);\n        return arrayFromItems(lastIndex + 1, items);\n    }, (value) => {\n        if (!Array.isArray(value)) {\n            throw new Error('Not supported entry type');\n        }\n        if (noTrailingHole && value.length !== 0 && !(value.length - 1 in value)) {\n            throw new Error('No trailing hole');\n        }\n        return Object.entries(value).map((entry) => [Number(entry[0]), entry[1]]);\n    });\n    if (noTrailingHole || maxLength === minNumElements) {\n        return sparseArrayNoTrailingHole;\n    }\n    return (0, tuple_1.tuple)(sparseArrayNoTrailingHole, (0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(minNumElements, maxGeneratedLength, maxLength)).map((data) => {\n        const sparse = data[0];\n        const targetLength = data[1];\n        if (sparse.length >= targetLength) {\n            return sparse;\n        }\n        const longerSparse = sparse.slice();\n        longerSparse.length = targetLength;\n        return longerSparse;\n    }, (value) => {\n        if (!Array.isArray(value)) {\n            throw new Error('Not supported entry type');\n        }\n        return [value, value.length];\n    });\n}\nexports.sparseArray = sparseArray;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}