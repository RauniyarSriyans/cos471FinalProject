{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeString = exports.decodeBytes = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:bytes:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst errors_1 = require(\"../../errors\");\nconst utf8_1 = __importDefault(require(\"utf8\"));\nfunction decodeBytes(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    const {\n      state\n    } = info;\n    const {\n      strictAbiMode: strict\n    } = options; //if this is undefined it'll still be falsy so OK\n    let bytes;\n    try {\n      bytes = yield* (0, read_1.default)(pointer, state);\n    } catch (error) {\n      debug(\"segfault, pointer %o, state: %O\", pointer, state);\n      return (0, errors_1.handleDecodingError)(dataType, error, strict);\n    }\n    debug(\"type %O\", dataType);\n    debug(\"pointer %o\", pointer);\n    //note: this function does not check padding\n    switch (dataType.typeClass) {\n      case \"bytes\":\n        //we assume this is a dynamic bytestring!\n        //static ones should go to decodeBasic!\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: {\n            asHex: Conversion.toHexString(bytes)\n          }\n        };\n      case \"string\":\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodeString(bytes)\n        };\n    }\n  }();\n}\nexports.decodeBytes = decodeBytes;\nfunction decodeString(bytes) {\n  //the following line takes our UTF-8 string... and interprets each byte\n  //as a UTF-16 bytepair.  Yikes!  Fortunately, we have a library to repair that.\n  let badlyEncodedString = String.fromCharCode.apply(undefined, bytes);\n  try {\n    //this will throw an error if we have malformed UTF-8\n    let correctlyEncodedString = utf8_1.default.decode(badlyEncodedString);\n    //NOTE: we don't use node's builtin Buffer class to do the UTF-8 decoding\n    //here, because that handles malformed UTF-8 by means of replacement characters\n    //(U+FFFD).  That loses information.  So we use the utf8 package instead,\n    //and... well, see the catch block below.\n    return {\n      kind: \"valid\",\n      asString: correctlyEncodedString\n    };\n  } catch (_a) {\n    //we're going to ignore the precise error and just assume it's because\n    //the string was malformed (what else could it be?)\n    let hexString = Conversion.toHexString(bytes);\n    return {\n      kind: \"malformed\",\n      asHex: hexString\n    };\n  }\n}\nexports.decodeString = decodeString;","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","read_1","Conversion","__importStar","errors_1","utf8_1","decodeBytes","dataType","pointer","info","options","arguments","length","undefined","state","strictAbiMode","strict","bytes","error","handleDecodingError","typeClass","type","kind","value","asHex","toHexString","decodeString","exports","badlyEncodedString","String","fromCharCode","apply","correctlyEncodedString","decode","asString","_a","hexString"],"sources":["../../../../lib/bytes/decode/index.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAAA,OAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,MAAMC,KAAK,GAAG,IAAAH,OAAA,CAAAI,OAAW,EAAC,oBAAoB,CAAC;AAE/C,MAAAC,MAAA,GAAAJ,eAAA,CAAAC,OAAA;AACA,MAAAI,UAAA,GAAAC,YAAA,CAAAL,OAAA;AAKA,MAAAM,QAAA,GAAAN,OAAA;AACA,MAAAO,MAAA,GAAAR,eAAA,CAAAC,OAAA;AAEA,SAAiBQ,WAAWA,CAC1BC,QAAiE,EACjEC,OAA4B,EAC5BC,IAAiB;EAAA,IACjBC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA0B,EAAE;EAAA;IAE5B,MAAM;MAAEG;IAAK,CAAE,GAAGL,IAAI;IACtB,MAAM;MAAEM,aAAa,EAAEC;IAAM,CAAE,GAAGN,OAAO,CAAC,CAAC;IAE3C,IAAIO,KAAiB;IACrB,IAAI;MACFA,KAAK,GAAG,OAAO,IAAAhB,MAAA,CAAAD,OAAI,EAACQ,OAAO,EAAEM,KAAK,CAAC;KACpC,CAAC,OAAOI,KAAK,EAAE;MACdnB,KAAK,CAAC,iCAAiC,EAAES,OAAO,EAAEM,KAAK,CAAC;MACxD,OAAO,IAAAV,QAAA,CAAAe,mBAAmB,EAACZ,QAAQ,EAAEW,KAAK,EAAEF,MAAM,CAAC;;IAGrDjB,KAAK,CAAC,SAAS,EAAEQ,QAAQ,CAAC;IAC1BR,KAAK,CAAC,YAAY,EAAES,OAAO,CAAC;IAE5B;IAEA,QAAQD,QAAQ,CAACa,SAAS;MACxB,KAAK,OAAO;QACV;QACA;QACA,OAAO;UACLC,IAAI,EAAEd,QAAQ;UACde,IAAI,EAAE,OAAgB;UACtBC,KAAK,EAAE;YACLC,KAAK,EAAEtB,UAAU,CAACuB,WAAW,CAACR,KAAK;;SAEtC;MAEH,KAAK,QAAQ;QACX,OAAO;UACLI,IAAI,EAAEd,QAAQ;UACde,IAAI,EAAE,OAAgB;UACtBC,KAAK,EAAEG,YAAY,CAACT,KAAK;SAC1B;;EAEP,CAAC;AAAA;AAzCDU,OAAA,CAAArB,WAAA,GAAAA,WAAA;AA2CA,SAAgBoB,YAAYA,CAACT,KAAiB;EAC5C;EACA;EACA,IAAIW,kBAAkB,GAAGC,MAAM,CAACC,YAAY,CAACC,KAAK,CAAClB,SAAS,EAAEI,KAAK,CAAC;EACpE,IAAI;IACF;IACA,IAAIe,sBAAsB,GAAG3B,MAAA,CAAAL,OAAI,CAACiC,MAAM,CAACL,kBAAkB,CAAC;IAC5D;IACA;IACA;IACA;IACA,OAAO;MACLN,IAAI,EAAE,OAAgB;MACtBY,QAAQ,EAAEF;KACX;GACF,CAAC,OAAAG,EAAA,EAAM;IACN;IACA;IACA,IAAIC,SAAS,GAAGlC,UAAU,CAACuB,WAAW,CAACR,KAAK,CAAC;IAC7C,OAAO;MACLK,IAAI,EAAE,WAAoB;MAC1BE,KAAK,EAAEY;KACR;;AAEL;AAxBAT,OAAA,CAAAD,YAAA,GAAAA,YAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}