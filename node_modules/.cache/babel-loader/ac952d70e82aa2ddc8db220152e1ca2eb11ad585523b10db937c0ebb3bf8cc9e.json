{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.float = void 0;\nconst integer_1 = require(\"./integer\");\nconst FloatHelpers_1 = require(\"./_internals/helpers/FloatHelpers\");\nfunction safeFloatToIndex(f, constraintsLabel) {\n  const conversionTrick = 'you can convert any double to a 32-bit float by using `new Float32Array([myDouble])[0]`';\n  const errorMessage = 'fc.float constraints.' + constraintsLabel + ' must be a 32-bit float - ' + conversionTrick;\n  if (Number.isNaN(f) || Number.isFinite(f) && (f < -FloatHelpers_1.MAX_VALUE_32 || f > FloatHelpers_1.MAX_VALUE_32)) {\n    throw new Error(errorMessage);\n  }\n  const index = (0, FloatHelpers_1.floatToIndex)(f);\n  if (!Number.isInteger(index)) {\n    throw new Error(errorMessage);\n  }\n  return index;\n}\nfunction unmapperFloatToIndex(value) {\n  if (typeof value !== 'number') throw new Error('Unsupported type');\n  return (0, FloatHelpers_1.floatToIndex)(value);\n}\nfunction float() {\n  let constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    noDefaultInfinity = false,\n    noNaN = false,\n    min = noDefaultInfinity ? -FloatHelpers_1.MAX_VALUE_32 : Number.NEGATIVE_INFINITY,\n    max = noDefaultInfinity ? FloatHelpers_1.MAX_VALUE_32 : Number.POSITIVE_INFINITY\n  } = constraints;\n  const minIndex = safeFloatToIndex(min, 'min');\n  const maxIndex = safeFloatToIndex(max, 'max');\n  if (minIndex > maxIndex) {\n    throw new Error('fc.float constraints.min must be smaller or equal to constraints.max');\n  }\n  if (noNaN) {\n    return (0, integer_1.integer)({\n      min: minIndex,\n      max: maxIndex\n    }).map(FloatHelpers_1.indexToFloat, unmapperFloatToIndex);\n  }\n  const minIndexWithNaN = maxIndex > 0 ? minIndex : minIndex - 1;\n  const maxIndexWithNaN = maxIndex > 0 ? maxIndex + 1 : maxIndex;\n  return (0, integer_1.integer)({\n    min: minIndexWithNaN,\n    max: maxIndexWithNaN\n  }).map(index => {\n    if (index > maxIndex || index < minIndex) return Number.NaN;else return (0, FloatHelpers_1.indexToFloat)(index);\n  }, value => {\n    if (typeof value !== 'number') throw new Error('Unsupported type');\n    if (Number.isNaN(value)) return maxIndex !== maxIndexWithNaN ? maxIndexWithNaN : minIndexWithNaN;\n    return (0, FloatHelpers_1.floatToIndex)(value);\n  });\n}\nexports.float = float;","map":{"version":3,"names":["Object","defineProperty","exports","value","float","integer_1","require","FloatHelpers_1","safeFloatToIndex","f","constraintsLabel","conversionTrick","errorMessage","Number","isNaN","isFinite","MAX_VALUE_32","Error","index","floatToIndex","isInteger","unmapperFloatToIndex","constraints","arguments","length","undefined","noDefaultInfinity","noNaN","min","NEGATIVE_INFINITY","max","POSITIVE_INFINITY","minIndex","maxIndex","integer","map","indexToFloat","minIndexWithNaN","maxIndexWithNaN","NaN"],"sources":["/Users/karimelbarbary/Desktop/test4/devote/node_modules/fast-check/lib/arbitrary/float.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.float = void 0;\nconst integer_1 = require(\"./integer\");\nconst FloatHelpers_1 = require(\"./_internals/helpers/FloatHelpers\");\nfunction safeFloatToIndex(f, constraintsLabel) {\n    const conversionTrick = 'you can convert any double to a 32-bit float by using `new Float32Array([myDouble])[0]`';\n    const errorMessage = 'fc.float constraints.' + constraintsLabel + ' must be a 32-bit float - ' + conversionTrick;\n    if (Number.isNaN(f) || (Number.isFinite(f) && (f < -FloatHelpers_1.MAX_VALUE_32 || f > FloatHelpers_1.MAX_VALUE_32))) {\n        throw new Error(errorMessage);\n    }\n    const index = (0, FloatHelpers_1.floatToIndex)(f);\n    if (!Number.isInteger(index)) {\n        throw new Error(errorMessage);\n    }\n    return index;\n}\nfunction unmapperFloatToIndex(value) {\n    if (typeof value !== 'number')\n        throw new Error('Unsupported type');\n    return (0, FloatHelpers_1.floatToIndex)(value);\n}\nfunction float(constraints = {}) {\n    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -FloatHelpers_1.MAX_VALUE_32 : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? FloatHelpers_1.MAX_VALUE_32 : Number.POSITIVE_INFINITY, } = constraints;\n    const minIndex = safeFloatToIndex(min, 'min');\n    const maxIndex = safeFloatToIndex(max, 'max');\n    if (minIndex > maxIndex) {\n        throw new Error('fc.float constraints.min must be smaller or equal to constraints.max');\n    }\n    if (noNaN) {\n        return (0, integer_1.integer)({ min: minIndex, max: maxIndex }).map(FloatHelpers_1.indexToFloat, unmapperFloatToIndex);\n    }\n    const minIndexWithNaN = maxIndex > 0 ? minIndex : minIndex - 1;\n    const maxIndexWithNaN = maxIndex > 0 ? maxIndex + 1 : maxIndex;\n    return (0, integer_1.integer)({ min: minIndexWithNaN, max: maxIndexWithNaN }).map((index) => {\n        if (index > maxIndex || index < minIndex)\n            return Number.NaN;\n        else\n            return (0, FloatHelpers_1.indexToFloat)(index);\n    }, (value) => {\n        if (typeof value !== 'number')\n            throw new Error('Unsupported type');\n        if (Number.isNaN(value))\n            return maxIndex !== maxIndexWithNaN ? maxIndexWithNaN : minIndexWithNaN;\n        return (0, FloatHelpers_1.floatToIndex)(value);\n    });\n}\nexports.float = float;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}