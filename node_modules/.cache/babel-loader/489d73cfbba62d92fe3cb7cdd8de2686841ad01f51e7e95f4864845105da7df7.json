{"ast":null,"code":"\"use strict\";\n\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:abi-data:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst errors_1 = require(\"../../errors\");\nfunction decodeAbi(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    if (Format.Types.isReferenceType(dataType) || dataType.typeClass === \"tuple\") {\n      //I don't want tuples to be considered a reference type, but it makes sense\n      //to group them for this purpose\n      let dynamic;\n      try {\n        dynamic = (0, allocate_1.abiSizeInfo)(dataType, info.allocations.abi).dynamic;\n      } catch (error) {\n        return (0, errors_1.handleDecodingError)(dataType, error, options.strictAbiMode);\n      }\n      if (dynamic) {\n        return yield* decodeAbiReferenceByAddress(dataType, pointer, info, options);\n      } else {\n        return yield* decodeAbiReferenceStatic(dataType, pointer, info, options);\n      }\n    } else {\n      debug(\"pointer %o\", pointer);\n      return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n    }\n  }();\n}\nexports.decodeAbi = decodeAbi;\nfunction decodeAbiReferenceByAddress(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    let {\n      strictAbiMode: strict,\n      abiPointerBase: base,\n      lengthOverride\n    } = options;\n    base = base || 0; //in case base was undefined\n    const {\n      allocations: {\n        abi: allocations\n      },\n      state\n    } = info;\n    debug(\"pointer %o\", pointer);\n    //this variable holds the location we should look to *next*\n    //stack pointers point to calldata; other pointers point to same location\n    const location = pointer.location === \"stack\" || pointer.location === \"stackliteral\" ? \"calldata\" : pointer.location;\n    if (pointer.location !== \"stack\" && pointer.location !== \"stackliteral\") {\n      //length overrides are only applicable when you're decoding a pointer\n      //from the stack!  otherwise they must be ignored!\n      lengthOverride = undefined;\n    }\n    let rawValue;\n    try {\n      rawValue = yield* (0, read_1.default)(pointer, state);\n    } catch (error) {\n      return (0, errors_1.handleDecodingError)(dataType, error, strict);\n    }\n    let rawValueAsBN = Conversion.toBN(rawValue);\n    debug(\"rawValue: %O\", rawValue);\n    debug(\"rawValueAsBN: %O\", rawValueAsBN);\n    let rawValueAsNumber;\n    try {\n      rawValueAsNumber = rawValueAsBN.toNumber();\n    } catch (_a) {\n      let error = {\n        kind: \"OverlargePointersNotImplementedError\",\n        pointerAsBN: rawValueAsBN\n      };\n      if (strict) {\n        throw new errors_1.StopDecodingError(error);\n      }\n      return {\n        //again with the TS failures...\n        type: dataType,\n        kind: \"error\",\n        error\n      };\n    }\n    let startPosition = rawValueAsNumber + base;\n    debug(\"startPosition %d\", startPosition);\n    let dynamic;\n    let size;\n    try {\n      ({\n        dynamic,\n        size\n      } = (0, allocate_1.abiSizeInfo)(dataType, allocations));\n    } catch (error) {\n      return (0, errors_1.handleDecodingError)(dataType, error, strict);\n    }\n    if (!dynamic) {\n      //this will only come up when called from stack.ts\n      let staticPointer = {\n        location,\n        start: startPosition,\n        length: size\n      };\n      return yield* decodeAbiReferenceStatic(dataType, staticPointer, info, options);\n    }\n    let length;\n    let lengthAsBN;\n    let rawLength;\n    switch (dataType.typeClass) {\n      case \"bytes\":\n      case \"string\":\n        //initial word contains length (unless an override was given)\n        if (lengthOverride !== undefined) {\n          lengthAsBN = lengthOverride;\n          //note in this case we do *not* increment start position;\n          //if a length override is given, that means the given start\n          //position skips over the length word!\n        } else {\n          try {\n            rawLength = yield* (0, read_1.default)({\n              location,\n              start: startPosition,\n              length: Evm.Utils.WORD_SIZE\n            }, state);\n          } catch (error) {\n            return (0, errors_1.handleDecodingError)(dataType, error, strict);\n          }\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length\n          //so it'll be set up to read the data\n        }\n\n        if (strict && lengthAsBN.gtn(state[location].length)) {\n          //you may notice that the comparison is a bit crude; that's OK, this is\n          //just to prevent huge numbers from DOSing us, other errors will still\n          //be caught regardless\n          throw new errors_1.StopDecodingError({\n            kind: \"OverlongArrayOrStringStrictModeError\",\n            lengthAsBN,\n            dataLength: state[location].length\n          });\n        }\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_b) {\n          //note: if we're in this situation, we can assume we're not in strict mode,\n          //as the strict case was handled above\n          return {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN\n            }\n          };\n        }\n        let childPointer = {\n          location,\n          start: startPosition,\n          length\n        };\n        return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info, options);\n      case \"array\":\n        if (dataType.kind === \"static\") {\n          //static-length array\n          lengthAsBN = dataType.length;\n          //note we don't increment start position; static arrays don't\n          //include a length word!\n        } else if (lengthOverride !== undefined) {\n          debug(\"override: %o\", lengthOverride);\n          //dynamic-length array, but with length override\n          lengthAsBN = lengthOverride;\n          //we don't increment start position; if a length override was\n          //given, that means the pointer skipped the length word!\n        } else {\n          //dynamic-length array, read length from data\n          //initial word contains array length\n          try {\n            rawLength = yield* (0, read_1.default)({\n              location,\n              start: startPosition,\n              length: Evm.Utils.WORD_SIZE\n            }, state);\n          } catch (error) {\n            return (0, errors_1.handleDecodingError)(dataType, error, strict);\n          }\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n          //to next word, as first word was used for length\n        }\n\n        if (strict && lengthAsBN.gtn(state[location].length)) {\n          //you may notice that the comparison is a bit crude; that's OK, this is\n          //just to prevent huge numbers from DOSing us, other errors will still\n          //be caught regardless\n          throw new errors_1.StopDecodingError({\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN,\n            dataLength: state[location].length\n          });\n        }\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_c) {\n          //again, if we get here, we can assume we're not in strict mode\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN\n            }\n          };\n        }\n        //note: I've written this fairly generically, but it is worth noting that\n        //since this array is of dynamic type, we know that if it's static length\n        //then size must be EVM.WORD_SIZE\n        let baseSize;\n        try {\n          baseSize = (0, allocate_1.abiSizeInfo)(dataType.baseType, allocations).size;\n        } catch (error) {\n          return (0, errors_1.handleDecodingError)(dataType, error, strict);\n        }\n        let decodedChildren = [];\n        for (let index = 0; index < length; index++) {\n          decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n            location,\n            start: startPosition + index * baseSize,\n            length: baseSize\n          }, info, Object.assign(Object.assign({}, options), {\n            abiPointerBase: startPosition\n          }))); //pointer base is always start of list, never the length\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedChildren\n        };\n      case \"struct\":\n        return yield* decodeAbiStructByPosition(dataType, location, startPosition, info, options);\n      case \"tuple\":\n        return yield* decodeAbiTupleByPosition(dataType, location, startPosition, info, options);\n    }\n  }();\n}\nexports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;\nfunction decodeAbiReferenceStatic(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function* () {\n    debug(\"static\");\n    debug(\"pointer %o\", pointer);\n    const location = pointer.location;\n    switch (dataType.typeClass) {\n      case \"array\":\n        //we're in the static case, so we know the array must be statically sized\n        const lengthAsBN = dataType.length;\n        let length;\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_a) {\n          //note: since this is the static case, we don't bother including the stronger\n          //strict-mode guard against getting DOSed by large array sizes, since in this\n          //case we're not reading the size from the input; if there's a huge static size\n          //array, well, we'll just have to deal with it\n          let error = {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN\n          };\n          if (options.strictAbiMode) {\n            throw new errors_1.StopDecodingError(error);\n          }\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n        let baseSize;\n        try {\n          baseSize = (0, allocate_1.abiSizeInfo)(dataType.baseType, info.allocations.abi).size;\n        } catch (error) {\n          return (0, errors_1.handleDecodingError)(dataType, error, options.strictAbiMode);\n        }\n        let decodedChildren = [];\n        for (let index = 0; index < length; index++) {\n          decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n            location,\n            start: pointer.start + index * baseSize,\n            length: baseSize\n          }, info, options));\n        }\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedChildren\n        };\n      case \"struct\":\n        return yield* decodeAbiStructByPosition(dataType, location, pointer.start, info, options);\n      case \"tuple\":\n        return yield* decodeAbiTupleByPosition(dataType, location, pointer.start, info, options);\n    }\n  }();\n}\nexports.decodeAbiReferenceStatic = decodeAbiReferenceStatic;\n//note that this function takes the start position as a *number*; it does not take a pointer\nfunction decodeAbiStructByPosition(dataType, location, startPosition, info) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  return function* () {\n    const {\n      allocations: {\n        abi: allocations\n      }\n    } = info;\n    const typeLocation = location === \"calldata\" ? \"calldata\" : null; //other abi locations are not valid type locations\n    const typeId = dataType.id;\n    const structAllocation = allocations[typeId];\n    if (!structAllocation) {\n      let error = {\n        kind: \"UserDefinedTypeNotFoundError\",\n        type: dataType\n      };\n      if (options.strictAbiMode || options.allowRetry) {\n        throw new errors_1.StopDecodingError(error, true);\n        //note that we allow a retry if we couldn't locate the allocation!\n      }\n\n      return {\n        type: dataType,\n        kind: \"error\",\n        error\n      };\n    }\n    let decodedMembers = [];\n    for (let index = 0; index < structAllocation.members.length; index++) {\n      const memberAllocation = structAllocation.members[index];\n      const memberPointer = memberAllocation.pointer;\n      const childPointer = {\n        location,\n        start: startPosition + memberPointer.start,\n        length: memberPointer.length\n      };\n      let memberName = memberAllocation.name;\n      let memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);\n      decodedMembers.push({\n        name: memberName,\n        value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n          abiPointerBase: startPosition\n        }))\n        //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n      });\n    }\n\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: decodedMembers\n    };\n  }();\n}\n//note that this function takes the start position as a *number*; it does not take a pointer\nfunction decodeAbiTupleByPosition(dataType, location, startPosition, info) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  return function* () {\n    //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n    //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder\n    //However it may be worth revisiting this in the future if performance turns out to be a problem\n    //(changing this may be pretty hard though)\n    let decodedMembers = [];\n    let position = startPosition;\n    for (const {\n      name,\n      type: memberType\n    } of dataType.memberTypes) {\n      const memberSize = (0, allocate_1.abiSizeInfo)(memberType, info.allocations.abi).size;\n      const childPointer = {\n        location,\n        start: position,\n        length: memberSize\n      };\n      decodedMembers.push({\n        name,\n        value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n          abiPointerBase: startPosition\n        }))\n        //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n      });\n\n      position += memberSize;\n    }\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: decodedMembers\n    };\n  }();\n}","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","read_1","Conversion","__importStar","Basic","Bytes","Format","Evm","allocate_1","errors_1","decodeAbi","dataType","pointer","info","options","arguments","length","undefined","Types","isReferenceType","typeClass","dynamic","abiSizeInfo","allocations","abi","error","handleDecodingError","strictAbiMode","decodeAbiReferenceByAddress","decodeAbiReferenceStatic","Decode","decodeBasic","exports","strict","abiPointerBase","base","lengthOverride","state","location","rawValue","rawValueAsBN","toBN","rawValueAsNumber","toNumber","_a","kind","pointerAsBN","StopDecodingError","type","startPosition","size","staticPointer","start","lengthAsBN","rawLength","Utils","WORD_SIZE","gtn","dataLength","_b","childPointer","decodeBytes","_c","baseSize","baseType","decodedChildren","index","push","Object","assign","value","decodeAbiStructByPosition","decodeAbiTupleByPosition","typeLocation","typeId","id","structAllocation","allowRetry","decodedMembers","members","memberAllocation","memberPointer","memberName","name","memberType","specifyLocation","position","memberTypes","memberSize"],"sources":["../../../../lib/abi-data/decode/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}