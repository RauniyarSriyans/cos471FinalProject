{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeTupleAbiWithSelector = exports.encodeTupleAbi = exports.encodeAbi = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:abi-data:encode\");\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst sum_1 = __importDefault(require(\"lodash/sum\"));\n//UGH -- it turns out TypeScript can't handle nested tagged unions\n//see: https://github.com/microsoft/TypeScript/issues/18758\n//so, I'm just going to have to throw in a bunch of type coercions >_>\n/**\n * @Category Encoding (low-level)\n */\nfunction encodeAbi(input, allocations) {\n  //errors can't be encoded\n  if (input.kind === \"error\") {\n    return undefined;\n  }\n  let bytes;\n  //TypeScript can at least infer in the rest of this that we're looking\n  //at a value, not an error!  But that's hardly enough...\n  switch (input.type.typeClass) {\n    case \"mapping\":\n    case \"magic\":\n    case \"type\":\n      //none of these can go in the ABI\n      return undefined;\n    case \"bytes\":\n      switch (input.type.kind) {\n        case \"static\":\n          return Basic.Encode.encodeBasic(input);\n        case \"dynamic\":\n          bytes = Bytes.Encode.encodeBytes(input);\n          return padAndPrependLength(bytes);\n      }\n    case \"string\":\n      bytes = Bytes.Encode.encodeBytes(input);\n      return padAndPrependLength(bytes);\n    case \"function\":\n      {\n        switch (input.type.visibility) {\n          case \"internal\":\n            return undefined;\n          //internal functions can't go in the ABI!\n          //Yes, technically we could defer to encodeBasic here, but,\n          //c'mon, that's not how the function's supposed to be used\n          case \"external\":\n            return Basic.Encode.encodeBasic(input);\n        }\n      }\n    //now for the serious cases\n    case \"array\":\n      {\n        let coercedInput = input;\n        if (coercedInput.reference !== undefined) {\n          return undefined; //circular values can't be encoded\n        }\n\n        let staticEncoding = encodeTupleAbi(coercedInput.value, allocations);\n        switch (input.type.kind) {\n          case \"static\":\n            return staticEncoding;\n          case \"dynamic\":\n            let encoded = new Uint8Array(Evm.Utils.WORD_SIZE + staticEncoding.length); //leave room for length\n            encoded.set(staticEncoding, Evm.Utils.WORD_SIZE); //again, leave room for length beforehand\n            let lengthBytes = Conversion.toBytes(coercedInput.value.length, Evm.Utils.WORD_SIZE);\n            encoded.set(lengthBytes); //and now we set the length\n            return encoded;\n        }\n      }\n    case \"struct\":\n      {\n        let coercedInput = input;\n        if (coercedInput.reference !== undefined) {\n          return undefined; //circular values can't be encoded\n        }\n\n        return encodeTupleAbi(coercedInput.value.map(_ref => {\n          let {\n            value\n          } = _ref;\n          return value;\n        }), allocations);\n      }\n    case \"tuple\":\n      //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n      //(That may not be apparent from this one line, but it's true)\n      //I'm writing it this way anyway for simplicity, to avoid rewriting the encoder\n      //However it may be worth revisiting this in the future if performance turns out to be a problem\n      return encodeTupleAbi(input.value.map(_ref2 => {\n        let {\n          value\n        } = _ref2;\n        return value;\n      }), allocations);\n    default:\n      return Basic.Encode.encodeBasic(input);\n  }\n}\nexports.encodeAbi = encodeAbi;\n/**\n * @Category Encoding (low-level)\n */\nfunction padAndPrependLength(bytes) {\n  let length = bytes.length;\n  let paddedLength = Evm.Utils.WORD_SIZE * Math.ceil(length / Evm.Utils.WORD_SIZE);\n  let encoded = new Uint8Array(Evm.Utils.WORD_SIZE + paddedLength);\n  encoded.set(bytes, Evm.Utils.WORD_SIZE); //start 32 in to leave room for the length beforehand\n  let lengthBytes = Conversion.toBytes(length, Evm.Utils.WORD_SIZE);\n  encoded.set(lengthBytes); //and now we set the length\n  return encoded;\n}\n/**\n * @Category Encoding (low-level)\n */\nfunction encodeTupleAbi(tuple, allocations) {\n  let elementEncodings = tuple.map(element => encodeAbi(element, allocations));\n  if (elementEncodings.some(element => element === undefined)) {\n    return undefined;\n  }\n  let elementSizeInfo = tuple.map(element => (0, allocate_1.abiSizeInfo)(element.type, allocations));\n  //heads and tails here are as discussed in the ABI docs;\n  //for a static type the head is the encoding and the tail is empty,\n  //for a dynamic type the head is the pointer and the tail is the encoding\n  let heads = [];\n  let tails = [];\n  //but first, we need to figure out where the first tail will start,\n  //by adding up the sizes of all the heads (we can easily do this in\n  //advance via elementSizeInfo, without needing to know the particular\n  //values of the heads)\n  let startOfNextTail = (0, sum_1.default)(elementSizeInfo.map(elementInfo => elementInfo.size));\n  for (let i = 0; i < tuple.length; i++) {\n    let head;\n    let tail;\n    if (!elementSizeInfo[i].dynamic) {\n      //static case\n      head = elementEncodings[i];\n      tail = new Uint8Array(); //empty array\n    } else {\n      //dynamic case\n      head = Conversion.toBytes(startOfNextTail, Evm.Utils.WORD_SIZE);\n      tail = elementEncodings[i];\n    }\n    heads.push(head);\n    tails.push(tail);\n    startOfNextTail += tail.length;\n  }\n  //finally, we need to concatenate everything together!\n  //since we're dealing with Uint8Arrays, we have to do this manually\n  let totalSize = startOfNextTail;\n  let encoded = new Uint8Array(totalSize);\n  let position = 0;\n  for (let head of heads) {\n    encoded.set(head, position);\n    position += head.length;\n  }\n  for (let tail of tails) {\n    encoded.set(tail, position);\n    position += tail.length;\n  }\n  return encoded;\n}\nexports.encodeTupleAbi = encodeTupleAbi;\n/**\n * @Category Encoding (low-level)\n */\nfunction encodeTupleAbiWithSelector(tuple, selector, allocations) {\n  const encodedTuple = encodeTupleAbi(tuple, allocations);\n  if (!encodedTuple) {\n    return undefined;\n  }\n  const encoded = new Uint8Array(selector.length + encodedTuple.length);\n  encoded.set(selector);\n  encoded.set(encodedTuple, selector.length);\n  return encoded;\n}\nexports.encodeTupleAbiWithSelector = encodeTupleAbiWithSelector;","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","Conversion","__importStar","Basic","Bytes","Evm","allocate_1","sum_1","encodeAbi","input","allocations","kind","undefined","bytes","type","typeClass","Encode","encodeBasic","encodeBytes","padAndPrependLength","visibility","coercedInput","reference","staticEncoding","encodeTupleAbi","value","encoded","Uint8Array","Utils","WORD_SIZE","length","set","lengthBytes","toBytes","map","_ref","_ref2","exports","paddedLength","Math","ceil","tuple","elementEncodings","element","some","elementSizeInfo","abiSizeInfo","heads","tails","startOfNextTail","elementInfo","size","i","head","tail","dynamic","push","totalSize","position","encodeTupleAbiWithSelector","selector","encodedTuple"],"sources":["../../../../lib/abi-data/encode/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}