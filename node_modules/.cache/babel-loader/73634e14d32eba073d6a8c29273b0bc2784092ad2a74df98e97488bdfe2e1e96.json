{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrap = exports.udvtCases = exports.txOptionsCases = exports.tupleCases = exports.arrayCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:wrap\");\nconst Format = __importStar(require(\"../format\"));\nconst errors_1 = require(\"./errors\");\nconst dispatch_1 = require(\"./dispatch\");\nconst Messages = __importStar(require(\"./messages\"));\nconst Conversion = __importStar(require(\"../conversion\"));\nconst Utils = __importStar(require(\"./utils\"));\nconst integer_1 = require(\"./integer\");\nconst decimal_1 = require(\"./decimal\");\nconst bool_1 = require(\"./bool\");\nconst bytes_1 = require(\"./bytes\");\nconst address_1 = require(\"./address\");\nconst string_1 = require(\"./string\");\nconst function_1 = require(\"./function\");\n//this file contains the main wrap function, as well as the cases\n//for arrays, tuples, udvts, and tx options.  all other types get their\n//own file.\nconst arrayCasesBasic = [arrayFromArray, arrayFromCodecArrayValue, arrayFromJson, arrayFailureCase];\nexports.arrayCases = [arrayFromTypeValueInput, ...arrayCasesBasic];\nconst tupleCasesBasic = [tupleFromArray, tupleFromCodecTupleLikeValue, tupleFromObject, tupleFromJson, tupleFailureCase];\nexports.tupleCases = [tupleFromTypeValueInput, ...tupleCasesBasic];\nconst txOptionsCasesBasic = [optionsFromCodecOptionsValue, optionsFromObject, optionsFailureCase];\nexports.txOptionsCases = [optionsFromTypeValueInput, ...txOptionsCasesBasic];\nexports.udvtCases = [\n//no separate case for udvtFromUdvtValue,\n//since underlying already handles this\nudvtFromUnderlying];\nfunction* wrap(dataType, input, wrapOptions) {\n  if (!wrapOptions.name) {\n    wrapOptions = Object.assign(Object.assign({}, wrapOptions), {\n      name: \"<input>\"\n    });\n  }\n  switch (dataType.typeClass) {\n    case \"uint\":\n    case \"int\":\n    case \"enum\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, integer_1.integerCases);\n    case \"fixed\":\n    case \"ufixed\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, decimal_1.decimalCases);\n    case \"bool\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, bool_1.boolCases);\n    case \"bytes\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, bytes_1.bytesCases);\n    case \"address\":\n    case \"contract\":\n      //these are treated the same\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, address_1.addressCases);\n    case \"string\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, string_1.stringCases);\n    case \"function\":\n      //special check: weed out internal functions\n      if (dataType.visibility === \"internal\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5,\n        //it doesn't matter, but we'll make this error high specificity\n        `Wrapping/encoding for internal function pointers is not supported`);\n      }\n      //otherwise, go ahead\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, function_1.functionExternalCases);\n    case \"array\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.arrayCases);\n    case \"struct\":\n    case \"tuple\":\n      //these are treated the same as well\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.tupleCases);\n    case \"userDefinedValueType\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.udvtCases);\n    case \"options\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.txOptionsCases);\n    default:\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5,\n      //it doesn't matter, but we'll make this error high specificity\n      `Wrapping/encoding for type ${Format.Types.typeStringWithoutLocation(dataType)} is not supported`);\n  }\n}\nexports.wrap = wrap;\n//array cases\nfunction* arrayFromArray(dataType, input, wrapOptions) {\n  if (!Array.isArray(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an array\");\n  }\n  if (dataType.kind === \"static\" && !dataType.length.eqn(input.length)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(dataType.length, input.length));\n  }\n  //can't do yield in a map, so manual loop here\n  let value = [];\n  for (let index = 0; index < input.length; index++) {\n    value.push(yield* wrap(dataType.baseType, input[index], Object.assign(Object.assign({}, wrapOptions), {\n      name: `${wrapOptions.name}[${index}]`,\n      specificityFloor: 5 //errors in components are quite specific!\n    })));\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\nfunction* arrayFromCodecArrayValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"array\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  //we won't bother with detailed typechecking as much of it is handled\n  //either in the call to arrayFromArray or in the wrapping of the\n  //individual elements; we will check dynamic vs static though as that\n  //isn't handled elsewhere\n  if (!wrapOptions.loose && input.type.kind === dataType.kind) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  //note that we do *not* just copy over input.value, but rather we\n  //defer to arrayFromArray; this is because there might be some elements\n  //where the type is not the same but is compatible\n  const value = input.value;\n  return yield* arrayFromArray(dataType, value, wrapOptions);\n}\nfunction* arrayFromJson(dataType, input, wrapOptions) {\n  if (!wrapOptions.allowJson) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"JSON input must be explicitly enabled\");\n  }\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  let parsedInput;\n  try {\n    parsedInput = JSON.parse(input);\n  } catch (error) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Input was not valid JSON: ${error.message}`);\n  }\n  return yield* arrayFromArray(dataType, parsedInput, wrapOptions);\n}\nfunction* arrayFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n  if (input.type !== \"array\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n  //don't turn on loose here, only do that for non-container types!\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, arrayCasesBasic);\n}\nfunction* arrayFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not an array, type/value pair or wrapped array\");\n}\n//tuple/struct cases;\n//note even with loose turned off, we won't distinguish\n//between tuples and structs\nfunction* tupleFromArray(dataType, input, wrapOptions) {\n  //first: obtain the types of the members\n  if (!Array.isArray(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an array\");\n  }\n  debug(\"input is array\");\n  const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);\n  if (memberTypes.length !== input.length) {\n    debug(\"input is wrong-length array\");\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(memberTypes.length, input.length));\n  }\n  //can't do yield in a map, so manual loop here\n  let value = [];\n  for (let index = 0; index < input.length; index++) {\n    const memberName = memberTypes[index].name;\n    debug(\"wrapping %s\", memberName);\n    value.push({\n      name: memberName,\n      value: yield* wrap(memberTypes[index].type, input[index], Object.assign(Object.assign({}, wrapOptions), {\n        name: memberName ? wrapOptions.name.match(/^<.*>$/) //hack?\n        ? memberName : `${wrapOptions.name}.${memberName}` : `${wrapOptions.name}[${index}]`,\n        specificityFloor: 5\n      }))\n    });\n  }\n  //we need to coerce here because TS doesn't know that if it's a struct\n  //then everything has a name\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\nfunction* tupleFromObject(dataType, input, wrapOptions) {\n  if (!Utils.isPlainObject(input)) {\n    //just checks that it's an object & not null\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a non-null object\");\n  }\n  if (!wrapOptions.loose && Utils.isTypeValueInput(input)) {\n    //let's exclude these unless loose is turned on\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a type/value pair\");\n  }\n  if (!wrapOptions.loose && Utils.isWrappedResult(input)) {\n    //similarly here\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n  }\n  const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);\n  if (memberTypes.some(_ref => {\n    let {\n      name\n    } = _ref;\n    return !name;\n  })) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, \"Plain object input is allowed only when all elements of tuple are named\");\n  }\n  let unusedKeys = new Set(Object.keys(input));\n  let value = [];\n  for (let index = 0; index < memberTypes.length; index++) {\n    //note we had better process these in order!\n    const memberName = memberTypes[index].name;\n    if (!(memberName in input)) {\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Missing key from tuple or struct: ${memberName}`);\n    }\n    unusedKeys.delete(memberName);\n    value.push({\n      name: memberName,\n      value: yield* wrap(memberTypes[index].type, input[memberName], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${memberName}`,\n        specificityFloor: 4 //not sure this warrants a 5\n      }))\n    });\n  }\n\n  if (!wrapOptions.loose) {\n    if (unusedKeys.size > 0) {\n      //choose one arbitrarily\n      const exampleKey = unusedKeys.values().next().value;\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Unknown key ${exampleKey} included`);\n    }\n  }\n  //we need to coerce here because TS doesn't know that if it's a struct\n  //then everything has a name\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\nfunction* tupleFromJson(dataType, input, wrapOptions) {\n  if (!wrapOptions.allowJson) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"JSON input must be explicitly enabled\");\n  }\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n  let parsedInput;\n  try {\n    parsedInput = JSON.parse(input);\n  } catch (error) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Input was not valid JSON: ${error.message}`);\n  }\n  debug(\"input is JSON\");\n  debug(\"parses to: %O\", parsedInput);\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, parsedInput, wrapOptions, [tupleFromObject, tupleFromArray]);\n}\nfunction* tupleFromCodecTupleLikeValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"tuple\" && input.type.typeClass !== \"struct\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  //not going to do much typechecking here as it'll be handled in the call\n  //to tupleFromArray\n  //Typescript complains if I try to say it can be either struct or\n  //tuple, so, uh, let's just tell it it's a tuple <shrug>\n  const coercedInput = input; //HACK!\n  //note that we do *not* just copy over input.value, but rather we\n  //defer to tupleFromArray; this is because there might be some elements\n  //where the type is not the same but is compatible\n  return yield* tupleFromArray(dataType, coercedInput.value.map(_ref2 => {\n    let {\n      value\n    } = _ref2;\n    return value;\n  }), wrapOptions);\n}\nfunction* tupleFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n  if (input.type !== \"tuple\" && input.type !== \"struct\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n  //don't turn on loose here, only do that for non-container types!\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, tupleCasesBasic);\n}\nfunction* tupleFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not an array, plain object, type/value pair or wrapped tuple or struct\");\n}\nfunction memberTypesForType(dataType, userDefinedTypes) {\n  switch (dataType.typeClass) {\n    case \"tuple\":\n      return dataType.memberTypes;\n      break;\n    case \"struct\":\n      debug(\"wrapping for struct %s\", dataType.typeName);\n      return Format.Types.fullType(dataType, userDefinedTypes).memberTypes;\n  }\n}\n//udvt cases\nfunction* udvtFromUnderlying(dataType, input, wrapOptions) {\n  const {\n    underlyingType\n  } = Format.Types.fullType(dataType, wrapOptions.userDefinedTypes);\n  const value = yield* wrap(underlyingType, input, wrapOptions);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: value\n  };\n}\n//tx options cases\nfunction* optionsFromObject(dataType, input, wrapOptions) {\n  if (!Utils.isPlainObject(input)) {\n    //just checks that it's an object & not null\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a non-null object\");\n  }\n  debug(\"options input is object: %O\", input);\n  debug(\"wrapOptions: %O\", wrapOptions);\n  if (!wrapOptions.loose && Utils.isWrappedResult(input)) {\n    //similarly here\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n  }\n  //now... the main case\n  let value = {};\n  const uintKeys = [\"gas\", \"gasPrice\", \"value\", \"nonce\", \"maxFeePerGas\", \"maxPriorityFeePerGas\"];\n  const uint8Keys = [\"type\"];\n  const addressKeys = [\"from\", \"to\"];\n  const bytesKeys = [\"data\"];\n  const boolKeys = [\"overwrite\"];\n  const accessListKeys = [\"accessList\"];\n  const specialKeys = [\"privateFor\"];\n  const allKeys = [...uintKeys, ...uint8Keys, ...addressKeys, ...bytesKeys, ...boolKeys, ...accessListKeys, ...specialKeys];\n  const badKey = Object.keys(input).find(key => !allKeys.includes(key));\n  const goodKey = Object.keys(input).find(key => allKeys.includes(key));\n  if (badKey !== undefined && !wrapOptions.oldOptionsBehavior) {\n    //note we allow extra keys if oldOptionsBehavior is on -- this is a HACK\n    //to preserve existing behavior of Truffle Contract (perhaps we can\n    //change this in Truffle 6)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included unknown option ${badKey}`);\n  }\n  if (wrapOptions.oldOptionsBehavior && goodKey === undefined) {\n    //similarly, if oldOptionsBehavior is on, we require at least\n    //one *legit* key (again, HACK to preserve existing behavior,\n    //maybe remove this in Truffle 6)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included no recognized options`);\n  }\n  //otherwise, if all keys are transaction options, let's process them...\n  //part 1: uint options\n  for (const key of uintKeys) {\n    //note we check input[key] !== undefined, rather than key in input,\n    //because if one of them is undefined we want to just allow that but ignore it\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"uint\",\n        bits: 256\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), integer_1.integerCases);\n      value[key] = wrappedOption.value.asBN;\n    }\n  }\n  //part 2: uint8 options (just type for now)\n  for (const key of uint8Keys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"uint\",\n        bits: 8\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), integer_1.integerCases);\n      const asBN = wrappedOption.value.asBN;\n      //since this is just type right now, we're going to reject illegal types\n      if (asBN.gten(0xc0)) {\n        //not making a constant for this, this is its only use here\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.type`, 4, \"Transaction types must be less than 0xc0\");\n      }\n      //for compatibility, we give type as a hex string rather than\n      //leaving it as a BN.  Since it's unsigned we don't have to\n      //worry about negatives.\n      value[key] = Conversion.toHexString(asBN);\n    }\n  }\n  //part 3: address options\n  for (const key of addressKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"address\",\n        kind: \"general\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), address_1.addressCases);\n      value[key] = wrappedOption.value.asAddress;\n    }\n  }\n  //part 4: bytestring options\n  for (const key of bytesKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"bytes\",\n        kind: \"dynamic\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), bytes_1.bytesCases);\n      value[key] = wrappedOption.value.asHex;\n    }\n  }\n  //part 5: boolean options\n  for (const key of boolKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"bool\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), bool_1.boolCases);\n      value[key] = wrappedOption.value.asBoolean;\n    }\n  }\n  //part 6: the access list\n  for (const key of accessListKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"array\",\n        kind: \"dynamic\",\n        baseType: {\n          typeClass: \"tuple\",\n          memberTypes: [{\n            name: \"address\",\n            type: {\n              typeClass: \"address\",\n              kind: \"general\"\n            }\n          }, {\n            name: \"storageKeys\",\n            type: {\n              typeClass: \"array\",\n              kind: \"dynamic\",\n              baseType: {\n                //we use uint256 rather than bytes32 to allow\n                //abbreviating and left-padding\n                typeClass: \"uint\",\n                bits: 256\n              }\n            }\n          }]\n        }\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), exports.arrayCases);\n      value[key] = Format.Utils.Inspect.nativizeAccessList(wrappedOption);\n    }\n  }\n  //part 7: the special case of privateFor\n  if (input.privateFor !== undefined) {\n    //this doesn't correspond to any of our usual types, so we have to handle it specially\n    if (!Array.isArray(input.privateFor)) {\n      throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, \"Transaction option privateFor should be an array of base64-encoded bytestrings of 32 bytes\");\n    }\n    value.privateFor = input.privateFor.map((publicKey, index) => {\n      if (Utils.isBoxedString(publicKey)) {\n        publicKey = publicKey.valueOf();\n      }\n      if (typeof publicKey !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not a string`);\n      }\n      if (!Utils.isBase64(publicKey)) {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not base64-encoded`);\n      }\n      const length = Utils.base64Length(publicKey);\n      if (length !== 32) {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} should encode a bytestring of 32 bytes; got ${length} bytes instead`);\n      }\n      return publicKey;\n    });\n  }\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\nfunction* optionsFromCodecOptionsValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n  if (input.type.typeClass !== \"options\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n  const value = input.value;\n  //unlike in the array or tuple cases, here should not have\n  //to worry about compatible-but-not-identical types, so it's\n  //safe to just copy value over\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\nfunction* optionsFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n  if (input.type !== \"options\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n  //because options, unlike other containers, has specific types, we *will* turn on loose\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), txOptionsCasesBasic);\n}\nfunction* optionsFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Transaction options input was not a plain object, type/value pair or wrapped options object\");\n}","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","Format","__importStar","errors_1","dispatch_1","Messages","Conversion","Utils","integer_1","decimal_1","bool_1","bytes_1","address_1","string_1","function_1","arrayCasesBasic","arrayFromArray","arrayFromCodecArrayValue","arrayFromJson","arrayFailureCase","exports","arrayCases","arrayFromTypeValueInput","tupleCasesBasic","tupleFromArray","tupleFromCodecTupleLikeValue","tupleFromObject","tupleFromJson","tupleFailureCase","tupleCases","tupleFromTypeValueInput","txOptionsCasesBasic","optionsFromCodecOptionsValue","optionsFromObject","optionsFailureCase","txOptionsCases","optionsFromTypeValueInput","udvtCases","udvtFromUnderlying","wrap","dataType","input","wrapOptions","name","Object","assign","typeClass","wrapWithCases","integerCases","decimalCases","boolCases","bytesCases","addressCases","stringCases","visibility","TypeMismatchError","functionExternalCases","Types","typeStringWithoutLocation","Array","isArray","kind","length","eqn","wrongArrayLengthMessage","value","index","push","baseType","specificityFloor","type","isWrappedResult","wrappedTypeMessage","errorResultMessage","loose","allowJson","parsedInput","JSON","parse","error","message","isTypeValueInput","specifiedTypeMessage","memberTypes","memberTypesForType","userDefinedTypes","memberName","match","isPlainObject","some","_ref","unusedKeys","Set","keys","delete","size","exampleKey","values","next","coercedInput","map","_ref2","typeName","fullType","underlyingType","uintKeys","uint8Keys","addressKeys","bytesKeys","boolKeys","accessListKeys","specialKeys","allKeys","badKey","find","key","includes","goodKey","undefined","oldOptionsBehavior","wrappedOption","bits","asBN","gten","toHexString","asAddress","asHex","asBoolean","Inspect","nativizeAccessList","privateFor","publicKey","isBoxedString","valueOf","isBase64","base64Length"],"sources":["../../../lib/wrap/wrap.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}