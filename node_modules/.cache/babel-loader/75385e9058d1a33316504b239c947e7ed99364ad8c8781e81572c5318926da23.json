{"ast":null,"code":"\"use strict\";\n\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readStorage = exports.readSlot = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:storage:read\");\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nfunction* readSlot(storage, slot) {\n  const address = Utils.slotAddress(slot);\n  // debug(\"reading slot: %o\", Conversion.toHexString(address));\n  const hexAddress = Conversion.toHexString(address, Evm.Utils.WORD_SIZE);\n  let word = storage[hexAddress];\n  //if we can't find the word in the map, we place a request to the invoker to supply it\n  //(contract-decoder will look it up from the blockchain, while the debugger will just\n  //say 0)\n  if (word === undefined) {\n    word = yield {\n      type: \"storage\",\n      slot: address\n    };\n    if (word === null) {\n      //check for null as a way to deliberately indicate an error\n      throw new errors_1.DecodingError({\n        kind: \"StorageNotSuppliedError\",\n        slot: address\n      });\n    }\n  }\n  return word;\n}\nexports.readSlot = readSlot;\nfunction* readStorage(pointer, state) {\n  const {\n    storage\n  } = state;\n  const {\n    range\n  } = pointer;\n  debug(\"readRange %o\", range);\n  let {\n    from,\n    to,\n    length\n  } = range;\n  from = {\n    slot: from.slot,\n    index: from.index || 0\n  };\n  if (length !== undefined) {\n    to = {\n      slot: {\n        path: from.slot.path || undefined,\n        offset: from.slot.offset.addn(Math.floor((from.index + length - 1) / Evm.Utils.WORD_SIZE))\n      },\n      index: (from.index + length - 1) % Evm.Utils.WORD_SIZE\n    };\n  }\n  debug(\"normalized readRange %o\", {\n    from,\n    to\n  });\n  let totalWordsAsBN = to.slot.offset.sub(from.slot.offset).addn(1);\n  let totalWords;\n  try {\n    totalWords = totalWordsAsBN.toNumber();\n  } catch (_) {\n    throw new errors_1.DecodingError({\n      kind: \"ReadErrorStorage\",\n      range\n    });\n  }\n  let data = new Uint8Array(totalWords * Evm.Utils.WORD_SIZE);\n  for (let i = 0; i < totalWords; i++) {\n    let offset = from.slot.offset.addn(i);\n    const word = yield* readSlot(storage, Object.assign(Object.assign({}, from.slot), {\n      offset\n    }));\n    data.set(word, i * Evm.Utils.WORD_SIZE);\n  }\n  debug(\"words %o\", data);\n  data = data.slice(from.index, (totalWords - 1) * Evm.Utils.WORD_SIZE + to.index + 1);\n  debug(\"data: %o\", data);\n  return data;\n}\nexports.readStorage = readStorage;","map":{"version":3,"names":["debug_1","__importDefault","require","debug","default","Conversion","__importStar","Utils","Evm","errors_1","readSlot","storage","slot","address","slotAddress","hexAddress","toHexString","WORD_SIZE","word","undefined","type","DecodingError","kind","exports","readStorage","pointer","state","range","from","to","length","index","path","offset","addn","Math","floor","totalWordsAsBN","sub","totalWords","toNumber","_","data","Uint8Array","i","Object","assign","set","slice"],"sources":["../../../../lib/storage/read/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}