{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SlicedBasedGenerator = void 0;\nconst Value_1 = require(\"../../../check/arbitrary/definition/Value\");\nclass SlicedBasedGenerator {\n  constructor(arb, mrng, slices, biasFactor) {\n    this.arb = arb;\n    this.mrng = mrng;\n    this.slices = slices;\n    this.biasFactor = biasFactor;\n    this.activeSliceIndex = 0;\n    this.nextIndexInSlice = 0;\n    this.lastIndexInSlice = -1;\n  }\n  attemptExact(targetLength) {\n    if (targetLength !== 0 && this.mrng.nextInt(1, this.biasFactor) === 1) {\n      const eligibleIndices = [];\n      for (let index = 0; index !== this.slices.length; ++index) {\n        const slice = this.slices[index];\n        if (slice.length === targetLength) {\n          eligibleIndices.push(index);\n        }\n      }\n      if (eligibleIndices.length === 0) {\n        return;\n      }\n      this.activeSliceIndex = eligibleIndices[this.mrng.nextInt(0, eligibleIndices.length - 1)];\n      this.nextIndexInSlice = 0;\n      this.lastIndexInSlice = targetLength - 1;\n    }\n  }\n  next() {\n    if (this.nextIndexInSlice <= this.lastIndexInSlice) {\n      return new Value_1.Value(this.slices[this.activeSliceIndex][this.nextIndexInSlice++], undefined);\n    }\n    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {\n      return this.arb.generate(this.mrng, this.biasFactor);\n    }\n    this.activeSliceIndex = this.mrng.nextInt(0, this.slices.length - 1);\n    const slice = this.slices[this.activeSliceIndex];\n    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {\n      this.nextIndexInSlice = 1;\n      this.lastIndexInSlice = slice.length - 1;\n      return new Value_1.Value(slice[0], undefined);\n    }\n    const rangeBoundaryA = this.mrng.nextInt(0, slice.length - 1);\n    const rangeBoundaryB = this.mrng.nextInt(0, slice.length - 1);\n    this.nextIndexInSlice = Math.min(rangeBoundaryA, rangeBoundaryB);\n    this.lastIndexInSlice = Math.max(rangeBoundaryA, rangeBoundaryB);\n    return new Value_1.Value(slice[this.nextIndexInSlice++], undefined);\n  }\n}\nexports.SlicedBasedGenerator = SlicedBasedGenerator;","map":{"version":3,"names":["Object","defineProperty","exports","value","SlicedBasedGenerator","Value_1","require","constructor","arb","mrng","slices","biasFactor","activeSliceIndex","nextIndexInSlice","lastIndexInSlice","attemptExact","targetLength","nextInt","eligibleIndices","index","length","slice","push","next","Value","undefined","generate","rangeBoundaryA","rangeBoundaryB","Math","min","max"],"sources":["/Users/karimelbarbary/Desktop/test4/devote/node_modules/fast-check/lib/arbitrary/_internals/implementations/SlicedBasedGenerator.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SlicedBasedGenerator = void 0;\nconst Value_1 = require(\"../../../check/arbitrary/definition/Value\");\nclass SlicedBasedGenerator {\n    constructor(arb, mrng, slices, biasFactor) {\n        this.arb = arb;\n        this.mrng = mrng;\n        this.slices = slices;\n        this.biasFactor = biasFactor;\n        this.activeSliceIndex = 0;\n        this.nextIndexInSlice = 0;\n        this.lastIndexInSlice = -1;\n    }\n    attemptExact(targetLength) {\n        if (targetLength !== 0 && this.mrng.nextInt(1, this.biasFactor) === 1) {\n            const eligibleIndices = [];\n            for (let index = 0; index !== this.slices.length; ++index) {\n                const slice = this.slices[index];\n                if (slice.length === targetLength) {\n                    eligibleIndices.push(index);\n                }\n            }\n            if (eligibleIndices.length === 0) {\n                return;\n            }\n            this.activeSliceIndex = eligibleIndices[this.mrng.nextInt(0, eligibleIndices.length - 1)];\n            this.nextIndexInSlice = 0;\n            this.lastIndexInSlice = targetLength - 1;\n        }\n    }\n    next() {\n        if (this.nextIndexInSlice <= this.lastIndexInSlice) {\n            return new Value_1.Value(this.slices[this.activeSliceIndex][this.nextIndexInSlice++], undefined);\n        }\n        if (this.mrng.nextInt(1, this.biasFactor) !== 1) {\n            return this.arb.generate(this.mrng, this.biasFactor);\n        }\n        this.activeSliceIndex = this.mrng.nextInt(0, this.slices.length - 1);\n        const slice = this.slices[this.activeSliceIndex];\n        if (this.mrng.nextInt(1, this.biasFactor) !== 1) {\n            this.nextIndexInSlice = 1;\n            this.lastIndexInSlice = slice.length - 1;\n            return new Value_1.Value(slice[0], undefined);\n        }\n        const rangeBoundaryA = this.mrng.nextInt(0, slice.length - 1);\n        const rangeBoundaryB = this.mrng.nextInt(0, slice.length - 1);\n        this.nextIndexInSlice = Math.min(rangeBoundaryA, rangeBoundaryB);\n        this.lastIndexInSlice = Math.max(rangeBoundaryA, rangeBoundaryB);\n        return new Value_1.Value(slice[this.nextIndexInSlice++], undefined);\n    }\n}\nexports.SlicedBasedGenerator = SlicedBasedGenerator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}