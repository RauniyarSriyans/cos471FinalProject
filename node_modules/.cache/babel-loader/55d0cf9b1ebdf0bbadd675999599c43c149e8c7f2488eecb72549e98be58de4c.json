{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayArbitrary = void 0;\nconst Stream_1 = require(\"../../stream/Stream\");\nconst symbols_1 = require(\"../../check/symbols\");\nconst integer_1 = require(\"../integer\");\nconst LazyIterableIterator_1 = require(\"../../stream/LazyIterableIterator\");\nconst Arbitrary_1 = require(\"../../check/arbitrary/definition/Arbitrary\");\nconst Value_1 = require(\"../../check/arbitrary/definition/Value\");\nconst DepthContext_1 = require(\"./helpers/DepthContext\");\nconst BuildSlicedGenerator_1 = require(\"./helpers/BuildSlicedGenerator\");\nfunction biasedMaxLength(minLength, maxLength) {\n  if (minLength === maxLength) {\n    return minLength;\n  }\n  return minLength + Math.floor(Math.log(maxLength - minLength) / Math.log(2));\n}\nclass ArrayArbitrary extends Arbitrary_1.Arbitrary {\n  constructor(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, setBuilder, customSlices) {\n    super();\n    this.arb = arb;\n    this.minLength = minLength;\n    this.maxGeneratedLength = maxGeneratedLength;\n    this.maxLength = maxLength;\n    this.setBuilder = setBuilder;\n    this.customSlices = customSlices;\n    this.lengthArb = (0, integer_1.integer)({\n      min: minLength,\n      max: maxGeneratedLength\n    });\n    this.depthContext = (0, DepthContext_1.getDepthContextFor)(depthIdentifier);\n  }\n  preFilter(tab) {\n    if (this.setBuilder === undefined) {\n      return tab;\n    }\n    const s = this.setBuilder();\n    for (let index = 0; index !== tab.length; ++index) {\n      s.tryAdd(tab[index]);\n    }\n    return s.getData();\n  }\n  static makeItCloneable(vs, shrinkables) {\n    vs[symbols_1.cloneMethod] = () => {\n      const cloned = [];\n      for (let idx = 0; idx !== shrinkables.length; ++idx) {\n        cloned.push(shrinkables[idx].value);\n      }\n      this.makeItCloneable(cloned, shrinkables);\n      return cloned;\n    };\n    return vs;\n  }\n  generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {\n    let numSkippedInRow = 0;\n    const s = setBuilder();\n    const slicedGenerator = (0, BuildSlicedGenerator_1.buildSlicedGenerator)(this.arb, mrng, this.customSlices, biasFactorItems);\n    while (s.size() < N && numSkippedInRow < this.maxGeneratedLength) {\n      const current = slicedGenerator.next();\n      if (s.tryAdd(current)) {\n        numSkippedInRow = 0;\n      } else {\n        numSkippedInRow += 1;\n      }\n    }\n    return s.getData();\n  }\n  safeGenerateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {\n    const depthImpact = Math.max(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));\n    this.depthContext.depth += depthImpact;\n    try {\n      return this.generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems);\n    } finally {\n      this.depthContext.depth -= depthImpact;\n    }\n  }\n  generateNItems(N, mrng, biasFactorItems) {\n    const items = [];\n    const slicedGenerator = (0, BuildSlicedGenerator_1.buildSlicedGenerator)(this.arb, mrng, this.customSlices, biasFactorItems);\n    slicedGenerator.attemptExact(N);\n    for (let index = 0; index !== N; ++index) {\n      const current = slicedGenerator.next();\n      items.push(current);\n    }\n    return items;\n  }\n  safeGenerateNItems(N, mrng, biasFactorItems) {\n    const depthImpact = Math.max(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));\n    this.depthContext.depth += depthImpact;\n    try {\n      return this.generateNItems(N, mrng, biasFactorItems);\n    } finally {\n      this.depthContext.depth -= depthImpact;\n    }\n  }\n  wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {\n    const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;\n    let cloneable = false;\n    const vs = [];\n    const itemsContexts = [];\n    for (let idx = 0; idx !== items.length; ++idx) {\n      const s = items[idx];\n      cloneable = cloneable || s.hasToBeCloned;\n      vs.push(s.value);\n      itemsContexts.push(s.context);\n    }\n    if (cloneable) {\n      ArrayArbitrary.makeItCloneable(vs, items);\n    }\n    const context = {\n      shrunkOnce,\n      lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== undefined ? itemsRawLengthContext : undefined,\n      itemsContexts,\n      startIndex\n    };\n    return new Value_1.Value(vs, context);\n  }\n  generate(mrng, biasFactor) {\n    const biasMeta = this.applyBias(mrng, biasFactor);\n    const targetSize = biasMeta.size;\n    const items = this.setBuilder !== undefined ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems) : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);\n    return this.wrapper(items, false, undefined, 0);\n  }\n  applyBias(mrng, biasFactor) {\n    if (biasFactor === undefined) {\n      return {\n        size: this.lengthArb.generate(mrng, undefined).value\n      };\n    }\n    if (this.minLength === this.maxGeneratedLength) {\n      return {\n        size: this.lengthArb.generate(mrng, undefined).value,\n        biasFactorItems: biasFactor\n      };\n    }\n    if (mrng.nextInt(1, biasFactor) !== 1) {\n      return {\n        size: this.lengthArb.generate(mrng, undefined).value\n      };\n    }\n    if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) {\n      return {\n        size: this.lengthArb.generate(mrng, undefined).value,\n        biasFactorItems: biasFactor\n      };\n    }\n    const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);\n    const targetSizeValue = (0, integer_1.integer)({\n      min: this.minLength,\n      max: maxBiasedLength\n    }).generate(mrng, undefined);\n    return {\n      size: targetSizeValue.value,\n      biasFactorItems: biasFactor\n    };\n  }\n  canShrinkWithoutContext(value) {\n    if (!Array.isArray(value) || this.minLength > value.length || value.length > this.maxLength) {\n      return false;\n    }\n    for (let index = 0; index !== value.length; ++index) {\n      if (!(index in value)) {\n        return false;\n      }\n      if (!this.arb.canShrinkWithoutContext(value[index])) {\n        return false;\n      }\n    }\n    const filtered = this.preFilter(value.map(item => new Value_1.Value(item, undefined)));\n    return filtered.length === value.length;\n  }\n  shrinkItemByItem(value, safeContext, endIndex) {\n    let shrinks = Stream_1.Stream.nil();\n    for (let index = safeContext.startIndex; index < endIndex; ++index) {\n      shrinks = shrinks.join((0, LazyIterableIterator_1.makeLazy)(() => this.arb.shrink(value[index], safeContext.itemsContexts[index]).map(v => {\n        const beforeCurrent = value.slice(0, index).map((v, i) => new Value_1.Value((0, symbols_1.cloneIfNeeded)(v), safeContext.itemsContexts[i]));\n        const afterCurrent = value.slice(index + 1).map((v, i) => new Value_1.Value((0, symbols_1.cloneIfNeeded)(v), safeContext.itemsContexts[i + index + 1]));\n        return [beforeCurrent.concat(v).concat(afterCurrent), undefined, index];\n      })));\n    }\n    return shrinks;\n  }\n  shrinkImpl(value, context) {\n    if (value.length === 0) {\n      return Stream_1.Stream.nil();\n    }\n    const safeContext = context !== undefined ? context : {\n      shrunkOnce: false,\n      lengthContext: undefined,\n      itemsContexts: [],\n      startIndex: 0\n    };\n    return this.lengthArb.shrink(value.length, safeContext.lengthContext).drop(safeContext.shrunkOnce && safeContext.lengthContext === undefined && value.length > this.minLength + 1 ? 1 : 0).map(lengthValue => {\n      const sliceStart = value.length - lengthValue.value;\n      return [value.slice(sliceStart).map((v, index) => new Value_1.Value((0, symbols_1.cloneIfNeeded)(v), safeContext.itemsContexts[index + sliceStart])), lengthValue.context, 0];\n    }).join((0, LazyIterableIterator_1.makeLazy)(() => value.length > this.minLength ? this.shrinkItemByItem(value, safeContext, 1) : this.shrinkItemByItem(value, safeContext, value.length))).join(value.length > this.minLength ? (0, LazyIterableIterator_1.makeLazy)(() => {\n      const subContext = {\n        shrunkOnce: false,\n        lengthContext: undefined,\n        itemsContexts: safeContext.itemsContexts.slice(1),\n        startIndex: 0\n      };\n      return this.shrinkImpl(value.slice(1), subContext).filter(v => this.minLength <= v[0].length + 1).map(v => {\n        return [[new Value_1.Value((0, symbols_1.cloneIfNeeded)(value[0]), safeContext.itemsContexts[0])].concat(v[0]), undefined, 0];\n      });\n    }) : Stream_1.Stream.nil());\n  }\n  shrink(value, context) {\n    return this.shrinkImpl(value, context).map(contextualValue => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));\n  }\n}\nexports.ArrayArbitrary = ArrayArbitrary;","map":{"version":3,"names":["Object","defineProperty","exports","value","ArrayArbitrary","Stream_1","require","symbols_1","integer_1","LazyIterableIterator_1","Arbitrary_1","Value_1","DepthContext_1","BuildSlicedGenerator_1","biasedMaxLength","minLength","maxLength","Math","floor","log","Arbitrary","constructor","arb","maxGeneratedLength","depthIdentifier","setBuilder","customSlices","lengthArb","integer","min","max","depthContext","getDepthContextFor","preFilter","tab","undefined","s","index","length","tryAdd","getData","makeItCloneable","vs","shrinkables","cloneMethod","cloned","idx","push","generateNItemsNoDuplicates","N","mrng","biasFactorItems","numSkippedInRow","slicedGenerator","buildSlicedGenerator","size","current","next","safeGenerateNItemsNoDuplicates","depthImpact","depth","generateNItems","items","attemptExact","safeGenerateNItems","wrapper","itemsRaw","shrunkOnce","itemsRawLengthContext","startIndex","cloneable","itemsContexts","hasToBeCloned","context","lengthContext","Value","generate","biasFactor","biasMeta","applyBias","targetSize","nextInt","maxBiasedLength","targetSizeValue","canShrinkWithoutContext","Array","isArray","filtered","map","item","shrinkItemByItem","safeContext","endIndex","shrinks","Stream","nil","join","makeLazy","shrink","v","beforeCurrent","slice","i","cloneIfNeeded","afterCurrent","concat","shrinkImpl","drop","lengthValue","sliceStart","subContext","filter","contextualValue"],"sources":["/Users/karimelbarbary/Desktop/test4/devote/node_modules/fast-check/lib/arbitrary/_internals/ArrayArbitrary.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArrayArbitrary = void 0;\nconst Stream_1 = require(\"../../stream/Stream\");\nconst symbols_1 = require(\"../../check/symbols\");\nconst integer_1 = require(\"../integer\");\nconst LazyIterableIterator_1 = require(\"../../stream/LazyIterableIterator\");\nconst Arbitrary_1 = require(\"../../check/arbitrary/definition/Arbitrary\");\nconst Value_1 = require(\"../../check/arbitrary/definition/Value\");\nconst DepthContext_1 = require(\"./helpers/DepthContext\");\nconst BuildSlicedGenerator_1 = require(\"./helpers/BuildSlicedGenerator\");\nfunction biasedMaxLength(minLength, maxLength) {\n    if (minLength === maxLength) {\n        return minLength;\n    }\n    return minLength + Math.floor(Math.log(maxLength - minLength) / Math.log(2));\n}\nclass ArrayArbitrary extends Arbitrary_1.Arbitrary {\n    constructor(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, setBuilder, customSlices) {\n        super();\n        this.arb = arb;\n        this.minLength = minLength;\n        this.maxGeneratedLength = maxGeneratedLength;\n        this.maxLength = maxLength;\n        this.setBuilder = setBuilder;\n        this.customSlices = customSlices;\n        this.lengthArb = (0, integer_1.integer)({ min: minLength, max: maxGeneratedLength });\n        this.depthContext = (0, DepthContext_1.getDepthContextFor)(depthIdentifier);\n    }\n    preFilter(tab) {\n        if (this.setBuilder === undefined) {\n            return tab;\n        }\n        const s = this.setBuilder();\n        for (let index = 0; index !== tab.length; ++index) {\n            s.tryAdd(tab[index]);\n        }\n        return s.getData();\n    }\n    static makeItCloneable(vs, shrinkables) {\n        vs[symbols_1.cloneMethod] = () => {\n            const cloned = [];\n            for (let idx = 0; idx !== shrinkables.length; ++idx) {\n                cloned.push(shrinkables[idx].value);\n            }\n            this.makeItCloneable(cloned, shrinkables);\n            return cloned;\n        };\n        return vs;\n    }\n    generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {\n        let numSkippedInRow = 0;\n        const s = setBuilder();\n        const slicedGenerator = (0, BuildSlicedGenerator_1.buildSlicedGenerator)(this.arb, mrng, this.customSlices, biasFactorItems);\n        while (s.size() < N && numSkippedInRow < this.maxGeneratedLength) {\n            const current = slicedGenerator.next();\n            if (s.tryAdd(current)) {\n                numSkippedInRow = 0;\n            }\n            else {\n                numSkippedInRow += 1;\n            }\n        }\n        return s.getData();\n    }\n    safeGenerateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {\n        const depthImpact = Math.max(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));\n        this.depthContext.depth += depthImpact;\n        try {\n            return this.generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems);\n        }\n        finally {\n            this.depthContext.depth -= depthImpact;\n        }\n    }\n    generateNItems(N, mrng, biasFactorItems) {\n        const items = [];\n        const slicedGenerator = (0, BuildSlicedGenerator_1.buildSlicedGenerator)(this.arb, mrng, this.customSlices, biasFactorItems);\n        slicedGenerator.attemptExact(N);\n        for (let index = 0; index !== N; ++index) {\n            const current = slicedGenerator.next();\n            items.push(current);\n        }\n        return items;\n    }\n    safeGenerateNItems(N, mrng, biasFactorItems) {\n        const depthImpact = Math.max(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));\n        this.depthContext.depth += depthImpact;\n        try {\n            return this.generateNItems(N, mrng, biasFactorItems);\n        }\n        finally {\n            this.depthContext.depth -= depthImpact;\n        }\n    }\n    wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {\n        const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;\n        let cloneable = false;\n        const vs = [];\n        const itemsContexts = [];\n        for (let idx = 0; idx !== items.length; ++idx) {\n            const s = items[idx];\n            cloneable = cloneable || s.hasToBeCloned;\n            vs.push(s.value);\n            itemsContexts.push(s.context);\n        }\n        if (cloneable) {\n            ArrayArbitrary.makeItCloneable(vs, items);\n        }\n        const context = {\n            shrunkOnce,\n            lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== undefined\n                ? itemsRawLengthContext\n                : undefined,\n            itemsContexts,\n            startIndex,\n        };\n        return new Value_1.Value(vs, context);\n    }\n    generate(mrng, biasFactor) {\n        const biasMeta = this.applyBias(mrng, biasFactor);\n        const targetSize = biasMeta.size;\n        const items = this.setBuilder !== undefined\n            ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems)\n            : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);\n        return this.wrapper(items, false, undefined, 0);\n    }\n    applyBias(mrng, biasFactor) {\n        if (biasFactor === undefined) {\n            return { size: this.lengthArb.generate(mrng, undefined).value };\n        }\n        if (this.minLength === this.maxGeneratedLength) {\n            return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };\n        }\n        if (mrng.nextInt(1, biasFactor) !== 1) {\n            return { size: this.lengthArb.generate(mrng, undefined).value };\n        }\n        if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) {\n            return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };\n        }\n        const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);\n        const targetSizeValue = (0, integer_1.integer)({ min: this.minLength, max: maxBiasedLength }).generate(mrng, undefined);\n        return { size: targetSizeValue.value, biasFactorItems: biasFactor };\n    }\n    canShrinkWithoutContext(value) {\n        if (!Array.isArray(value) || this.minLength > value.length || value.length > this.maxLength) {\n            return false;\n        }\n        for (let index = 0; index !== value.length; ++index) {\n            if (!(index in value)) {\n                return false;\n            }\n            if (!this.arb.canShrinkWithoutContext(value[index])) {\n                return false;\n            }\n        }\n        const filtered = this.preFilter(value.map((item) => new Value_1.Value(item, undefined)));\n        return filtered.length === value.length;\n    }\n    shrinkItemByItem(value, safeContext, endIndex) {\n        let shrinks = Stream_1.Stream.nil();\n        for (let index = safeContext.startIndex; index < endIndex; ++index) {\n            shrinks = shrinks.join((0, LazyIterableIterator_1.makeLazy)(() => this.arb.shrink(value[index], safeContext.itemsContexts[index]).map((v) => {\n                const beforeCurrent = value\n                    .slice(0, index)\n                    .map((v, i) => new Value_1.Value((0, symbols_1.cloneIfNeeded)(v), safeContext.itemsContexts[i]));\n                const afterCurrent = value\n                    .slice(index + 1)\n                    .map((v, i) => new Value_1.Value((0, symbols_1.cloneIfNeeded)(v), safeContext.itemsContexts[i + index + 1]));\n                return [\n                    beforeCurrent.concat(v).concat(afterCurrent),\n                    undefined,\n                    index,\n                ];\n            })));\n        }\n        return shrinks;\n    }\n    shrinkImpl(value, context) {\n        if (value.length === 0) {\n            return Stream_1.Stream.nil();\n        }\n        const safeContext = context !== undefined\n            ? context\n            : { shrunkOnce: false, lengthContext: undefined, itemsContexts: [], startIndex: 0 };\n        return (this.lengthArb\n            .shrink(value.length, safeContext.lengthContext)\n            .drop(safeContext.shrunkOnce && safeContext.lengthContext === undefined && value.length > this.minLength + 1 ? 1 : 0)\n            .map((lengthValue) => {\n            const sliceStart = value.length - lengthValue.value;\n            return [\n                value\n                    .slice(sliceStart)\n                    .map((v, index) => new Value_1.Value((0, symbols_1.cloneIfNeeded)(v), safeContext.itemsContexts[index + sliceStart])),\n                lengthValue.context,\n                0,\n            ];\n        })\n            .join((0, LazyIterableIterator_1.makeLazy)(() => value.length > this.minLength\n            ? this.shrinkItemByItem(value, safeContext, 1)\n            : this.shrinkItemByItem(value, safeContext, value.length)))\n            .join(value.length > this.minLength\n            ? (0, LazyIterableIterator_1.makeLazy)(() => {\n                const subContext = {\n                    shrunkOnce: false,\n                    lengthContext: undefined,\n                    itemsContexts: safeContext.itemsContexts.slice(1),\n                    startIndex: 0,\n                };\n                return this.shrinkImpl(value.slice(1), subContext)\n                    .filter((v) => this.minLength <= v[0].length + 1)\n                    .map((v) => {\n                    return [\n                        [new Value_1.Value((0, symbols_1.cloneIfNeeded)(value[0]), safeContext.itemsContexts[0])].concat(v[0]),\n                        undefined,\n                        0,\n                    ];\n                });\n            })\n            : Stream_1.Stream.nil()));\n    }\n    shrink(value, context) {\n        return this.shrinkImpl(value, context).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));\n    }\n}\nexports.ArrayArbitrary = ArrayArbitrary;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}